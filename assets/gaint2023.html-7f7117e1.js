import{_ as l}from"./v2-8cec22d735be76cd4a140ac30513ca49_b-96a3f059.js";import{_ as p,W as r,X as c,a0 as n,a1 as s,Z as a,a2 as u,$ as t,C as o}from"./framework-c8643d23.js";const d="/Computer-Science-Learn-Notes/assets/641-578d5863.png",k="/Computer-Science-Learn-Notes/assets/n1ql-query-workflow-1bdb3bce.png",h="/Computer-Science-Learn-Notes/assets/n1ql-query-workflow-cover-idx-98e67a6c.png",g="/Computer-Science-Learn-Notes/assets/640-cd2471c0.png",m="/Computer-Science-Learn-Notes/assets/91-04b15948.jpg",v="/Computer-Science-Learn-Notes/assets/92-afaa56b0.jpg",b={},y=n("h2",{id:"前言",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#前言","aria-hidden":"true"},"#"),s(" 前言")],-1),f=t(`<h2 id="🐦java-基础" tabindex="-1"><a class="header-anchor" href="#🐦java-基础" aria-hidden="true">#</a> 🐦Java 基础</h2><h3 id="arraylist线程安全吗-把arraylist变成线程安全有哪些方法-2023美团" tabindex="-1"><a class="header-anchor" href="#arraylist线程安全吗-把arraylist变成线程安全有哪些方法-2023美团" aria-hidden="true">#</a> ArrayList线程安全吗？把ArrayList变成线程安全有哪些方法？（2023美团）</h3><p>将ArrayList变成线程安全有几种方法：</p><ol><li>使用<strong>Collections.synchronizedList()</strong> 方法将ArrayList转换为线程安全的List。该方法会返回一个线程安全的List，使用该List时需要在访问它的方法上添加synchronized关键字，以保证多线程访问的安全性。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Collections</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> synchronizedList <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>使用<strong>CopyOnWriteArrayList</strong>类来代替ArrayList。CopyOnWriteArrayList是一种线程安全的List实现，它通过在写操作时复制整个数组来保证线程安全性，在读操作时不需要加锁，因此可以提高读取效率。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CopyOnWriteArrayList</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>使用<strong>Lock接口</strong>来实现同步。可以使用ReentrantLock类来实现对ArrayList的同步操作，该类提供了与synchronized类似的功能，但是具有更高的灵活性。比如可以使用tryLock()方法来尝试获取锁，避免了线程的长时间等待。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对 ArrayList 的操作</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>使用<strong>读写锁</strong>来实现同步。可以使用ReentrantReadWriteLock类来实现对ArrayList的读写操作的同步。该类提供了读锁和写锁两种锁，多个线程可以同时获取读锁，但是只有一个线程可以获取写锁，在写操作时需要先获取写锁，以保证线程安全。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ReadWriteLock</span> rwLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对 ArrayList 的读操作</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
rwLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对 ArrayList 的写操作</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    rwLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>使用 <strong>Vector</strong>: Vector 是一个线程安全的类，与 ArrayList 非常相似，可以作为替代品。但是，由于 Vector 的所有方法都是同步的，这可能会导致性能问题。</li></ol>`,12),_=n("p",null,"参考文献：",-1),w={href:"https://stackoverflow.com/questions/2444005/how-do-i-make-my-arraylist-thread-safe-another-approach-to-problem-in-java",target:"_blank",rel:"noopener noreferrer"},S={href:"https://stackoverflow.com/questions/18983362/how-to-prove-arraylist-is-not-thread-safe-with-a-test",target:"_blank",rel:"noopener noreferrer"},x={href:"https://stackoverflow.com/questions/300519/arraylist-vs-vectors-in-java-if-thread-safety-isnt-a-concern",target:"_blank",rel:"noopener noreferrer"},C=n("h3",{id:"arraylist的并发修改异常了解吗-单线程情况下会发生吗-2023小红书",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#arraylist的并发修改异常了解吗-单线程情况下会发生吗-2023小红书","aria-hidden":"true"},"#"),s(" ArrayList的并发修改异常了解吗？单线程情况下会发生吗？（2023小红书）")],-1),L=n("p",null,"这种异常通常发生在对ArrayList进行遍历时，同时尝试修改它的结构（例如添加或删除元素）。这种异常被称为ConcurrentModificationException。",-1),q=n("p",null,"在单线程情况下，这种异常也可能发生。当你在使用迭代器遍历ArrayList集合时，如果使用ArrayList的方法（如add()或remove()）修改了集合的结构，就可能触发这个异常。这是因为ArrayList的内部实现使用了一个modCount变量来跟踪结构修改的次数。当迭代器检测到modCount发生变化时，它会抛出ConcurrentModificationException异常。",-1),R=n("p",null,"为了避免这种异常，你可以在遍历ArrayList时采用以下方法：",-1),M=n("ol",null,[n("li",null,"使用Iterator的remove()方法来删除元素，而不是直接使用ArrayList的remove()方法。这样可以确保modCount的值在迭代过程中保持一致。"),n("li",null,"如果需要遍历过程中添加元素，可以考虑使用ListIterator，它提供了add()方法，允许在遍历过程中修改列表结构。"),n("li",null,"另一种方法是使用Java 8的Stream API，它提供了一种更安全的方式来处理集合的并发修改问题。"),n("li",null,"如果你确实需要在遍历过程中修改ArrayList，可以考虑先复制一个新的ArrayList，然后在新的ArrayList上进行修改。遍历完成后，再将新的ArrayList赋值给原来的引用。这样可以避免在遍历过程中修改原始ArrayList的结构。")],-1),A=n("p",null,"参考：",-1),T={href:"https://stackoverflow.com/questions/602636/why-is-a-concurrentmodificationexception-thrown-and-how-to-debug-it",target:"_blank",rel:"noopener noreferrer"},E={href:"https://www.javatpoint.com/concurrentmodificationexception-in-java",target:"_blank",rel:"noopener noreferrer"},P=t(`<h3 id="面向过程的方法存在哪些问题-2023美团" tabindex="-1"><a class="header-anchor" href="#面向过程的方法存在哪些问题-2023美团" aria-hidden="true">#</a> 面向过程的方法存在哪些问题？（2023美团）</h3><ol><li>可维护性较差：面向过程编程主要依赖于函数和过程，随着代码规模的增大，可能会导致代码结构复杂，不易维护。</li><li>可复用性较低：面向过程编程难以实现模块化，导致代码难以复用，进一步增加开发时间和成本。</li><li>扩展性不足：面向过程编程在代码逻辑发生变化时，往往需要对程序进行大量的修改，这样的代码扩展性不足。</li><li>抽象能力有限：面向过程编程主要关注过程和算法，而不是数据结构和对象，这使得它在表达现实世界的复杂问题时抽象能力有限。</li><li>封装性差：面向过程编程没有提供良好的封装机制，程序中的数据和处理过程容易暴露，可能导致数据安全性和程序稳定性问题。</li><li>强耦合：面向过程编程的方法往往导致程序组件之间存在强耦合，当一个组件发生变化时，可能会影响其他组件的正常工作。</li></ol><h3 id="面向过程好处是什么-2023美团" tabindex="-1"><a class="header-anchor" href="#面向过程好处是什么-2023美团" aria-hidden="true">#</a> 面向过程好处是什么？（2023美团）</h3><ul><li>面向过程编程采用自顶向下的编程方式，将问题分解为一个个小的模块，便于理解和编写。</li><li>每个模块相对独立，出现问题时可以单独调试，降低了调试难度。</li><li>面向过程编程适合解决简单、逻辑性强的问题，对于初学者来说，学习成本较低。</li></ul><h3 id="object-有哪些方法-2023百度" tabindex="-1"><a class="header-anchor" href="#object-有哪些方法-2023百度" aria-hidden="true">#</a> object 有哪些方法（2023百度）</h3><p>当面试官问到 Java 中 Object 类的方法时，如果你无法记住所有的方法，可以采用以下回答策略：</p><ul><li>强调<strong>基本方法</strong>：首先提及最常用和最基本的几个方法，如 equals()、hashCode()、toString()，这些方法几乎在每个对象中都会用到。 <ul><li>equals(Object obj): 检查当前对象是否与另一个对象相等。</li><li>hashCode(): 返回对象的哈希码值。</li><li>toString(): 返回对象的字符串表示。</li></ul></li><li>提及<strong>重要的方法</strong>：接下来可以提及一些较为重要的方法，如 getClass() 用于获取对象的运行时类，clone() 用于创建对象的副本等。 <ul><li>clone(): 创建并返回当前对象的副本。</li><li>getClass(): 返回对象的运行时类。</li></ul></li><li>谈论<strong>对象间的通信</strong>：强调 wait()、notify()、notifyAll() 这些用于线程间通信的方法，说明其在多线程编程中的作用。 <ul><li>notify(): 唤醒在该对象上等待的单个线程。</li><li>notifyAll(): 唤醒在该对象上等待的所有线程。</li><li>wait(): 导致当前线程等待，直到另一个线程调用该对象的 notify() 或 notifyAll() 方法。</li></ul></li><li>谈论<strong>垃圾回收</strong>：提及 finalize() 方法，它在对象被垃圾回收之前调用，可以用于执行一些清理操作。 <ul><li>finalize(): 在对象被垃圾回收器回收之前调用。</li></ul></li></ul><h3 id="如果让你自己实现一个-map-你会怎么做-2023百度" tabindex="-1"><a class="header-anchor" href="#如果让你自己实现一个-map-你会怎么做-2023百度" aria-hidden="true">#</a> 如果让你自己实现一个 map 你会怎么做（2023百度）</h3><p>我认为这个问题可以转换一个思路：设计一个Map这样的数据结构时，需要考虑以下因素？</p><ul><li><strong>哈希函数</strong>：哈希函数用于将键转化为数组索引。好的哈希函数应尽量使得每个键都映射到不同的索引上，以减少冲突。</li><li><strong>冲突处理</strong>：如果两个不同的键哈希到相同的索引上，就会产生冲突。常见的冲突处理方法有链地址法和开放地址法。</li><li><strong>动态扩容</strong>：如果Map中的元素数量超过了当前数组的大小，就需要对数组进行扩容。扩容的过程通常会重新哈希所有元素，因此需要考虑何时进行扩容以及如何高效地进行扩容。</li><li><strong>数据类型</strong>：需要考虑存储的数据类型，是基础类型还是自定义类型。如果是自定义类型，需要考虑如何定义哈希函数和相等性判断。</li><li><strong>线程安全</strong>：是否需要支持多线程环境？如果需要，如何保证线程安全？</li><li><strong>API设计</strong>：如何设计API使得使用者容易理解和使用？</li><li><strong>性能考虑</strong>：需要考虑Map的主要操作（插入，删除，查找）的时间复杂性。对于Java的HashMap，这些操作的平均时间复杂性为O(1)。</li></ul><h3 id="作为-map-的-key-需要重写哪些方法-2023完美世界" tabindex="-1"><a class="header-anchor" href="#作为-map-的-key-需要重写哪些方法-2023完美世界" aria-hidden="true">#</a> 作为 map 的 key 需要重写哪些方法？（2023完美世界）</h3><p>首先，先理解面试题的意思，可以理解为：<strong>如果你要用自己的类的对象作为Map的键，你需要重写这个类的哪些方法？</strong></p><ul><li>在Java中，Map接口是基于键值对的，每个键都必须是唯一的。Java使用键对象的hashCode()方法来计算哈希值，这个哈希值用于确定在Map内部存储结构中的位置。同时，Java也使用键对象的equals()方法来检查两个键是否相等。</li><li>所以，如果你的类的对象要作为Map的键使用，那么通常需要你重写这个类的hashCode()和equals()方法，以确保它们的行为符合预期。</li><li>如果不重写这两个方法，那么默认的hashCode()方法将返回每个对象的内存地址，equals()方法将仅比较两个对象的内存地址。这可能会导致不符合预期的行为，比如两个内容完全相同但内存地址不同的对象被视为不同的键。</li></ul><p>在Java中，作为Map的键（key），你通常需要重写以下两个方法：</p><ol><li><strong>hashCode()</strong>：这个方法返回对象的哈希码，用于确定在哈希表中的存储位置。如果两个对象被认为相等（根据equals()方法），那么它们的hashCode()方法必须返回相同的值。</li><li><strong>equals()</strong>：这个方法用来判断两个对象是否相等。在Java的Map中，当我们调用get(key)或containsKey(key)方法时，Map实现会用这个方法来查找与给定键匹配的键。</li></ol><p>当你创建自定义的类并打算将其实例用作Map的键时，通常需要覆盖这两个方法以确保它们的行为符合预期。如果不这样做，Map可能无法正确地查找、添加或删除键值对。</p><h3 id="list的实现类-2023阿里" tabindex="-1"><a class="header-anchor" href="#list的实现类-2023阿里" aria-hidden="true">#</a> List的实现类（2023阿里）</h3><p>Java中的List接口有多个实现类，常用的包括：</p><ul><li>ArrayList：基于动态数组实现，优势在于支持随机访问和快速插入/删除元素，适用于频繁读取和遍历的场景。</li><li>LinkedList：基于双向链表实现，优势在于支持快速插入/删除元素，适用于频繁插入/删除元素的场景。</li><li>Vector：和ArrayList类似，但由于其线程安全性，适用于多线程环境。</li><li>Stack：基于Vector实现，是一个后进先出（LIFO）的数据结构，适用于需要按照后进先出顺序处理元素的场景。</li></ul><h3 id="list和set的区别-2023阿里" tabindex="-1"><a class="header-anchor" href="#list和set的区别-2023阿里" aria-hidden="true">#</a> List和Set的区别（2023阿里）</h3><ol><li>顺序：List是有序的集合，它可以按照元素插入的顺序进行存储和访问。而Set是无序的集合，元素在集合中的位置是不固定的。</li><li>重复元素：List允许存储重复的元素，即可以有多个相同的对象。Set不允许存储重复的元素，即每个对象在集合中只能出现一次。</li><li>实现类：List的常用实现类有ArrayList和LinkedList，分别使用数组和链表作为底层数据结构。Set的常用实现类有HashSet、LinkedHashSet和TreeSet，分别基于哈希表、链表+哈希表和红黑树实现。</li><li>性能：由于底层数据结构的差异，List和Set在增加、删除、查找等操作上的性能表现有所不同。例如，ArrayList在随机访问元素时性能较好，而LinkedList在插入和删除元素时性能较好。HashSet在查找、添加和删除元素时性能较好，但不保证元素顺序。TreeSet在保持元素排序的同时，也能提供较好的查找性能。</li></ol><blockquote><p>补充： Queue(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。 Map(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，&quot;x&quot; 代表 key，&quot;y&quot; 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p></blockquote><h3 id="针对你说的list和set的性质-那你会用这两种结构解决哪些问题-2023阿里" tabindex="-1"><a class="header-anchor" href="#针对你说的list和set的性质-那你会用这两种结构解决哪些问题-2023阿里" aria-hidden="true">#</a> 针对你说的List和Set的性质，那你会用这两种结构解决哪些问题（2023阿里）</h3><p>List（列表）适用于以下场景：</p><ol><li>有序数据：列表中的元素按照插入顺序存储，因此适用于需要保持元素顺序的场景。</li><li>允许重复元素：列表允许存储重复的元素，因此适用于需要统计元素出现次数的场景。</li><li>需要根据索引进行查找、插入和删除操作：列表允许通过索引值直接访问、插入或删除元素，适用于需要频繁进行这些操作的场景。</li></ol><p>Set（集合）适用于以下场景：</p><ol><li>去重：集合中的元素不能重复，因此适用于去除数据中重复元素的场景。</li><li>无需关心元素顺序：集合中的元素没有固定顺序，适用于元素顺序无关紧要的场景。</li><li>快速判断元素是否存在：集合提供了高效率的查找算法，适用于需要快速判断某个元素是否存在于数据集中的场景。</li><li>集合运算：集合支持交集、并集、差集等运算，适用于需要进行这些运算的场景。</li></ol><h2 id="🕝-并发编程" tabindex="-1"><a class="header-anchor" href="#🕝-并发编程" aria-hidden="true">#</a> 🕝 并发编程</h2><h3 id="线程池的拒绝策略能自定义拒绝策略吗-2023阿里" tabindex="-1"><a class="header-anchor" href="#线程池的拒绝策略能自定义拒绝策略吗-2023阿里" aria-hidden="true">#</a> 线程池的拒绝策略能自定义拒绝策略吗？（2023阿里）</h3><p>Java线程池拒绝策略是可以自定义的。你可以使用<code>RejecttedExecutionHandler</code>接口来定义你自己的拒绝策略。该接口只有一个方法拒绝执行（Runnable r，ThreadPoolExecator执行器），当执行器无法执行任务时调用。你可以实现这个方法来定义你自己的拒绝策略。</p><p>示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomRejectedExecutionHandler</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Your custom rejection policy here</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
        corePoolSize<span class="token punctuation">,</span>
        maxPoolSize<span class="token punctuation">,</span>
        keepAliveTime<span class="token punctuation">,</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">CustomRejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用多线程要注意哪些问题-2023美团" tabindex="-1"><a class="header-anchor" href="#使用多线程要注意哪些问题-2023美团" aria-hidden="true">#</a> 使用多线程要注意哪些问题？（2023美团）</h3><p>使用多线程时需要注意以下问题：</p><ol><li><strong>线程安全</strong>：当多个线程同时访问某一数据时，如果不进行正确的同步控制，可能会导致数据的不一致。需要通过使用synchronized，Lock，volatile等机制来保证线程安全。</li><li><strong>死锁</strong>：死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那他们都将无法推进下去。我们应避免在代码中产生死锁。</li><li><strong>活锁</strong>：活锁指的是线程虽然没有被阻塞，但是由于某种条件没有被满足，始终无法向前执行，就像在原地踏步。</li><li><strong>饥饿</strong>：由于线程的优先级设置不合理或者锁机制不公平，导致某些线程始终无法获取到CPU资源或者锁资源，从而无法进行工作。</li><li><strong>资源消耗</strong>：每个线程都会占用一定的内存资源，过多的线程可能会导致系统资源消耗过大。同时，线程上下文切换也会消耗CPU资源，过多的线程也可能会导致CPU负载过大。</li><li><strong>数据共享和可见性</strong>：多线程之间共享数据，需要保证一个线程对数据的修改对其他线程可见，可以使用volatile或者Atomic类来保证。</li><li><strong>线程的生命周期管理</strong>：需要合理的创建、启动、暂停、恢复、终止线程，不合理的管理可能会导致程序错误或者资源泄漏。</li><li><strong>线程异常处理</strong>：线程中的未捕获异常会导致线程终止，而且这个异常不能被外部捕获。需要为线程设置UncaughtExceptionHandler来处理未捕获的异常。</li></ol><h3 id="保证数据的一致性有哪些方案呢-2023美团" tabindex="-1"><a class="header-anchor" href="#保证数据的一致性有哪些方案呢-2023美团" aria-hidden="true">#</a> 保证数据的一致性有哪些方案呢？（2023美团）</h3><p>在Java中，有多种方式可以保证数据的一致性：</p><ol><li><strong>同步语句块(Synchronized Blocks)</strong>：在Java中，你可以使用synchronized关键字对一个对象或者方法进行锁定，来保证在一个时刻只有一个线程可以访问该对象或者方法，从而避免数据的不一致。</li><li><strong>Volatile关键字</strong>：volatile关键字可以保证变量的可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去主存中读取新值。</li><li><strong>原子类（Atomic Classes）</strong>：Java提供了一组原子类（如AtomicInteger、AtomicLong等），它们使用了高效的机器级指令来保证原子性操作，从而避免了复杂的同步。</li><li><strong>Lock接口和相关类</strong>：Java并发库提供了显式的锁机制，包括ReentrantLock、ReadWriteLock等，可以提供比synchronized更灵活的锁定机制。</li><li><strong>并发集合（Concurrent Collections）</strong>：Java提供了一组并发集合类（如ConcurrentHashMap、CopyOnWriteArrayList等），它们内部已经实现了并发控制，可以在并发环境中安全使用。</li><li><strong>事务（Transactions）</strong>：在数据库和某些支持事务的系统中，可以通过事务来保证数据的一致性。Java中的JPA和Spring等框架提供了对事务的支持。</li></ol><p>以上就是在Java中保证数据一致性的一些常用方案，选择哪种方案取决于具体的应用场景和需求。</p><h2 id="🍃-常用框架" tabindex="-1"><a class="header-anchor" href="#🍃-常用框架" aria-hidden="true">#</a> 🍃 常用框架</h2><h3 id="mybatis运用了哪些常见的设计模式-2023美团" tabindex="-1"><a class="header-anchor" href="#mybatis运用了哪些常见的设计模式-2023美团" aria-hidden="true">#</a> MyBatis运用了哪些常见的设计模式？（2023美团）</h3><ul><li><strong>工厂模式</strong>，工厂模式在 MyBatis 中的典型代表是 SqlSessionFactory</li><li><strong>建造者模式</strong>，建造者模式在 MyBatis 中的典型代表是 SqlSessionFactoryBuilder</li><li><strong>单例模式</strong>，单例模式在 MyBatis 中的典型代表是 ErrorContext</li><li><strong>适配器模式</strong>，适配器模式在 MyBatis 中的典型代表是 Log</li><li><strong>代理模式</strong>，代理模式在 MyBatis 中的典型代表是 MapperProxyFactory</li><li><strong>模板方法模式</strong>，模板方法在 MyBatis 中的典型代表是 BaseExecutor</li><li><strong>装饰器模式</strong>，装饰器模式在 MyBatis 中的典型代表是 Cache</li><li><strong>迭代器模式</strong>，如迭代器模式Properties tyTokenizer；</li><li><strong>组合模式</strong>，如SqlNode和每个子类ChooseSqlNode；</li></ul>`,42),j=n("p",null,"参考文献：",-1),O={href:"https://programming.vip/docs/6200e8e7b682c.html",target:"_blank",rel:"noopener noreferrer"},J={href:"https://programming.vip/docs/mybatis-design-pattern.html",target:"_blank",rel:"noopener noreferrer"},B=t('<h3 id="mybatis中创建了一个mapper接口-在写一个xml文件-java的接口是要实现的-为什么这没有实现呢-2023美团" tabindex="-1"><a class="header-anchor" href="#mybatis中创建了一个mapper接口-在写一个xml文件-java的接口是要实现的-为什么这没有实现呢-2023美团" aria-hidden="true">#</a> MyBatis中创建了一个Mapper接口，在写一个xml文件，java的接口是要实现的，为什么这没有实现呢？（2023美团）</h3><p>MyBatis中的Mapper接口并不需要实现，它只是定义了一组方法签名。MyBatis会根据Mapper接口中的方法名、参数类型和返回值类型，自动生成实现方法。因此，Mapper接口中的方法不需要实现，也不需要在该接口中编写任何方法体。</p><p>相反，你需要编写一个与Mapper接口同名的XML文件，来实现这些方法的具体SQL操作。这样，当你在Java代码中调用Mapper接口中的方法时，MyBatis会自动将该方法映射到对应的XML文件中的SQL语句，并执行该语句。</p><h3 id="与传统的jdbc相比-mybatis的优点-2023美团" tabindex="-1"><a class="header-anchor" href="#与传统的jdbc相比-mybatis的优点-2023美团" aria-hidden="true">#</a> 与传统的JDBC相比，MyBatis的优点？（2023美团）</h3><p>在面试中，可以按照以下的方式来回答：</p><ol><li>首先，我认为最大的优点是MyBatis提供了更高的<strong>灵活性</strong>。我们可以直接编写SQL，这样可以充分利用数据库的特性并且更好地控制查询。</li><li>其次，MyBatis使我们<strong>无需手动</strong>转换数据，它能自动将结果集映射到Java对象，这大大简化了编程工作。</li><li>此外，MyBatis支持<strong>动态SQL</strong>，我们可以在SQL语句中使用动态元素，如if、choose等，从而能够创建更复杂的查询。</li><li>除此之外，MyBatis将SQL语句放在<strong>XML文件或注解</strong>中，实现了SQL与Java代码的分离，这使得代码更加易于维护。</li><li>MyBatis也能<strong>更好地处理一对多、多对多</strong>等复杂关系。</li><li>最后，MyBatis提供了<strong>一些JDBC无法提供的特性</strong>，如延迟加载，这对于性能优化是非常有用的。</li></ol><h3 id="jdbc连接数据库的步骤吗-2023美团" tabindex="-1"><a class="header-anchor" href="#jdbc连接数据库的步骤吗-2023美团" aria-hidden="true">#</a> JDBC连接数据库的步骤吗？（2023美团）</h3>',7),I=n("ol",null,[n("li",null,[n("strong",null,"加载数据库驱动程序"),s('：首先，我们需要加载数据库驱动。这可以通过 Class.forName() 方法实现，例如 Class.forName("com.mysql.jdbc.Driver")。')]),n("li",null,[n("strong",null,"建立数据库连接"),s('：使用DriverManager.getConnection()方法建立与数据库的连接，需要指定数据库的URL、用户名和密码，例如：Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/mydatabase", "username", "password");')]),n("li",null,[n("strong",null,"创建Statement对象"),s("：使用Connection对象的createStatement()方法创建一个Statement对象，用于执行SQL语句，例如：Statement stmt = conn.createStatement();")]),n("li",null,[n("strong",null,"执行SQL语句"),s('：使用Statement对象的executeQuery()或executeUpdate()方法执行SQL语句，例如：ResultSet rs = stmt.executeQuery("SELECT * FROM mytable");')]),n("li",{String:"",name:"",class:'rsgetString("name"); rsgetInt("age");',int:"",age:""},[n("strong",null,"处理查询结果"),s("：如果执行的是查询语句，需要使用ResultSet对象来处理查询结果，例如：while (rs.next())")]),n("li",null,[n("strong",null,"关闭数据库连接"),s("：在程序结束时，需要使用Connection对象的close()方法关闭数据库连接，例如：conn.close();")])],-1),z=t(`<h3 id="怎么理解springioc-2023美团" tabindex="-1"><a class="header-anchor" href="#怎么理解springioc-2023美团" aria-hidden="true">#</a> 怎么理解SpringIoc？（2023美团）</h3><p><strong>IoC（Inversion of Control）是“控制反转”</strong> 的缩写，是一种设计思想，也是Spring框架的核心。IoC是将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好IoC呢？可以从以下几点来看：</p><ol><li><strong>控制反转</strong>：传统的程序是由我们自己在对象内部通过new进行创建对象，是由程序控制对象的创建。在Spring框架中，对象的创建是由Spring容器来进行的，它负责控制对象的生命周期。所谓“控制反转”就是把传统的有我们自己控制的对象创建过程交给Spring框架来做。</li><li><strong>依赖注入</strong>：IoC的一个重要的具体实现方法是DI（Dependency Injection），也叫作依赖注入。在我们设计好的对象中会有一些其他对象的引用（即依赖），如果没有Spring容器，我们需要使用很多复杂的方法来管理这些依赖。而有了Spring容器，我们只需要告诉Spring这些依赖即可，Spring会自动把这些依赖注入到对象中。</li><li><strong>容器</strong>：在Spring的IoC下，Spring容器是一个非常重要的角色，它包含并管理了应用中定义的各种组件，负责实例化、配置、装配对象，管理对象的整个生命周期。</li><li><strong>减轻耦合</strong>：通过IoC，对象间的耦合度可以降低，对象只需要关注自身的业务逻辑，而不需要关心其他对象是如何创建和管理的，大大增强了代码的可维护性和可测试性。</li><li><strong>提供配置</strong>：Spring容器可以使用XML、Java注解、Java代码等多种方式来进行配置，提供了非常大的灵活性。</li></ol><h3 id="如果让你设计一个springioc-你觉得会从哪些方面考虑这个设计-2023美团" tabindex="-1"><a class="header-anchor" href="#如果让你设计一个springioc-你觉得会从哪些方面考虑这个设计-2023美团" aria-hidden="true">#</a> 如果让你设计一个SpringIoc，你觉得会从哪些方面考虑这个设计？（2023美团）</h3><ul><li>Bean的生命周期管理：需要设计Bean的创建、初始化、销毁等生命周期管理机制，可以考虑使用工厂模式和单例模式来实现。</li><li>依赖注入：需要实现依赖注入的功能，包括属性注入、构造函数注入、方法注入等，可以考虑使用反射机制和XML配置文件来实现。</li><li>Bean的作用域：需要支持多种Bean作用域，比如单例、原型、会话、请求等，可以考虑使用Map来存储不同作用域的Bean实例。</li><li>AOP功能的支持：需要支持AOP功能，可以考虑使用动态代理机制和切面编程来实现。</li><li>异常处理：需要考虑异常处理机制，包括Bean创建异常、依赖注入异常等，可以考虑使用try-catch机制来处理异常。</li><li>配置文件加载：需要支持从不同的配置文件中加载Bean的相关信息，可以考虑使用XML、注解或者Java配置类来实现。</li></ul><h3 id="spring给我们提供了很多扩展点-这些有了解吗-2023美团" tabindex="-1"><a class="header-anchor" href="#spring给我们提供了很多扩展点-这些有了解吗-2023美团" aria-hidden="true">#</a> Spring给我们提供了很多扩展点，这些有了解吗？（2023美团）</h3><ol><li>BeanFactoryPostProcessor：允许在Spring容器实例化bean之前修改bean的定义。常用于修改bean属性或改变bean的作用域。</li><li>BeanPostProcessor：可以在bean实例化、配置以及初始化之后对其进行额外处理。常用于代理bean、修改bean属性等。</li><li>PropertySource：用于定义不同的属性源，如文件、数据库等，以便在Spring应用中使用。</li><li>ImportSelector和ImportBeanDefinitionRegistrar：用于根据条件动态注册bean定义，实现配置类的模块化。</li><li>Spring MVC中的HandlerInterceptor：用于拦截处理请求，可以在请求处理前、处理中和处理后执行特定逻辑。</li><li>Spring MVC中的ControllerAdvice：用于全局处理控制器的异常、数据绑定和数据校验。</li><li>Spring Boot的自动配置：通过创建自定义的自动配置类，可以实现对框架和第三方库的自动配置。</li><li>自定义注解：创建自定义注解，用于实现特定功能或约定，如权限控制、日志记录等。</li></ol><h3 id="大致了解springmvc的处理流程吗-2023美团" tabindex="-1"><a class="header-anchor" href="#大致了解springmvc的处理流程吗-2023美团" aria-hidden="true">#</a> 大致了解SpringMVC的处理流程吗？（2023美团）</h3><ol><li><strong>接收请求</strong>：用户发送请求至前端控制器DispatcherServlet。</li><li><strong>查找处理器映射</strong>：DispatcherServlet收到请求后，调用HandlerMapping处理器映射器。</li><li><strong>处理器映射返回处理器执行链</strong>：HandlerMapping根据请求的URL找到对应的Controller并返回一个HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象）。</li><li><strong>调用处理器适配器</strong>：DispatcherServlet通过HandlerAdapter进行多类型的页面控制器的适配，调用对应的Controller（处理器）。</li><li><strong>Controller执行业务逻辑</strong>：Controller开始执行页面控制器的处理方法，并返回一个ModelAndView对象（模型和视图）。</li><li><strong>视图解析</strong>：DispatcherServlet通过视图解析器进行解析（根据逻辑视图名解析成实际视图/页面），并将ModelAndView对象中的模型数据填充到request域对象中。</li><li><strong>返回视图</strong>：DispatcherServlet把返回的视图对象返回给用户。</li></ol><h3 id="springaop主要想解决什么问题-2023美团" tabindex="-1"><a class="header-anchor" href="#springaop主要想解决什么问题-2023美团" aria-hidden="true">#</a> SpringAOP主要想解决什么问题（2023美团）</h3><ol><li>代码分离：在许多应用程序中，你可能会发现你需要在多个方法或对象中重复相同的代码块，比如日志记录、事务管理、权限检查等。这种情况下，代码不是真正的分离，各部分功能模块的职责并不清晰。通过使用AOP，你可以把这些代码集中在一起，然后应用到程序的其他部分，实现&quot;横切关注点&quot;（cross-cutting concerns）的有效管理。</li><li>维护性：如果你需要修改一些重复的代码（比如更改日志记录的格式），你可能需要在多个位置进行更改。使用AOP，你只需要在一个地方更改，减少了出错的可能性，提高了代码的维护性。</li><li>可读性：AOP可以使得代码的可读性增强。因为重复的、固定的代码被分离出来，业务代码更加清晰，易于理解。</li><li>可重用性：由于AOP能将横切关注点抽象成独立的模块，这些模块可以在多个应用中重用。</li></ol><p>总的来说，Spring AOP能够让开发者更好地关注业务逻辑的开发，而将诸如日志记录、安全控制、事务处理等公共任务抽象和集中处理，从而提高代码的可维护性、可读性和可重用性。</p><h3 id="springaop的原理了解吗-2023美团、2023完美世界" tabindex="-1"><a class="header-anchor" href="#springaop的原理了解吗-2023美团、2023完美世界" aria-hidden="true">#</a> SpringAOP的原理了解吗（2023美团、2023完美世界）</h3><p>Spring AOP (Aspect-Oriented Programming)其主要目的是将业务逻辑与系统服务解耦。在 Spring 中，AOP 的实现主要通过代理实现。下面是一些关于其工作原理的关键点：</p><ol><li><strong>代理模式</strong>：Spring AOP 的实现主要依赖于代理模式。在运行时，Spring AOP 动态地在目标对象与实际对象之间创建一个代理对象，然后通过代理对象实现对目标对象的访问。</li><li><strong>JoinPoint</strong>：这是程序执行过程中明确的点，比如方法的调用或特定的异常被抛出。在 Spring AOP 中，一个 JoinPoint 总是代表一个方法的执行。</li><li><strong>PointCut</strong>：这是一组 JoinPoint，你可以通过表达式或规则定义。</li><li><strong>Advice</strong>：这是实际要在程序特定的 JoinPoint 执行的动作。它的类型可以是 Before, After, AfterReturning, AfterThrowing, Around 等。</li><li><strong>Aspect</strong>：这是一个关注点的模块化，这种关注点实现了某一种跨越一个应用程序的功能，通常包含一些 Advices 和 PointCuts。</li><li><strong>Target Object</strong>：代理模式的目标对象。</li><li><strong>AOP Proxy</strong>：AOP 框架创建的对象，包含了 advice。</li></ol><p>Spring AOP 使用这些元素来确保横切关注点（cross-cutting concerns）在应用中适当的位置被执行。Spring 可以在运行时动态地将 Advice 应用到目标对象上，从而实现了解耦和代码重用。</p><p>在 Spring AOP 中，有两种类型的 AOP 代理：</p><ul><li>基于 JDK 的动态代理：如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。在这种情况下，生成的代理对象会实现被代理对象所实现的接口。</li><li>CGLIB 代理：如果被代理的目标对象没有实现任何接口，则 Spring AOP 会创建一个被代理对象的子类，然后增强被代理对象的方法，这就是所谓的 CGLIB 代理。 所有这些都为开发者提供了一个强大的工具，使他们能够将业务逻辑和系统服务（如事务管理、日志、安全等）分开，从而使业务代码更简洁、更易于维护和复用。</li></ul><blockquote><p>面试的时候可以这样回答： 🙋‍♂️ &quot;Spring AOP 是一种面向切面编程的实现，它通过动态代理方式解耦了业务逻辑和系统服务。其主要组成部分包括 JoinPoint（程序执行过程中的某个特定点，如方法调用），PointCut（一组可以通过表达式或规则定义的 JoinPoint），Advice（在特定的 JoinPoint 执行的代码），和 Aspect（包含 Advice 和 PointCut 的模块）。 Spring AOP 根据目标对象是否实现接口来选择使用 JDK 动态代理还是 CGLIB 代理。如果目标对象实现了接口，Spring AOP 就会用 JDK 动态代理，否则会用 CGLIB 代理。这样，在运行时，Spring AOP 可以动态地将 Advice 应用到目标对象，实现系统服务和业务逻辑的解耦。 通过这种方式，我们可以将一些通用的系统服务（比如事务管理、日志、安全等）抽象出来，从而使业务代码更简洁、更易于维护和复用。&quot;</p></blockquote><h3 id="拦截器有几个方法-分别在什么时候执行-对比过滤器-2023完美世界" tabindex="-1"><a class="header-anchor" href="#拦截器有几个方法-分别在什么时候执行-对比过滤器-2023完美世界" aria-hidden="true">#</a> 拦截器有几个方法，分别在什么时候执行，对比过滤器（2023完美世界）</h3><p>拦截器和过滤器是Web开发中常用的两种处理方法。这里我假设你指的是Spring MVC拦截器和Java Servlet过滤器。 拦截器 (Interceptor) 在Spring MVC中通常有3个方法：</p><ul><li><code>preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code>: 在请求被处理之前调用。如果返回true，处理流程继续；如果返回false，处理流程结束，不会调用后续的拦截器和处理器。</li><li><code>postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</code>: 在请求被处理之后，视图被渲染之前调用。可以通过它来修改数据模型和视图或进行其他处理。</li><li><code>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</code>: 在请求处理完毕后（视图渲染后）调用，通常用于进行资源清理等工作。</li></ul><p>过滤器 (Filter) 在Java Servlet API中通常有三个方法：</p><ul><li>init(FilterConfig filterConfig): 在服务器启动时，创建Filter对象时调用。</li><li>doFilter(ServletRequest request, ServletResponse response, FilterChain chain): 每次在过滤请求时调用。可以进行逻辑处理，然后使用chain.doFilter(request, response);将请求传递到链中的下一个过滤器或资源（servlet或静态内容）。</li><li>destroy(): 在服务器关闭时，销毁Filter对象时调用。</li></ul><p>比较：</p><ul><li>相较于过滤器，拦截器更加灵活和强大。拦截器是基于Java的反射机制的，它在运行时动态地将逻辑插入到方法调用中，而不需要改变源码。此外，拦截器可以获得Spring容器中的各种bean，从而有更多的操作。</li><li>过滤器则主要用于请求的过滤处理，包括日志记录、请求压缩、安全检查、用户登录校验等。它的运行速度一般比拦截器快，但功能上不如拦截器强大。</li></ul><h3 id="导入一个-jar-包怎么让-springboot-知道哪些需要自动配置-2023完美世界" tabindex="-1"><a class="header-anchor" href="#导入一个-jar-包怎么让-springboot-知道哪些需要自动配置-2023完美世界" aria-hidden="true">#</a> 导入一个 jar 包怎么让 springboot 知道哪些需要自动配置（2023完美世界）</h3><p>Spring Boot自动配置是通过@EnableAutoConfiguration注解实现的。它基本上是通过查找并加载META-INF/spring.factories配置文件来完成的。 如果你想要将你的jar包在Spring Boot项目中进行自动配置，你需要以下步骤：</p><ol><li>在你的jar包中创建一个spring.factories文件，并将其放入META-INF目录下</li><li>在spring.factories文件中添加你的自动配置类，格式如下</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\
com.yourpackage.YourAutoConfigurationClass
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>确保你的AutoConfiguration类使用了@Configuration，并在需要的bean上使用了@Bean注解。</li></ol><p>这样，当Spring Boot项目启动时，它会读取META-INF/spring.factories文件，并自动配置那些bean。</p><p>请注意，你的AutoConfiguration类应该尽可能的&quot;幂等&quot;，意味着多次运行结果应该是一致的，并且应该对已有的Bean有所尊重，如果容器中已经存在了你要创建的Bean，你应该避免再次创建。</p><p>另外，你可能需要使用@Conditional注解以避免在不需要的情况下创建bean。</p><h2 id="📑-数据库" tabindex="-1"><a class="header-anchor" href="#📑-数据库" aria-hidden="true">#</a> 📑 数据库</h2><h3 id="可重复读和已提交读隔离级别表现的现象是什么-区别是什么样的-2023美团" tabindex="-1"><a class="header-anchor" href="#可重复读和已提交读隔离级别表现的现象是什么-区别是什么样的-2023美团" aria-hidden="true">#</a> 可重复读和已提交读隔离级别表现的现象是什么，区别是什么样的？（2023美团）</h3><ul><li>读提交，指一个事务提交之后，它做的变更才能被其他事务看到，会有不可重复读、幻读的问题。</li><li>可重复读，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别，解决了不可重复读的问题，并且以很大程度上避免幻读现象的发生。</li></ul><h3 id="数据文件大体分成哪几种数据文件-2023美团" tabindex="-1"><a class="header-anchor" href="#数据文件大体分成哪几种数据文件-2023美团" aria-hidden="true">#</a> 数据文件大体分成哪几种数据文件？（2023美团）</h3><p>我们每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。</p><p>比如，我这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。 <img src="`+d+'" alt="" loading="lazy"> 然后，我们进入 /var/lib/mysql/my_test 目录，看看里面有什么文件？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>root <span class="token operator">~</span><span class="token punctuation">]</span>#ls <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>mysql<span class="token operator">/</span>my_test\ndb<span class="token punctuation">.</span>opt  \nt_order<span class="token punctuation">.</span>frm  \nt_order<span class="token punctuation">.</span>ibd\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，共有三个文件，这三个文件分别代表着：</p><ul><li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li><li>t_order.frm ，t_order 的表结构会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li><li>t_order.ibd，t_order 的表数据会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li></ul><h3 id="对一个慢sql怎么去排查-2023美团" tabindex="-1"><a class="header-anchor" href="#对一个慢sql怎么去排查-2023美团" aria-hidden="true">#</a> 对一个慢sql怎么去排查？（2023美团）</h3><p>可通过开启mysql的慢日志查询，设置好时间阈值，进行捕获</p><h3 id="索引字段是不是建的越多越好-2023美团" tabindex="-1"><a class="header-anchor" href="#索引字段是不是建的越多越好-2023美团" aria-hidden="true">#</a> 索引字段是不是建的越多越好（2023美团）</h3><p>索引越多，在写入频繁的场景下，对于B+树的维护所付出的性能消耗也会越大</p><h3 id="什么是覆盖索引-2023-快手" tabindex="-1"><a class="header-anchor" href="#什么是覆盖索引-2023-快手" aria-hidden="true">#</a> 什么是覆盖索引？（2023 快手）</h3><blockquote><p>这个其实在2022年的大厂面试中出现过，但是是以聚簇索引形式提问出现</p></blockquote><p><strong>覆盖索引是一种数据库查询优化机制</strong>。在覆盖索引中，索引本身包含了查询所需要的所有数据，因此在执行查询时，数据库系统可以只访问索引，而不需要再访问数据行。这样可以显著提高查询速度，因为访问索引通常比访问数据行要快。（在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作）</p><blockquote><p>覆盖索引与聚簇索引和非聚簇索引的主要区别在于数据的存储和访问方式：</p><ul><li>覆盖索引：它被称为“覆盖”，因为只需使用索引即可满足查询，而无需访问表数据本身。这可以使查询更快，因为它避免了访问表数据的需要，而是使用通常更小、更紧凑的索引数据</li><li>聚簇索引：在聚簇索引中，数据行实际上被存储在索引中，因此每个表只能有一个聚簇索引。索引的顺序与磁盘上行的物理顺序相同。聚簇索引可以快速查找指定的数据行，但如果你需要在同一表上执行许多不同的查询，那么可能会受到限制，因为每个表只能有一个聚簇索引。</li><li>非聚簇索引：非聚簇索引是一个单独的结构，与数据行分开存储。非聚簇索引包含索引键值和一个指向每个数据行实际位置的指针。在非聚簇索引中查找数据需要两个步骤：首先在索引中查找，然后使用索引中的指针访问数据行。因此，非聚簇索引的查询通常比聚簇索引要慢一些。</li></ul></blockquote><p>覆盖索引可以看作是非聚簇索引的一个特例，它不仅包含索引键值和数据行的指针，还包含查询所需的其他列的数据。所以，如果查询可以被一个覆盖索引满足，那么查询速度就会比一般的非聚簇索引要快，因为数据库系统不需要再访问数据行，所有需要的数据都在索引中。使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。</p><p>使用覆盖索引的例子:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tbl_user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_name_age<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span>\n\n<span class="token keyword">SELECT</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>tbl_user<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token string">&#39;John&#39;</span> <span class="token operator">AND</span> <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里 (name, age) 组成了一个复合索引 idx_name_age,查询只需要name和age两列,所以这个查询可以使用覆盖索引,数据库只需要扫描索引,不需要访问表数据,所以查询效率高。</p><p>具体查询为：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>tbl_user<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token string">&#39;John&#39;</span> <span class="token operator">AND</span> <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个查询只需要name和age两个字段,而idx_name_age索引中就包含这两个字段,所以这个查询可以使用覆盖索引。 覆盖索引的查询语句应该是:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> \n    idx_name_age<span class="token punctuation">.</span>name<span class="token punctuation">,</span> \n    idx_name_age<span class="token punctuation">.</span>age\n<span class="token keyword">FROM</span> tbl_user \n<span class="token keyword">WHERE</span> idx_name_age<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;John&#39;</span> <span class="token operator">AND</span> idx_name_age<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们直接从idx_name_age索引中选取需要的字段,而不再访问表数据,所以这个查询使用了覆盖索引。 所以,一个查询要使用覆盖索引,需要满足两个条件:</p><ol><li>查询所需要的字段都存在于某个索引中</li><li>查询语句直接从该索引中选取字段,而不再访问表数据</li></ol><p>没使用覆盖索引的例子:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tbl_user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>address<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_name_age<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">)</span>  \n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span>\n\n<span class="token keyword">SELECT</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>address<span class="token punctuation">`</span></span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>tbl_user<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token string">&#39;John&#39;</span> <span class="token operator">AND</span> <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里虽然有(name, age)的索引,但是由于查询需要的address字段不在该索引中,所以这个查询无法使用覆盖索引,需要访问表数据获取address字段,查询效率较低。</p><p>图示： 在没有使用覆盖索引，数据库查询数据是这样： <img src="'+k+'" alt="" loading="lazy"></p><p>使用了覆盖索引避免了从数据服务中获取数据的额外步骤。这导致了相当大的性能改进。 <img src="'+h+'" alt="" loading="lazy"></p>',66),N=n("p",null,"参考文献：",-1),D={href:"https://stackoverflow.com/questions/62137/what-is-a-covered-index",target:"_blank",rel:"noopener noreferrer"},G={href:"https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB",target:"_blank",rel:"noopener noreferrer"},H={href:"https://stackoverflow.com/questions/609343/what-are-covering-indexes-and-covered-queries-in-sql-server",target:"_blank",rel:"noopener noreferrer"},V={href:"https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/covering-indexes.html",target:"_blank",rel:"noopener noreferrer"},F={href:"https://www.red-gate.com/simple-talk/databases/sql-server/learn/using-covering-indexes-to-improve-query-performance/",target:"_blank",rel:"noopener noreferrer"},Q=t(`<h3 id="redis怎么实现分布式锁-set-nx命令有什么问题-如何解决-2023小红书" tabindex="-1"><a class="header-anchor" href="#redis怎么实现分布式锁-set-nx命令有什么问题-如何解决-2023小红书" aria-hidden="true">#</a> redis怎么实现分布式锁 set nx命令有什么问题 如何解决？（2023小红书）</h3><p>Redis实现分布式锁的基本思路是使用SET命令的NX（Not eXists）选项。NX选项表示只有当键不存在时，才会设置键值对。这样可以确保在分布式环境中，只有一个客户端能够成功地获取锁。以下是一个简单的示例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SET lock_key some_value NX PX <span class="token number">30000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个命令尝试设置一个名为lock_key的键，值为some_value，并且使用NX选项。PX选项表示设置一个过期时间，单位为毫秒，在这个例子中是30000毫秒（30秒）。 然而，使用SET NX命令实现分布式锁存在一些问题：</p><ol><li>非原子操作：在某些情况下，客户端可能在设置锁和设置过期时间之间崩溃，导致锁永远不会被释放。这可以通过使用SET命令的PX选项来解决，它可以在设置锁的同时设置过期时间，确保操作是原子的。</li><li>无法解决锁超时问题：如果持有锁的客户端在锁过期之前没有完成任务，其他客户端可能会获取到锁，导致并发问题。为了解决这个问题，可以在获取锁时设置一个唯一的值（例如UUID），并在释放锁时检查该值。这样可以确保只有锁的持有者才能释放锁。</li><li>无法解决锁释放问题：如果持有锁的客户端在释放锁之前崩溃，锁可能永远不会被释放。为了解决这个问题，可以使用一个后台线程定期检查并释放过期的锁。</li><li>无法实现公平锁：SET NX命令无法保证公平性，即等待时间最长的客户端不一定能够优先获取锁。要实现公平锁，可以使用Redis的LIST数据结构，将等待锁的客户端按照先进先出（FIFO）的顺序排队。 综上所述，虽然SET NX命令可以实现基本的分布式锁功能，但在实际应用中可能需要考虑更多的问题。为了解决这些问题，可以使用成熟的Redis分布式锁库，如Redlock。Redlock提供了一个更加健壮和可靠的分布式锁实现，可以解决上述问题</li></ol><h3 id="什么情况使用-redis-反而降低性能-2023完美世界" tabindex="-1"><a class="header-anchor" href="#什么情况使用-redis-反而降低性能-2023完美世界" aria-hidden="true">#</a> 什么情况使用 redis 反而降低性能（2023完美世界）</h3><ul><li>数据集过大：Redis 将数据存储在内存中，如果数据集过大，超出了服务器可用内存的限制，就会导致 Redis 使用交换空间（swap space）或者频繁地从磁盘加载数据，从而严重影响性能。</li><li>内存碎片化：当 Redis 频繁地进行写入、更新和删除操作时，可能会导致内存碎片化。这会导致 Redis 需要更多的内存来存储相同的数据，最终导致性能下降。</li><li>大量的键过期操作：当 Redis 中有大量的键需要过期处理时，Redis 会执行定期清理操作来删除过期的键。如果这个清理操作耗时较长，会导致 Redis 在执行其他操作时的性能下降。</li><li>高并发写入操作：当有大量的并发写入操作时，Redis 可能会因为竞争条件而降低性能。这种情况下，可以考虑使用 Redis 的事务功能来减少竞争并发。</li><li>复杂的数据结构操作：Redis 提供了多种复杂的数据结构，如列表、集合和有序集合等。当对这些数据结构进行复杂的操作时，例如对大型列表进行频繁的插入和删除操作，可能会导致性能下降。</li></ul><p>需要注意的是，这些情况并不意味着 Redis 总是会降低性能，而是在特定的场景下可能会出现性能下降的情况。为了优化 Redis 的性能，可以根据具体的情况进行调整和优化，例如增加内存、合理设置过期时间、使用合适的数据结构等。</p>`,8),U=n("p",null,"参考资料：",-1),K={href:"https://loadforge.com/guides/troubleshooting-redis-performance-issues",target:"_blank",rel:"noopener noreferrer"},W={href:"https://severalnines.com/blog/performance-tuning-redis/",target:"_blank",rel:"noopener noreferrer"},X=n("h3",{id:"mysql的隔离级别是什么-mysql是如何实现的-2023阿里",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#mysql的隔离级别是什么-mysql是如何实现的-2023阿里","aria-hidden":"true"},"#"),s(" mysql的隔离级别是什么?mysql是如何实现的？（2023阿里）")],-1),Z=n("p",null,"MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：",-1),Y=n("ul",null,[n("li",null,[s("针对"),n("strong",null,"快照读"),s("（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。")]),n("li",null,[s("针对"),n("strong",null,"当前读"),s("（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。")]),n("li")],-1),$={href:"https://xiaolincoding.com/mysql/transaction/mvcc.html",target:"_blank",rel:"noopener noreferrer"},nn=t(`<h3 id="redis大key如何解决-2023-滴滴" tabindex="-1"><a class="header-anchor" href="#redis大key如何解决-2023-滴滴" aria-hidden="true">#</a> Redis大key如何解决（2023 滴滴）</h3><p>Redis大key通常指的是存储在Redis中的数据结构（例如字符串、列表、集合、哈希表和有序集合）的数据量特别大的key。例如，一个列表中的元素数量巨大，或者一个哈希表的字段数量很多。这些大key可能会导致在执行某些操作时消耗过多的CPU和内存资源，进而影响Redis的性能。 例如：字符串(String)：一个字符串value的长度非常大，例如超过10KB。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>SET bigkey <span class="token string">&quot;a very large string.....&quot;</span>  # string长度非常大
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>列表(List)：列表中的元素数量非常多，例如超过10000个。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>LPUSH bigkey item1 item2 item3 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> item10001  # 列表元素数量非常多
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>哈希(Hash)：哈希中的字段数量非常多，例如超过10000个。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>HMSET bigkey field1 value1 field2 value2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> field10001 value10001  # 哈希字段数量非常多
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>以上的数值（例如10KB，10000个等）仅作为参考，具体定义大key的阈值需要根据实际业务和Redis的配置来决定。如果这些key对Redis的性能产生了影响，就应当考虑对其进行优化。</p><blockquote><p>什么是大key总结</p></blockquote><ul><li>String 类型的值大于 10 KB；</li><li>Hash、List、Set、ZSet 类型的元素的个数超过 5000个；</li></ul><blockquote><p>大 key 会造成什么问题？</p></blockquote><p>大 key 会带来以下四种影响：</p><ul><li><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li></ul><blockquote><p>如何找到大 key ？</p></blockquote><ol><li>redis-cli --bigkeys 查找大key</li></ol><p>可以通过 redis-cli --bigkeys 命令查找大 key：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>redis-cli -h 127.0.0.1 -p6379 -a &quot;password&quot; -- bigkeys
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用的时候注意事项：</p><ul><li>最好选择在从节点上执行该命令。因为主节点上执行时，会阻塞主节点；</li><li>如果没有从节点，那么可以选择在 Redis 实例业务压力的低峰阶段进行扫描查询，以免影响到实例的正常运行；或者可以使用 -i 参数控制扫描间隔，避免长时间扫描降低 Redis 实例的性能。 该方式的不足之处：</li><li>这个方法只能返回每种类型中最大的那个 bigkey，无法得到大小排在前 N 位的 bigkey；</li><li>对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量。但是，一个集合中的元素个数多，并不一定占用的内存就多。因为，有可能每个元素占用的内存很小，这样的话，即使元素个数有很多，总内存开销也不大；</li></ul><ol start="2"><li>使用 SCAN 命令查找大 key 使用 SCAN 命令对数据库扫描，然后用 TYPE 命令获取返回的每一个 key 的类型。 对于 String 类型，可以直接使用 STRLEN 命令获取字符串的长度，也就是占用的内存空间字节数。 对于集合类型来说，有两种方法可以获得它占用的内存大小：</li></ol><ul><li>如果能够预先从业务层知道集合元素的平均大小，那么，可以使用下面的命令获取集合元素的个数，然后乘以集合元素的平均大小，这样就能获得集合占用的内存大小了。List 类型：LLEN 命令；Hash 类型：HLEN 命令；Set 类型：SCARD 命令；Sorted Set 类型：ZCARD 命令；</li><li>如果不能提前知道写入集合的元素大小，可以使用 MEMORY USAGE 命令（需要 Redis 4.0 及以上版本），查询一个键值对占用的内存空间。</li></ul><ol start="3"><li>使用 RdbTools 工具查找大 key 使用 RdbTools 第三方开源工具，可以用来解析 Redis 快照（RDB）文件，找到其中的大 key。 比如，下面这条命令，将大于 10 kb 的 key 输出到一个表格文件。</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>rdb dump.rdb -c memory --bytes 10240 -f redis.csv
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>如何删除大 key</p></blockquote><p>删除操作的本质是要释放键值对占用的内存空间，不要小瞧内存的释放过程。</p><p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。</p><p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p><p>因此，删除大 key 这一个动作，我们要小心。具体要怎么做呢？这里给出两种方法：</p><ul><li>分批次删除</li><li>异步删除（Redis 4.0版本以上）</li></ul><ol><li>分批次删除</li></ol><p>对于删除大 Hash，使用 hscan 命令，每次获取 100 个字段，再用 hdel 命令，每次删除 1 个字段。</p><p>Python代码：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">del_large_hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  r <span class="token operator">=</span> redis<span class="token punctuation">.</span>StrictRedis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">&#39;redis-host1&#39;</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span>
    large_hash_key <span class="token operator">=</span><span class="token string">&quot;xxx&quot;</span> <span class="token comment">#要删除的大hash键名</span>
    cursor <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span>
    <span class="token keyword">while</span> cursor <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token comment"># 使用 hscan 命令，每次获取 100 个字段</span>
        cursor<span class="token punctuation">,</span> data <span class="token operator">=</span> r<span class="token punctuation">.</span>hscan<span class="token punctuation">(</span>large_hash_key<span class="token punctuation">,</span> cursor<span class="token operator">=</span>cursor<span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> item <span class="token keyword">in</span> data<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 再用 hdel 命令，每次删除1个字段</span>
                r<span class="token punctuation">.</span>hdel<span class="token punctuation">(</span>large_hash_key<span class="token punctuation">,</span> item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于删除大 List，通过 ltrim 命令，每次删除少量元素。</p><p>Python代码：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">del_large_list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  r <span class="token operator">=</span> redis<span class="token punctuation">.</span>StrictRedis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">&#39;redis-host1&#39;</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span>
  large_list_key <span class="token operator">=</span> <span class="token string">&#39;xxx&#39;</span>  <span class="token comment">#要删除的大list的键名</span>
  <span class="token keyword">while</span> r<span class="token punctuation">.</span>llen<span class="token punctuation">(</span>large_list_key<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">:</span>
      <span class="token comment">#每次只删除最右100个元素</span>
      r<span class="token punctuation">.</span>ltrim<span class="token punctuation">(</span>large_list_key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">101</span><span class="token punctuation">)</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于删除大 Set，使用 sscan 命令，每次扫描集合中 100 个元素，再用 srem 命令每次删除一个键。</p><p>Python代码：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">del_large_set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  r <span class="token operator">=</span> redis<span class="token punctuation">.</span>StrictRedis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">&#39;redis-host1&#39;</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span>
  large_set_key <span class="token operator">=</span> <span class="token string">&#39;xxx&#39;</span>   <span class="token comment"># 要删除的大set的键名</span>
  cursor <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span>
  <span class="token keyword">while</span> cursor <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用 sscan 命令，每次扫描集合中 100 个元素</span>
    cursor<span class="token punctuation">,</span> data <span class="token operator">=</span> r<span class="token punctuation">.</span>sscan<span class="token punctuation">(</span>large_set_key<span class="token punctuation">,</span> cursor<span class="token operator">=</span>cursor<span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> item <span class="token keyword">in</span> data<span class="token punctuation">:</span>
      <span class="token comment"># 再用 srem 命令每次删除一个键</span>
      r<span class="token punctuation">.</span>srem<span class="token punctuation">(</span>large_size_key<span class="token punctuation">,</span> item<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于删除大 ZSet，使用 zremrangebyrank 命令，每次删除 top 100个元素。</p><p>Python代码：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">del_large_sortedset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  r <span class="token operator">=</span> redis<span class="token punctuation">.</span>StrictRedis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">&#39;large_sortedset_key&#39;</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span>
  large_sortedset_key<span class="token operator">=</span><span class="token string">&#39;xxx&#39;</span>
  <span class="token keyword">while</span> r<span class="token punctuation">.</span>zcard<span class="token punctuation">(</span>large_sortedset_key<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用 zremrangebyrank 命令，每次删除 top 100个元素</span>
    r<span class="token punctuation">.</span>zremrangebyrank<span class="token punctuation">(</span>large_sortedset_key<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">)</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>异步删除 从 Redis 4.0 版本开始，可以采用异步删除法，用 unlink 命令代替 del 来删除。 这样 Redis 会将这个 key 放入到一个异步线程中进行删除，这样不会阻塞主线程。 除了主动调用 unlink 命令实现异步删除之外，我们还可以通过配置参数，达到某些条件的时候自动进行异步删除。 主要有 4 种场景，默认都是关闭的：</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del
noslave-lazy-flush no
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它们代表的含义如下：</p><ul><li>lazyfree-lazy-eviction：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除；</li><li>lazyfree-lazy-expire：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除；</li><li>lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；</li><li>slave-lazy-flush：针对 slave (从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。</li></ul><p>建议开启其中的 lazyfree-lazy-eviction、lazyfree-lazy-expire、lazyfree-lazy-server-del 等配置，这样就可以有效的提高主线程的执行效率。</p><blockquote><p>解决</p></blockquote><ol><li><strong>对大Key进行拆分</strong>：将一个Big Key拆分为多个key-value这样的小Key，并确保每个key的成员数量或者大小在合理范围内，然后再进行存储，通过get不同的key或者使用mget批量获取。</li><li><strong>对大Key进行清理</strong>：对Redis中的大Key进行清理，从Redis中删除此类数据。Redis自4.0起提供了UNLINK命令，该命令能够以非阻塞的方式缓慢逐步的清理传入的Key，通过UNLINK，你可以安全的删除大Key甚至特大Key。</li><li><strong>监控Redis的内存、网络带宽、超时等指标</strong>：通过监控系统并设置合理的Redis内存报警阈值来提醒我们此时可能有大Key正在产生，如：Redis内存使用率超过70%，Redis内存1小时内增长率超过20%等。</li><li><strong>定期清理失效数据</strong>：如果某个Key有业务不断以增量方式写入大量的数据，并且忽略了其时效性，这样会导致大量的失效数据堆积。可以通过定时任务的方式，对失效数据进行清理。</li><li><strong>压缩value</strong>：使用序列化、压缩算法将key的大小控制在合理范围内，但是需要注意序列化、反序列化都会带来一定的消耗。如果压缩后，value还是很大，那么可以进一步对key进行拆分。</li></ol>`,49),sn=n("p",null,"参考：",-1),an={href:"https://blog.csdn.net/Weixiaohuai/article/details/125391957",target:"_blank",rel:"noopener noreferrer"},en={href:"https://min.news/en/news/a1b1f8acadd9af9be99514da7504de1b.html",target:"_blank",rel:"noopener noreferrer"},tn={href:"https://www.dragonflydb.io/error-solutions/redis-big-key-problem",target:"_blank",rel:"noopener noreferrer"},on={href:"https://xiaolincoding.com/redis/base/redis_interview.html#redis-%E7%9A%84%E5%A4%A7-key-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86",target:"_blank",rel:"noopener noreferrer"},ln=t('<h3 id="什么是热key-如何解决热key问题-2023-滴滴" tabindex="-1"><a class="header-anchor" href="#什么是热key-如何解决热key问题-2023-滴滴" aria-hidden="true">#</a> 什么是热key？如何解决热key问题（2023 滴滴）</h3><p>热key是指在Redis中被频繁访问的key。当大量的请求都集中在一小部分key上时，就会形成热key。这可能导致Redis服务器负载不均，甚至可能导致部分业务瘫痪。</p><ol><li><strong>热点key分拆</strong>：将热点key拆分成多个小key，均匀分散到多个Redis实例上，从而避免单个Redis实例的瓶颈。</li><li><strong>读写分离</strong>：对于读多写少的热key，可以考虑使用Redis的主从复制功能，所有的读操作都发送到从服务器，写操作发送到主服务器，从而分散读取压力。</li><li><strong>数据缓存</strong>：对于计算复杂或者读取代价大的热key，可以考虑在业务端增加缓存处理，例如使用本地缓存，减少对Redis的直接访问。</li><li><strong>使用第三方中间件</strong>：例如使用Twemproxy等代理工具进行自动的分片和读写分离，避免热key问题。</li><li><strong>使用限流/熔断机制</strong>：在业务端加入限流/熔断机制，保证系统的稳定。</li><li><strong>使用哈希算法分片热点键</strong>：这种方法可以将热点数据分散到不同的节点上，降低单个节点的负载，从而解决热key问题。这是一种在数据层面解决问题的策略，需要结合具体的业务场景进行设计和实施。</li><li><strong>设置LFU（最不经常使用）</strong> 策略并运行redis-cli --hotkeys以确定哪些键更频繁地访问：Redis在4.0版本引入了LFU淘汰策略，这种策略可以根据键的使用频率来进行淘汰，比较适合处理热key问题。另外，通过运行redis-cli --hotkeys命令，可以找出访问频率最高的key，这对于分析和解决热key问题非常有帮助。</li></ol><p>总的来说，解决热key问题主要是通过分散热点、减少读取次数、增加读取的速度等方法，从而减轻Redis服务器的压力。</p>',4),pn=n("p",null,"参考：",-1),rn={href:"https://dzone.com/articles/redis-hotspot-key-discovery-and-common-solutions",target:"_blank",rel:"noopener noreferrer"},cn={href:"https://developer.redis.com/howtos/antipatterns/",target:"_blank",rel:"noopener noreferrer"},un={href:"https://github.com/twitter/twemproxy",target:"_blank",rel:"noopener noreferrer"},dn=n("h3",{id:"讲下redis的zset-2023-滴滴",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#讲下redis的zset-2023-滴滴","aria-hidden":"true"},"#"),s(" 讲下Redis的ZSet（2023 滴滴）")],-1),kn=n("p",null,"Redis的ZSet（有序集合）是一种数据结构，它与普通的集合相比，在存储每个元素时关联了一个分数（score）。这个分数用于对集合中的元素进行排序，并且每个元素都是唯一的。当多个字符串具有相同分数时，这些字符串按字典顺序排列。一些有序集合的用途包括：",-1),hn=n("ul",null,[n("li",null,"排行榜。例如，您可以使用有序集合轻松地维护大型在线游戏中得分最高的有序列表。"),n("li",null,"速率限制器。特别是，您可以使用有序集合构建滑动窗口速率限制器，以防止过多的API请求。")],-1),gn=n("p",null,"ZSet中的每个元素都有一个分数，根据分数的大小对元素进行排序。不同的元素可以有相同的分数，但每个元素在集合中必须是唯一的。 Redis内部使用了跳跃表（skip list）和压缩列表（ziplist）两种数据结构来实现ZSet。跳跃表用于提供有序性，而散列表用于快速查找元素。 Redis的ZSet提供了高效的操作，包括插入、删除和查找操作。这些操作的时间复杂度通常为O(log N)，其中N是ZSet中元素的数量。",-1),mn=n("p",null,"参考：",-1),vn={href:"https://redis.io/docs/data-types/sorted-sets/",target:"_blank",rel:"noopener noreferrer"},bn={href:"https://www.educba.com/redis-zset/",target:"_blank",rel:"noopener noreferrer"},yn={href:"https://redis.io/commands/zadd/",target:"_blank",rel:"noopener noreferrer"},fn=t('<h3 id="zset的范围查询的时间复杂度是多少-2023-滴滴" tabindex="-1"><a class="header-anchor" href="#zset的范围查询的时间复杂度是多少-2023-滴滴" aria-hidden="true">#</a> ZSet的范围查询的时间复杂度是多少（2023 滴滴）</h3><p>Redis的ZSet范围查询的时间复杂度是O(log N + M)，其中N是ZSet中的元素数量，M是范围内的元素数量。</p><p>具体来说，范围查询是通过指定最小和最大分数值来检索元素。Redis内部使用跳跃表（skip list）这种有序数据结构来存储ZSet，并且通过跳跃表可以高效地进行范围查询。</p><p>在进行范围查询时，Redis首先会通过二分查找在跳跃表中找到最小分数大于等于指定最小分数的节点，然后从这个节点开始，按照指定的最大分数遍历跳跃表，直到找到最后一个分数小于等于指定最大分数的节点。这个过程的时间复杂度是O(log N)。</p><p>然后，Redis会从找到的节点开始向后遍历，并收集在范围内的元素，直到遍历完所有符合条件的元素或达到范围内的元素数量上限。这个过程的时间复杂度是O(M)，其中M是范围内的元素数量。</p><p>综上所述，Redis的ZSet范围查询的时间复杂度是O(log N + M)，其中N是ZSet中的元素数量，M是范围内的元素数量。请注意，这是一种平均情况下的时间复杂度，具体的性能还受到硬件环境和实际数据分布的影响。</p><h2 id="♻️-jvm" tabindex="-1"><a class="header-anchor" href="#♻️-jvm" aria-hidden="true">#</a> ♻️ JVM</h2><h3 id="堆是如何管理内存的-2023-快手" tabindex="-1"><a class="header-anchor" href="#堆是如何管理内存的-2023-快手" aria-hidden="true">#</a> 堆是如何管理内存的（2023 快手）</h3><ol><li><strong>堆的划分</strong>：在JVM中，堆被划分为年轻代（Young Generation）和老年代（Old Generation）。年轻代又被划分为Eden区和两个Survivor区（S0和S1）。新创建的对象首先在Eden区创建，当Eden区满时，会触发Minor GC进行垃圾回收。存活的对象会被移动到Survivor区，当Survivor区也满时，对象会被移动到老年代。当老年代满了，会触发Major GC或者Full GC。</li><li><strong>垃圾回收</strong>：JVM通过垃圾回收机制自动回收不再使用的对象以释放内存。JVM的垃圾回收算法包括标记-清除、复制、标记-整理、分代收集等。</li><li><strong>内存分配</strong>：当创建新对象时，JVM会在堆中为其分配内存。JVM有一个指针叫做TLAB（Thread Local Allocation Buffer），用于在特定的线程中分配对象，这样可以避免线程之间的竞争。如果对象很大，可能直接在老年代分配。</li><li><strong>堆大小调整</strong>：JVM的堆大小可以动态调整，以适应程序的需求。可以通过启动参数设置最小堆大小（-Xms）和最大堆大小（-Xmx）。如果程序需要更多内存，堆可以扩展到最大堆大小；如果程序需要的内存减少，堆可以收缩到最小堆大小。</li></ol><h3 id="跨代引用问题怎么解决-2023-快手" tabindex="-1"><a class="header-anchor" href="#跨代引用问题怎么解决-2023-快手" aria-hidden="true">#</a> 跨代引用问题怎么解决（2023 快手）</h3><p><strong>跨代引用问题是指在JVM内存模型中，年轻代的对象引用老年代的对象，或者老年代的对象引用年轻代的对象</strong>。这在垃圾回收时可能会导致一些问题，因为垃圾回收通常会针对年轻代和老年代分别进行。</p><p>为了解决这个问题，JVM引入了一个叫做 <strong>&quot;卡表&quot;（Card Table）</strong> 的数据结构。卡表的主要作用是快速找到老年代中被年轻代对象引用的对象，从而在进行Minor GC时，减少全堆扫描的开销。</p><blockquote><p>卡表概览：卡表是Java虚拟机（JVM）中加速查找引用的一种辅助数据结构。表中每个条目对应于Java堆的一小部分，这里我称为小块。当老年代中的一个对象写入/更新对年轻代中的一个对象的引用时，这个操作会通过一种叫做写屏障的东西。当JVM看到这些写屏障时，它会更新卡片表中的相应条目。</p><ul><li>写屏障：垃圾收集器用来跟踪对象引用更改的一种机制。它是一段代码（JVM实现的），每当对象引用更新时就会运行。写屏障确保垃圾收集器可以跟踪堆中的所有引用，并确定哪些对象仍在使用，哪些没有。</li><li>当写入屏障发现语句<code>some_obj.field = other_obj;</code>将年轻指针存储在旧对象中时，它会这样做：<code>card_table[(&amp;old_obj - start_of_heap) &gt;&gt; K] = 1;</code></li><li>其中<code>&amp;old_obj</code>是现在有一个年轻代指针的对象的地址（它已经在寄存器中，因为它刚刚被确定引用旧对象）。 在次要GC期间，垃圾收集器查看卡表以确定要扫描哪些堆区域以查找年轻指针。 <ul><li>for i from 0 to (heap_size &gt;&gt; K):</li><li>if card_table[i]: scan heap[i &lt;&lt; K .. (i + 1) &lt;&lt; K] for young pointers <img src="'+l+'" alt="card-table" loading="lazy"></li></ul></li></ul></blockquote><p>卡表将老年代的内存分为多个小块（通常为512字节），每个小块对应卡表中的一项，当老年代中的某个小块内存<strong>被修改时</strong>（例如年轻代的对象引用了该小块中的某个对象），对应的卡表项就被标记为 <strong>&quot;脏（dirty）&quot;</strong> 。</p><p>在进行Minor GC（清理年轻代）时，JVM只需要检查标记为&quot;脏&quot;的卡表项对应的内存块，找出被年轻代对象引用的老年代对象，而无需扫描整个老年代。这样就大大提高了垃圾回收的效率。</p><p>至于<strong>老年代的对象引用年轻代的对象，这在JVM的分代回收策略中是不推荐的，因为会增加垃圾回收的复杂性</strong>。如果确实存在这种情况，一般需要在进行垃圾回收时，遍历老年代找到所有引用年轻代的对象，确保不会误删。</p>',16),_n=n("p",null,"参考文献如下：",-1),wn={href:"https://stackoverflow.com/questions/19154607/how-actually-card-table-and-writer-barrier-work",target:"_blank",rel:"noopener noreferrer"},Sn={href:"https://tschatzl.github.io/2022/02/15/card-table-card-size.html",target:"_blank",rel:"noopener noreferrer"},xn={href:"https://www.mo4tech.com/jvm-card-table.html",target:"_blank",rel:"noopener noreferrer"},Cn={href:"https://www.cnblogs.com/hongdada/p/12016020.html",target:"_blank",rel:"noopener noreferrer"},Ln={href:"http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html",target:"_blank",rel:"noopener noreferrer"},qn=t('<h3 id="每次回收都要从gc-root开始吗-2023-快手" tabindex="-1"><a class="header-anchor" href="#每次回收都要从gc-root开始吗-2023-快手" aria-hidden="true">#</a> 每次回收都要从GC ROOT开始吗（2023 快手）</h3><p>是的，每次垃圾回收都会从GC Roots开始。GC Roots是垃圾回收算法开始工作的一组必要的&quot;根&quot;对象。</p><p>Java中可以作为GC Roots的对象包括：</p><ol><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ol><p>垃圾回收器在对堆进行回收前，会先从GC Roots开始对堆中的对象进行可达性分析。只有当对象在GC Roots到该对象之间没有任何引用链可达时（换句话说，GC Roots到该对象不可达），这个对象才会被判定为可回收的垃圾对象。</p><p>这种通过GC Roots进行可达性分析的方式，保证了只有真正不再使用的对象会被回收，从而避免了错误地回收仍在使用的对象。</p><h3 id="垃圾回收过程如何判断每个阶段已经完成-可以进入下一个阶段-2023-快手" tabindex="-1"><a class="header-anchor" href="#垃圾回收过程如何判断每个阶段已经完成-可以进入下一个阶段-2023-快手" aria-hidden="true">#</a> 垃圾回收过程如何判断每个阶段已经完成，可以进入下一个阶段（2023 快手）</h3><p>像是垃圾回收器如CMS（并发标记清除）和G1（Garbage-First）在进行垃圾回收时，会通过一系列的阶段来判断何时可以进入下一步。</p><p>CMS垃圾回收器： CMS垃圾回收器主要包含以下四个阶段：</p><ol><li>初始标记（Initial Mark）：标记GC Roots能直接关联的对象，此阶段需要暂停所有的其他线程，但是时间通常较短。</li><li>并发标记（Concurrent Mark）：进行GC Roots Tracing的过程，也就是从GC Roots开始对堆中的对象进行可达性分析，此阶段可以与用户线程并发执行。</li><li>重新标记（Remark）：修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分标记记录，防止数据不一致，此阶段需要暂停所有的其他线程。</li><li>并发清除（Concurrent Sweep）：清除不再使用的对象，此阶段可以与用户线程并发执行。 CMS在每个阶段完成后会判断是否可以进入下一阶段。例如，在并发标记阶段，当所有从GC Roots开始可达的对象都被标记后，就可以进入重新标记阶段。</li></ol><p>G1垃圾回收器： G1垃圾回收器将堆内存划分为多个小块（Region），每个小块可能属于Eden区、Survivor区或者Old区。G1的垃圾回收过程包括以下几个阶段：</p><ol><li>初始标记（Initial Mark）：标记所有的GC Roots能直接关联的对象，此阶段需要暂停所有的其他线程。</li><li>并发标记（Concurrent Mark）：进行GC Roots Tracing的过程，此阶段可以与用户线程并发执行。</li><li>最终标记（Final Mark）：修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分标记记录，此阶段需要暂停所有的其他线程。</li><li>筛选回收（Cleanup）：首先统计各个Region的存活对象，并对Region进行排序，然后回收垃圾对象最多的Region。 类似地，G1在每个阶段完成后会判断是否可以进入下一阶段。例如，在并发标记阶段，当所有从GC Roots开始可达的对象都被标记后，就可以进入最终标记阶段。</li></ol><p>总的来说，垃圾回收器在每个阶段的结束条件主要取决于当前阶段的任务是否完成，例如是否所有的对象都已经被标记，或者是否所有的垃圾都已经被清除。</p><h3 id="什么时候会发生full-gc-2023-小红书" tabindex="-1"><a class="header-anchor" href="#什么时候会发生full-gc-2023-小红书" aria-hidden="true">#</a> 什么时候会发生FULL GC？（2023 小红书）</h3><p>每当堆满时，就会触发Full GC。在这种情况下，首先收集年轻代，然后收集老年代。如果老年代太满而无法接受年轻代的内容，则省略年轻代GC，并使用旧代GC以并行或串行方式收集完整堆。</p><p>另外：</p><ol><li>Young Generation 已满,而 Old Generation 中又没有足够的空间存活对象时,会触发 full gc。</li><li>已使用的内存超过最大堆内存(通过 -Xmx 设置)时,也会触发 full gc 以回收内存。</li><li>调用 System.gc() 方法时,如果 JVM 检测到 Old Generation 中有足够的垃圾需要清理,也会触发 full gc。</li><li>Minor GC 完成后,如果 JVM 检测到 Old Generation 中有足够的垃圾需要清理,也会触发 full gc。</li></ol>',17),Rn=n("p",null,"参考：",-1),Mn={href:"https://stackoverflow.com/questions/24766118/when-is-a-full-gc-triggered",target:"_blank",rel:"noopener noreferrer"},An=t(`<h3 id="可以在代码中捕获oom异常吗-2023-小红书" tabindex="-1"><a class="header-anchor" href="#可以在代码中捕获oom异常吗-2023-小红书" aria-hidden="true">#</a> 可以在代码中捕获oom异常吗？（2023 小红书）</h3><p>可以通过代码捕获 OOM(OutOfMemory)异常。例如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 可能触发 OOM 的代码</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OutOfMemoryError</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Out of Memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 JVM 的可用内存不足以满足应用的内存需求时,会抛出 OOM 异常。捕获这个异常可以让应用优雅地处理 OOM 错误,而不是直接崩溃。</p><h3 id="能不能说一下堆区具体怎么划分-为什么这样划分-2023百度" tabindex="-1"><a class="header-anchor" href="#能不能说一下堆区具体怎么划分-为什么这样划分-2023百度" aria-hidden="true">#</a> 能不能说一下堆区具体怎么划分，为什么这样划分（2023百度）</h3><p>Java虚拟机（JVM）的堆区（Heap）是JVM所管理的最大的一块内存空间，也是Java内存管理中最关键的部分。它主要用于存放各种对象实例，包括Java类的实例和数组。</p><p>堆区的具体划分可能会随着不同的JVM实现（例如HotSpot、JRockit、IBM J9等）和版本有所不同，但一般来说，可以划分为以下几个部分：</p><ol><li><strong>新生代（Young Generation）</strong>：新生代是堆内存中的一部分，主要存放新创建的对象。新生代又可以分为三部分： <ul><li><strong>Eden区</strong>：这是新生代的主要部分，大部分新创建的对象首先在Eden区分配内存。</li><li><strong>Survivor区</strong>：Survivor区包括两个，通常称为From Survivor和To Survivor，用于存放从Eden区经过一次Minor GC后仍然存活的对象。</li></ul></li><li><strong>老年代（Old Generation）</strong>：当对象在新生代Survivor区中经历了一定次数的GC后，或者Eden区没有足够空间进行分配时，对象会被晋升到老年代。老年代的空间通常比新生代大，用于存放长时间存活的对象。</li><li><strong>永久代（Permanent Generation）/元空间（Metaspace）</strong>：这部分内存用于存放JVM加载的类信息、常量、静态变量等数据。在Java 8之后，永久代被移除，改为使用元空间。</li></ol><p>堆的这种划分方式主要基于一个观察到的现象，即大部分对象的生命周期都非常短，即“弱代假说”。基于此，JVM采用了分代回收的垃圾收集策略。</p><p>新生代中的对象生命周期较短，所以可以通过Minor GC更频繁地收集新生代区域。当Eden区满时，会触发Minor GC，清理掉那些已经死亡的对象，把仍然存活的对象移动到Survivor区，如果Survivor区也满了，就会将对象移动到老年代。</p><p>老年代中的对象一般存活时间较长，或者是Survivor空间无法容纳的大对象。因此，相比于新生代，老年代的GC（Major GC或Full GC）会相对少些，但每次GC时间会比Minor GC要长，因为需要对整个老年代进行整理。</p><p>永久代/元空间存放的数据类型（如类信息、常量）的生命周期与一般的Java对象有所不同，其内存管理也有特殊之处，比如类的卸载等情况。</p><p>这种内存划分和管理方式能够提高垃圾收集的效率，同时也减轻了Full GC的压力，提高了系统的性能和稳定性。</p><h2 id="🦸‍♀️中间件" tabindex="-1"><a class="header-anchor" href="#🦸‍♀️中间件" aria-hidden="true">#</a> 🦸‍♀️中间件</h2><h3 id="请求很多-消息堆积处理不过来了如何应对-2023滴滴" tabindex="-1"><a class="header-anchor" href="#请求很多-消息堆积处理不过来了如何应对-2023滴滴" aria-hidden="true">#</a> 请求很多，消息堆积处理不过来了如何应对（2023滴滴）</h3><p>如果发现消息中间件中的消息正在堆积，这可能意味着生产者生产的消息速度大于消费者的消费速度。有几种可能的策略可以缓解这个问题：</p><ol><li>扩展消息中间件<strong>集群</strong>：考虑对消息中间件进行水平扩展，提高整体的处理能力。例如，在RabbitMQ中，可以增加节点来实现集群扩展。</li><li><strong>降级</strong>：在降级策略中，当发现消息处理速度不足以应对积压的情况时，可以决定对某些类型或优先级较低的消息进行降级处理。降级处理的方式可能包括减慢处理这些消息的速度、暂时忽略这些消息，或者将这些消息转移到一个低优先级的队列等待处理。这样，系统可以把更多的资源用于处理高优先级的消息。</li><li><strong>熔断</strong>：熔断是一种防止系统过载并快速失败的机制，类似于电路中的熔断器。当发现消息处理系统的压力过大时，可以启动熔断机制。这可能意味着暂时拒绝接收更多的消息，或者对新到的消息进行快速失败处理（例如立即返回错误，而不是将其放入队列）。一旦启动了熔断机制，就需要有一个机制去检测何时可以“闭合”熔断器，也就是何时可以恢复正常处理消息。这通常涉及到对系统的负载和性能进行监控，并设置合适的阈值。</li></ol><h3 id="用户在消息堆积时以为卡了多次请求怎么处理-2023滴滴" tabindex="-1"><a class="header-anchor" href="#用户在消息堆积时以为卡了多次请求怎么处理-2023滴滴" aria-hidden="true">#</a> 用户在消息堆积时以为卡了多次请求怎么处理（2023滴滴）</h3><p>当用户在消息堆积时多次发送相同的请求，这可能会进一步加重系统的压力。有几种策略可以帮助应对这个问题：</p><ol><li><strong>前端防抖（Debounce）</strong>：可以在客户端实现防抖机制，防止用户在短时间内多次点击发送重复的请求。例如，用户提交表单后，可以禁用提交按钮一段时间，防止多次提交。</li><li><strong>后端去重</strong>：后端可以记录每个请求的ID或者其他唯一标识，然后判断是否有重复的请求。如果检测到重复请求，可以选择忽略或者返回已处理的结果。</li><li><strong>用户反馈</strong>：在用户发送请求后，及时给出反馈，让用户知道请求已经被接收，正在处理中，以防止用户因为等待时间过长而重复发送请求。例如，可以显示一个进度条或者&quot;正在处理&quot;的提示。</li><li><strong>超时和重试策略</strong>：对于超时的请求，可以设置一个合理的超时时间，超过这个时间后，可以让用户选择是否重新发送请求。此外，可以设置自动重试策略，但需要注意控制重试次数和间隔，以防止过度重试加重系统压力。</li></ol><h2 id="🤹‍♂️微服务、分布式" tabindex="-1"><a class="header-anchor" href="#🤹‍♂️微服务、分布式" aria-hidden="true">#</a> 🤹‍♂️微服务、分布式</h2><h3 id="rpc如何进行序列化-2023-阿里" tabindex="-1"><a class="header-anchor" href="#rpc如何进行序列化-2023-阿里" aria-hidden="true">#</a> RPC如何进行序列化？（2023 阿里）</h3><p>RPC的序列化是将数据结构或对象转换成可以通过网络传输的格式的过程。序列化后的数据可以通过网络传输，并在另一端反序列化，以重建原始数据结构或对象。 有很多方法可以序列化RPC数据，包括使用二进制格式，如Protocol Buffers1、JSON、XML等。</p><h3 id="dubbo-的请求处理流程-2023完美世界" tabindex="-1"><a class="header-anchor" href="#dubbo-的请求处理流程-2023完美世界" aria-hidden="true">#</a> dubbo 的请求处理流程（2023完美世界）</h3><p>Dubbo 是一个分布式服务框架，它采用了 RPC 远程调用的方式进行服务间的通信。下面是一个简单的 Dubbo 的请求处理流程：</p><ol><li><strong>服务提供者启动</strong>：在服务提供者应用启动的时候，Dubbo 会自动检查所有 Spring 容器中定义的 Service Bean，自动识别出 Dubbo 服务并进行发布。</li><li><strong>服务注册</strong>：服务提供者启动后，Dubbo 会将提供的服务信息注册到注册中心（例如 ZooKeeper、Nacos）。这些信息通常包括服务提供者的 IP 地址、端口号、服务名称等。</li><li><strong>服务发现</strong>：服务消费者在启动的时候，会从注册中心获取到所有相关的服务信息，并保存在本地。同时，消费者还会向注册中心注册一个监听器，用来监听服务的变化。</li><li><strong>服务调用</strong>：当服务消费者需要调用某个服务的时候，首先会从本地的服务列表中选择一个服务提供者。选择的策略有很多种，例如轮询、随机等。选择好后，消费者就会通过 RPC 的方式调用服务提供者的方法。</li><li><strong>负载均衡</strong>：在服务调用的过程中，如果一个服务有多个服务提供者，那么就需要使用负载均衡策略来选择一个最合适的服务提供者。Dubbo 内置了多种负载均衡策略，例如随机、最小活跃数、一致性 Hash 等。</li><li><strong>容错处理</strong>：在服务调用的过程中，如果发生错误，Dubbo 会根据预先配置的容错策略进行处理。例如失败重试、失败忽略等。</li><li><strong>结果返回</strong>：服务提供者处理完消费者的请求后，会将结果返回给消费者。消费者收到结果后，就完成了一次服务调用。</li></ol><h2 id="🌐-计算机网络" tabindex="-1"><a class="header-anchor" href="#🌐-计算机网络" aria-hidden="true">#</a> 🌐 计算机网络</h2><h3 id="http协议的报文的格式有了解吗" tabindex="-1"><a class="header-anchor" href="#http协议的报文的格式有了解吗" aria-hidden="true">#</a> http协议的报文的格式有了解吗？</h3><p><img src="`+g+'" alt="" loading="lazy"> HTTP 的请求报文分为三个部分：</p><p>请求行、首部行、实体主体。</p><h3 id="http2了解吗-2023小红书" tabindex="-1"><a class="header-anchor" href="#http2了解吗-2023小红书" aria-hidden="true">#</a> http2了解吗？（2023小红书）</h3><p>HTTP/2是对万维网使用的HTTP网络协议的重大修订。它源自较早的实验性SPDY协议，最初由Google开发。HTTP/2不是对协议的彻底重写；HTTP方法、状态码和语义学与HTTP/1. x相同（可能有一些小的补充）来表示协议。新的二进制成帧机制的引入改变了客户端和服务器之间数据交换的方式。要描述这个过程，可以熟悉HTTP/2术语 -- <code>Stream</code>：已建立连接内的双向字节流，它可能携带一条或多条消息。</p><p>您还可以提到HTTP/2旨在提高网站性能并减少延迟。它通过引入几个新功能来做到这一点，例如服务器推送、标头压缩和多路复用。</p>',33),Tn=n("p",null,"参考：",-1),En={href:"https://http2.github.io/",target:"_blank",rel:"noopener noreferrer"},Pn={href:"https://en.wikipedia.org/wiki/HTTP/2",target:"_blank",rel:"noopener noreferrer"},jn={href:"https://web.dev/performance-http2/",target:"_blank",rel:"noopener noreferrer"},On={href:"https://www.digitalocean.com/community/tutorials/http-1-1-vs-http-2-what-s-the-difference",target:"_blank",rel:"noopener noreferrer"},Jn=t('<h3 id="建立-tcp-连接后-客户端下线了会发生什么-2023百度" tabindex="-1"><a class="header-anchor" href="#建立-tcp-连接后-客户端下线了会发生什么-2023百度" aria-hidden="true">#</a> 建立 TCP 连接后，客户端下线了会发生什么（2023百度）</h3><p>TCP（传输控制协议）连接建立后，如果客户端下线或断开，那么这个TCP连接就会被中断。</p><p>在TCP协议中，任何一方（客户端或服务器）都可以主动断开连接。在正常情况下，断开连接会通过一个四步握手过程（四次挥手）来完成。这个过程保证了双方都能清楚地了解连接已经被关闭，而不会造成数据丢失。</p><p>然而，如果客户端突然下线（比如因为网络中断、电源切断等原因），服务器可能并不会立刻知道这个情况。这是因为TCP协议的设计使得它能够在短暂的网络中断后恢复连接。所以，如果服务器尝试向客户端发送数据，这些数据可能会被阻塞，直到达到一定的重试次数或者超时，服务器才会认为连接已经断开。</p><p>在客户端重新上线后，如果它尝试再次建立与服务器的连接，那么需要完全重新进行TCP的三次握手过程来建立新的连接。</p><p>需要注意的是，TCP协议提供的是一种“可靠”的传输服务。即使在网络环境不稳定、丢包率高的情况下，TCP也能确保数据的完整性和有序性。但是，这种可靠性是通过复杂的错误检测和修复机制、以及重传机制来实现的，这也使得TCP在处理断开连接和重连的情况时相对复杂。</p><h2 id="🖥️操作系统" tabindex="-1"><a class="header-anchor" href="#🖥️操作系统" aria-hidden="true">#</a> 🖥️操作系统</h2><h3 id="linux有几种io模型-2023阿里" tabindex="-1"><a class="header-anchor" href="#linux有几种io模型-2023阿里" aria-hidden="true">#</a> linux有几种IO模型（2023阿里）</h3>',8),Bn={href:"https://linyunwen.github.io/2022/01/02/linux-io-model/",target:"_blank",rel:"noopener noreferrer"},In=t('<h3 id="分配给进程的资源有哪些-2023-滴滴" tabindex="-1"><a class="header-anchor" href="#分配给进程的资源有哪些-2023-滴滴" aria-hidden="true">#</a> 分配给进程的资源有哪些（2023 滴滴）</h3><ol><li><strong>CPU时间</strong>：每个进程都需要使用CPU来执行其指令。操作系统通过进程调度算法来决定哪个进程应该得到CPU时间。</li><li><strong>内存空间</strong>：每个进程都需要内存来存储其代码、数据和运行时的状态信息。操作系统通过内存管理算法来分配和管理内存资源。</li><li><strong>I/O设备</strong>：包括硬盘、鼠标、键盘、打印机等。操作系统负责管理和调度进程对这些设备的访问。</li><li><strong>文件</strong>：文件是一种常见的存储资源，操作系统通过文件系统来管理和控制进程对文件的访问。</li><li><strong>网络</strong>：进程可能需要通过网络来进行数据传输和通信，操作系统负责管理和调度进程对网络资源的访问。</li><li><strong>各种软件和库资源</strong>：例如数据库系统、图形处理库等。这些都是进程可能需要使用的资源，由操作系统进行管理和分配。</li></ol><h2 id="🎨-设计模式" tabindex="-1"><a class="header-anchor" href="#🎨-设计模式" aria-hidden="true">#</a> 🎨 设计模式</h2><h3 id="适配器模式、装饰器模式、代理模式有什么区别-2023小红书" tabindex="-1"><a class="header-anchor" href="#适配器模式、装饰器模式、代理模式有什么区别-2023小红书" aria-hidden="true">#</a> 适配器模式、装饰器模式、代理模式有什么区别？（2023小红书）</h3><ul><li><strong>适配器模式</strong>：适配器模式就像是一个电源适配器，它允许两个不兼容的接口可以一起工作。例如，一个类的接口与客户端代码需要的接口不一致时，可以通过创建一个适配器类来转换接口，使得客户端代码能够利用现有的类。</li><li><strong>装饰器模式</strong>：装饰器模式可以动态地向对象添加额外的职责，而不改变其实现。装饰器封装了一个类，并提供和该类相同的接口，但在调用其方法时，可以额外执行一些操作。装饰器可以被无限地堆叠，每个装饰器都添加一些额外的行为。</li><li><strong>代理模式</strong>：代理模式在不改变接口的前提下，为其他对象提供一个代理或占位符以控制对这个对象的访问。代理可以用于许多不同的目的，如安全控制、复杂性隐藏、延迟加载等。代理通常控制对其委托对象的访问，并可能选择创建或删除它。</li></ul><p>综上所述，适配器模式用于让不兼容的接口能够一起工作，装饰器模式用于动态添加功能，代理模式用于控制对另一个对象的访问。</p><h2 id="🖼️场景题" tabindex="-1"><a class="header-anchor" href="#🖼️场景题" aria-hidden="true">#</a> 🖼️场景题</h2><h3 id="服务端出现大量-close-wait-状态-可能的情况-2023美团" tabindex="-1"><a class="header-anchor" href="#服务端出现大量-close-wait-状态-可能的情况-2023美团" aria-hidden="true">#</a> 服务端出现大量 close_wait 状态，可能的情况？（2023美团）</h3><p><code>CLOSE_WAIT</code>状态通常意味着你的程序在关闭连接时有一些问题，或者说，它没有正确地关闭套接字连接。这通常发生在程序接收到了服务端的完成（FIN）信号，但是程序自身没有正确地关闭套接字，或者没有在适当的时间内关闭。当这种情况发生时，你会看到大量的连接处于<code>CLOSE_WAIT</code>状态。</p><p>导致大量CLOSE_WAIT状态的可能情况有很多，以下是一些可能的情况：</p><ol><li><strong>应用程序故障</strong>：应用程序可能没有正确地关闭连接。例如，应用程序可能在完成数据交换后忘记关闭连接，或者应用程序可能由于错误而无法关闭连接。这是最常见的原因。</li><li><strong>网络故障</strong>：网络连接问题可能会导致套接字无法正确关闭，从而导致大量的CLOSE_WAIT状态。</li><li><strong>系统资源不足</strong>：如果系统资源（如文件描述符）不足，可能会导致套接字无法关闭，从而产生大量的CLOSE_WAIT状态。</li><li><strong>服务端负载过高</strong>：如果服务器的负载过高，可能会导致套接字无法及时关闭，从而产生大量的CLOSE_WAIT状态。</li><li><strong>服务端代码中有一个bug</strong>： 服务器代码中的错误可能导致它意外关闭连接。 这也可能导致新请求处于等待状态。</li><li><strong>服务端有硬件问题</strong>： 硬件问题（如内存泄漏或CPU瓶颈）也可能导致服务器关闭连接。 这可能导致新请求处于等待状态。</li></ol><p>解决这种问题通常需要找出导致大量CLOSE_WAIT状态的原因，并进行相应的修复。例如，如果是应用程序没有正确关闭连接，那么可能需要修改应用程序的代码，确保它在完成数据交换后正确关闭连接。如果是网络问题，可能需要检查和修复网络连接。如果是系统资源不足，可能需要增加系统资源或优化应用程序以减少资源使用。如果是服务器负载过高，可能需要增加服务器资源或优化服务器配置来降低负载。</p>',12),zn=n("p",null,"参考：",-1),Nn={href:"https://stackoverflow.com/questions/21033104/close-wait-state-in-server",target:"_blank",rel:"noopener noreferrer"},Dn={href:"https://superuser.com/questions/173535/what-are-close-wait-and-time-wait-states",target:"_blank",rel:"noopener noreferrer"},Gn={href:"https://learn.microsoft.com/en-us/answers/questions/337518/tcp-connections-locked-in-close-wait-status-with-i",target:"_blank",rel:"noopener noreferrer"},Hn={href:"https://www.cnblogs.com/grey-wolf/p/10936657.html",target:"_blank",rel:"noopener noreferrer"},Vn={href:"https://juejin.cn/post/6844903734300901390#heading-6",target:"_blank",rel:"noopener noreferrer"},Fn=t(`<h3 id="java-程序运行了一周-发现老年代内存溢出-分析一下-2023美团" tabindex="-1"><a class="header-anchor" href="#java-程序运行了一周-发现老年代内存溢出-分析一下-2023美团" aria-hidden="true">#</a> Java 程序运行了一周，发现老年代内存溢出，分析一下？（2023美团）</h3><p>Java程序的内存溢出常常意味着在Java堆中没有足够的空间分配新的对象。通常，这意味着程序创建了太多的对象并且没有及时的清理，或者是这些对象占用了太大的内存。</p><p>Java的垃圾回收机制会自动清理不再使用的对象，释放内存空间。在HotSpot虚拟机中，内存被划分为年轻代和老年代。年轻代主要用于存放生命周期较短的对象，而老年代则用于存放生命周期较长的对象。如果老年代的内存溢出，这通常意味着存在以下可能的问题：</p><ol><li><strong>内存泄漏</strong>：这是最常见的问题，程序可能在持续的创建对象，而这些对象没有被及时的清理，比如长生命周期的对象持有短生命周期对象的引用，或者在集合类中添加了对象但是忘记移除等。</li><li><strong>配置问题</strong>：JVM的堆大小是可以配置的，如果配置的老年代的大小不合理，也可能会导致内存溢出。例如，如果将堆的大部分空间都分配给了年轻代，那么老年代可能会因为空间不足而导致内存溢出。</li><li><strong>程序逻辑问题</strong>：如果程序的某部分代码创建了大量的长生命周期的对象，或者创建了大量的短生命周期的对象但没有足够的时间进行垃圾回收，那么也可能会导致老年代的内存溢出。</li></ol><p>分析这个问题，通常需要用到一些工具，比如JVisualVM，MAT，jmap等，通过这些工具我们可以看到堆的使用情况，以及哪些对象占用了大部分的内存，还可以分析对象的引用链，找出可能的内存泄漏点。</p><p>要解决这个问题，你需要首先确定问题的根源。如果是内存泄漏，需要修改程序逻辑以确保不再创建不必要的对象或及时地清理不再使用的对象。如果是配置问题，需要调整JVM的参数以合理地分配堆空间。如果是程序逻辑问题，可能需要优化代码以减少对象的创建或提高垃圾回收的效率。</p><h3 id="如果核心线程数是-5-已经启动-4-个任务-后面又进来-1-个-是优先复用前面四个任务中的空闲线程还是重新创建新线程-2023完美世界" tabindex="-1"><a class="header-anchor" href="#如果核心线程数是-5-已经启动-4-个任务-后面又进来-1-个-是优先复用前面四个任务中的空闲线程还是重新创建新线程-2023完美世界" aria-hidden="true">#</a> 如果核心线程数是 5，已经启动 4 个任务，后面又进来 1 个，是优先复用前面四个任务中的空闲线程还是重新创建新线程（2023完美世界）</h3><blockquote><p>线程池是为了限制系统中执行线程的数量。根据系统的任务负载和资源容量，线程池可以灵活地调整线程的数量，优化线程的管理，这样可以减少线程创建和销毁带来的额外开销。</p></blockquote><p>这个问题的答案取决于你使用的是什么样的线程池。如果你使用的是Java的ThreadPoolExecutor线程池，其行为会按照以下规则：</p><ol><li>如果当前运行的线程数量小于核心线程数，即使线程池中存在空闲线程，新任务到来也会创建新的线程处理任务。</li><li>只有在运行的线程数量已经达到核心线程数，但是任务队列未满时，新任务会被放到任务队列中等待。</li><li>如果当前运行的线程数量等于最大线程数且任务队列已满，新任务将会被拒绝。 所以，在你提供的这种情况下，如果线程池使用的是Java的ThreadPoolExecutor，且核心线程数是5，已经启动4个任务，后面又进来1个任务，会新开一个线程处理新的任务，而不是复用前面四个任务中的空闲线程。这是因为核心线程数没有被用完，线程池会优先创建新的线程。</li></ol><h3 id="如果大量请求进来你怎么限流-2023美团" tabindex="-1"><a class="header-anchor" href="#如果大量请求进来你怎么限流-2023美团" aria-hidden="true">#</a> 如果大量请求进来你怎么限流（2023美团）</h3><p>一些通用的限流手段是：</p><ol><li><strong>令牌桶</strong>：在令牌桶限流策略中，系统有一个令牌桶，桶中的令牌以一定的速率被添加。当一个新的请求到来时，系统会从桶中取出一个令牌。如果桶是空的，那么新的请求就会被拒绝。这种策略允许突然的大量请求，只要桶中有足够的令牌。在SpringCloud中可以使用spring-boot-starter-data-redis-reactive的令牌桶算法，根据Spring Cloud Gateway的客户端实际IP地址限制传入请求的速率。 简而言之，可以在路由上设置RequestRateLimiter过滤器，然后配置网关使用IP地址限制唯一客户端的请求。 在Spring Cloud中，你可以通过整合Redis以及使用Reactive编程模式来实现令牌桶算法。以下是一个基本的步骤：</li></ol><p>首先，你需要在你的pom.xml文件中添加相关的依赖：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis-reactive<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在你的Spring Cloud Gateway应用中，你需要创建一个自定义的GatewayFilter。此过滤器将负责检查每个请求的IP地址，并限制每个IP地址的请求速率。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateLimiterFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GatewayFilterFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RateLimiterFilter<span class="token punctuation">.</span>Config</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">RateLimiterService</span> rateLimiterService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">RateLimiterFilter</span><span class="token punctuation">(</span><span class="token class-name">RateLimiterService</span> rateLimiterService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>rateLimiterService <span class="token operator">=</span> rateLimiterService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">GatewayFilter</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">Config</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>exchange<span class="token punctuation">,</span> chain<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 获取请求的IP地址</span>
            <span class="token class-name">String</span> ipAddress <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRemoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHostAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rateLimiterService<span class="token punctuation">.</span><span class="token function">isAllowed</span><span class="token punctuation">(</span>ipAddress<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果超过了限制，返回429状态码（Too Many Requests）</span>
                <span class="token keyword">return</span> <span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ResponseStatusException</span><span class="token punctuation">(</span><span class="token class-name">HttpStatus</span><span class="token punctuation">.</span><span class="token constant">TOO_MANY_REQUESTS</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Config</span> <span class="token punctuation">{</span>
        <span class="token comment">// 配置属性可以在这里定义</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，你需要创建一个RateLimiterService，在这个服务中，你可以使用令牌桶算法和Reactive Redis操作实现请求速率的限制：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateLimiterService</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReactiveStringRedisTemplate</span> redisTemplate<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">RateLimiterService</span><span class="token punctuation">(</span><span class="token class-name">ReactiveStringRedisTemplate</span> redisTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>redisTemplate <span class="token operator">=</span> redisTemplate<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAllowed</span><span class="token punctuation">(</span><span class="token class-name">String</span> ipAddress<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用Redis和令牌桶算法实现速率限制的逻辑</span>
        <span class="token comment">// 这个部分需要根据你的具体需求来实现</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，在你的路由配置中使用这个过滤器：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">RouteLocator</span> <span class="token function">customRouteLocator</span><span class="token punctuation">(</span><span class="token class-name">RouteLocatorBuilder</span> builder<span class="token punctuation">,</span> <span class="token class-name">RateLimiterFilter</span> rateLimiterFilter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span>r <span class="token operator">-&gt;</span> r<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token string">&quot;/some-path/**&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">filters</span><span class="token punctuation">(</span>f <span class="token operator">-&gt;</span> f<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>rateLimiterFilter<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RateLimiterFilter<span class="token punctuation">.</span>Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span><span class="token string">&quot;lb://some-service&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>Sentinel 通过注解（@SentinelResource）</strong> 的方式将某个方法或者资源标记为受保护的资源，然后可以对这些资源设置各种规则，比如 QPS 限流，滑动窗口限流等。</li></ol><p>例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@SentinelResource</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span> blockHandler <span class="token operator">=</span> <span class="token string">&quot;exceptionHandler&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// your logic here</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，test 方法被标记为受 Sentinel 保护的资源，如果这个方法的调用频率超过了设定的限制，Sentinel 就会调用 exceptionHandler 方法来处理这个问题。</p><ol start="3"><li>使用<strong>消息队列</strong> (MQ) 进行限流也是一个常见的做法。通过将请求放入消息队列中，然后通过调整处理请求的速度来实现限流。例如，你可以使用 RabbitMQ、Kafka 等消息队列技术，这种方式也可以起到异步处理的作用，提高系统的吞吐量。</li></ol><h3 id="写-mq-时程序宕机了怎么办-2023美团" tabindex="-1"><a class="header-anchor" href="#写-mq-时程序宕机了怎么办-2023美团" aria-hidden="true">#</a> 写 MQ 时程序宕机了怎么办？（2023美团）</h3><p>如果在使用消息队列（MQ）时，生产者（Producer）程序在写入消息队列时宕机，那么你可能会面临消息丢失的问题。以下是一些可行的解决方案：</p><ol><li><strong>消息持久化</strong>：大多数消息队列系统（如RabbitMQ，Kafka）都支持消息的持久化。持久化的消息即使在宕机情况下也不会丢失，因为它们被存储在磁盘上。当服务器恢复后，可以继续从存储介质上读取并处理这些消息。但是，使用持久化会增加系统的开销并可能影响性能。</li><li><strong>高可用配置</strong>：配置高可用集群可以提高系统的稳定性。对于Kafka，可以配置多个副本，当某个节点宕机时，其他节点可以继续提供服务。RabbitMQ 也支持类似的镜像队列（Mirrored Queues）机制。</li><li><strong>生产者确认机制</strong>：许多消息队列系统提供了生产者确认（Producer Acknowledgments）机制，生产者只有在收到消息已成功写入消息队列的确认后，才会认为消息已成功发送。这样，如果在写入过程中服务器宕机，生产者知道消息没有成功发送，并且可以在服务器恢复后重新发送。</li><li><strong>使用事务</strong>：如果你的应用场景允许，你可以使用事务来确保消息的完整性。在一次事务中，你可以将消息的发送和你的业务操作放在一起，要么都成功，要么都失败。但是，使用事务会增加系统的复杂性，并可能影响性能。</li><li><strong>异步写入 + 本地日志</strong>：对于非常关键的消息，可以采取异步写入+本地日志的方式。先将消息写入本地日志，然后再异步写入消息队列，如果消息队列写入失败，通过后台进程重试，直到写入成功。</li></ol><p>在设计和选择方案时，需要根据你的应用的具体需求和可接受的复杂性进行权衡。例如，你需要考虑你的应用是否能接受消息的丢失，是否需要保证消息的顺序，你的系统是否能承受持久化和事务的开销，以及你的系统是否有足够的资源来支持高可用配置。</p><h3 id="秒杀场景下扣减库存太慢了怎么办-2023-滴滴" tabindex="-1"><a class="header-anchor" href="#秒杀场景下扣减库存太慢了怎么办-2023-滴滴" aria-hidden="true">#</a> 秒杀场景下扣减库存太慢了怎么办？（2023 滴滴）</h3><p>如果在秒杀场景下扣减库存的过程太慢，那么可能会导致系统的响应时间变长，用户体验下降，甚至系统过载。以下是一些优化扣减库存过程的建议：</p><ol><li><strong>使用内存数据库</strong>：相比于传统的关系型数据库，内存数据库如Redis的读写速度更快，适合处理高并发请求。你可以在活动开始前将库存信息预加载到Redis中，用户抢购时直接在Redis中扣减库存，活动结束后再将Redis中的数据同步回数据库。</li><li><strong>异步处理</strong>：用户的抢购请求可以先进入消息队列，由后台服务异步处理。这样用户的请求就可以立即得到响应，提高了用户体验，同时也减轻了服务器的压力。</li><li><strong>数据库优化</strong>：如果仍然使用关系型数据库，可以通过数据库层面的优化来提高效率，例如选择合适的索引、调整事务的隔离级别、使用批处理等。</li><li><strong>减少数据库操作</strong>：每次扣减库存时都需要更新数据库，这会占用大量的I/O资源。你可以采用一些方法来减少数据库操作，例如将用户的请求先暂存起来，当积累到一定数量或者过了一段时间后再批量更新到数据库。</li><li><strong>使用分布式系统</strong>：如果你的系统规模较大，可以考虑使用分布式系统来分担压力。例如，可以使用分布式数据库、分布式缓存、分布式计算等技术。</li></ol><h3 id="短信登录的短信怎么发送的-2023-滴滴" tabindex="-1"><a class="header-anchor" href="#短信登录的短信怎么发送的-2023-滴滴" aria-hidden="true">#</a> 短信登录的短信怎么发送的（2023 滴滴）</h3><p>短信登录的过程通常如下：</p><ol><li>用户在应用程序或网站上输入手机号码。</li><li>系统验证该手机号码的格式是否正确。</li><li>如果手机号码正确，系统将生成一个随机的验证码。</li><li>系统使用短信服务提供商（如Twilio, Alibaba SMS Service等）将验证码作为短信发送到用户的手机号码上。</li><li>用户收到短信后，将验证码输入应用程序或网站。</li><li>系统验证输入的验证码是否与发送的验证码一致。</li><li>如果一致，系统允许用户登录。</li></ol><h3 id="旁路缓存机制具体解决的什么场景-2023-滴滴" tabindex="-1"><a class="header-anchor" href="#旁路缓存机制具体解决的什么场景-2023-滴滴" aria-hidden="true">#</a> 旁路缓存机制具体解决的什么场景（2023 滴滴）</h3><p>旁路缓存（Sidecar Caching）是一种在获取数据时避免缓存穿透、缓存击穿和缓存雪崩等问题的策略。在使用Redis作为缓存系统时，我们可以使用旁路缓存策略来提高系统的稳定性和性能。</p><p>旁路缓存与普通缓存的主要区别在于其处理缓存未命中的策略。普通缓存在未命中时会直接让所有相关的请求去数据库中获取数据，但这在高并发的环境中可能导致数据库的负载过大。另外，如果数据库中也没有数据，那么这些请求可能会重复地查询数据库，这种情况被称为缓存穿透。</p><p>旁路缓存策略则在缓存未命中时，会先将所有请求暂时挂起，然后由一个专门的线程或进程去数据库中获取数据并更新缓存。这样，其他的请求只需要等待缓存被更新，而不需要自己去数据库中获取数据。这可以有效地降低数据库的负载，并且减少缓存穿透的可能。</p><p>旁路缓存的目的主要是保护数据库，防止在高并发的环境下由于缓存未命中导致数据库的负载过大。同时，它也可以减少缓存穿透的可能，提高系统的稳定性和性能。</p><p>写：</p><ul><li>先更新DB。</li><li>然后直接删除cache。 <img src="`+m+'" alt="" loading="lazy"></li></ul><p>读：</p><ul><li>从cache中读取数据，读取到就直接返回。</li><li>cache中读取不到的话，就从DB读取返回。</li><li>再把数据写到cache中。 <img src="'+v+'" alt="" loading="lazy"></li></ul><blockquote><p><strong>如果在写数据的过程中，可以先删除cache，再更新DB吗？</strong> 在写入数据时，采用“先删除缓存，再更新数据库”的策略是一种常见的做法。这种策略被称为&quot;Cache-Aside&quot;模式或&quot;先删后写&quot;策略。 其主要步骤如下：</p><ol><li>删除缓存：在更新数据库之前，首先删除对应的缓存数据。</li><li>更新数据库：删除缓存后，再去更新数据库。 但这个策略需要注意的问题是，如果在你删除了缓存后，和数据库更新之间的这段时间里，如果有其他请求查询这个数据，那么这个查询请求可能会因为在缓存中没找到数据，去数据库中查询并将查询结果写入缓存。这时，再去更新数据库就可能会导致缓存与数据库中的数据不一致。 为了避免这种情况，你可以使用一种称为“读写锁”的机制。在更新数据时，首先获取写锁，然后删除缓存并更新数据库，最后释放写锁。在读取数据时，首先获取读锁，然后从缓存中获取数据，如果缓存中没有数据，就去数据库中查询并更新缓存，最后释放读锁。这样就可以确保数据的一致性。</li></ol></blockquote><blockquote><p><strong>如果先写BD，再删除cache就不会造成数据不一致了吗？</strong> &quot;先写数据库，再删除缓存&quot;也是一种常见的处理方式，其理论上可以避免&quot;先删缓存，再写数据库&quot;策略中可能出现的数据不一致问题。 在&quot;先写数据库，再删除缓存&quot;策略中，由于数据已经被先更新到数据库，即使在更新数据库和删除缓存的短暂时间间隔内有新的读请求到达并更新了缓存，该缓存数据也是最新的，因此不会出现数据不一致的问题。 然而，这种策略也有其自身的问题。在并发环境下，如果两个请求，一个是写请求，一个是读请求，它们几乎同时到达，可能会出现以下情况：</p><ol><li>写请求先更新了数据库</li><li>读请求读取数据库，并将数据写入缓存</li><li>写请求删除了缓存 在这种情况下，缓存就会丢失，导致后续的读请求必须直接访问数据库，这可能会增加数据库的负载。因此，不论是&quot;先删缓存，再写数据库&quot;还是&quot;先写数据库，再删缓存&quot;，都有可能存在问题</li></ol></blockquote><h3 id="更新缓存失败了怎么办-2023-滴滴" tabindex="-1"><a class="header-anchor" href="#更新缓存失败了怎么办-2023-滴滴" aria-hidden="true">#</a> 更新缓存失败了怎么办（2023 滴滴）</h3><ul><li>重新尝试：如果错误是暂时的，例如网络抖动，那么你可以尝试再次更新缓存。</li><li>失败后的兜底策略：如果缓存系统存在问题且无法立即修复，可以考虑暂时绕过缓存，直接访问原始数据源。这可以确保业务的正常运行，但可能会增加原始数据源的负载。</li></ul><blockquote><p>重试的时候，缓存中的错数据被访问多次了，怎么解决（2023 滴滴）</p></blockquote><p>当尝试更新缓存时，如果数据已经被错误地写入到缓存中，那么这个错误数据可能会被多次访问。这是一个常见的问题，有几种可能的解决方案：</p><ol><li>延迟更新：一种方法是在写入新数据之前，先将旧数据从缓存中删除，然后再写入新数据。这可以确保在新数据还没有被写入缓存时，客户端只能获取到旧的数据，而不是错误的数据。然而，这可能会导致缓存“空窗期”的问题。</li><li>读写锁：使用读写锁可以保证在写入新数据时，不会有读取操作发生。在更新缓存的过程中，写操作将会锁定数据，读操作将会被阻塞，直到新的数据写入完毕。</li><li>乐观并发控制：你可以使用乐观并发控制，只有在数据没有发生改变的情况下，才能更新缓存。这需要在原始数据源中保存数据版本信息，并在更新缓存时检查数据版本。</li><li>原子操作：一些缓存系统支持原子操作，可以确保数据的更新是原子的，即数据的更新要么全部成功，要么全部失败，不会出现部分成功的情况。</li></ol><h3 id="如何设计抢优惠券-2023-滴滴" tabindex="-1"><a class="header-anchor" href="#如何设计抢优惠券-2023-滴滴" aria-hidden="true">#</a> 如何设计抢优惠券？（2023 滴滴）</h3><p>设计一个抢优惠券的系统可以涉及到很多方面，包括并发控制、数据一致性、通知机制等等。以下是一个基本的设计思路：</p><ol><li><strong>预热数据</strong>：为了减少数据库的压力，可以在活动开始之前将优惠券的信息预热到缓存中，例如使用Redis。</li><li><strong>限流</strong>：由于抢优惠券的活动可能会产生巨大的流量，需要采取限流措施防止服务器过载。可以使用如令牌桶或漏桶等限流算法。</li><li><strong>并发控制</strong>：为了处理大量用户同时抢购的情况，可以采用Java的并发处理能力，如线程池、CompletableFuture等。也可以采用分布式系统设计，使用多个服务器共同处理请求。</li><li><strong>数据一致性</strong>：为了避免超卖的问题，需要确保数据的一致性。这可以通过事务控制或分布式锁等方式实现。例如，使用Redis或ZooKeeper实现分布式锁。</li><li><strong>异步处理</strong>：抢购的请求可以通过消息队列异步处理，不仅可以减轻服务器的压力，还可以提高用户的体验。比如，用户点击抢购后，立即返回一个正在处理的响应，然后通过消息队列在后台处理抢购的逻辑。</li><li><strong>通知用户</strong>：当抢购处理完后，需要及时通知用户结果。可以通过邮件、短信、应用内通知或者推送通知等方式。</li><li><strong>容错和备份</strong>：系统需要有足够的容错和备份机制，以便在出现问题时快速恢复。</li><li><strong>监控和报警</strong>：设置监控和报警机制，对系统的运行状态进行实时监控，一旦发现异常，立即触发报警，便于及时处理。</li></ol><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2><h3 id="讲一讲cms" tabindex="-1"><a class="header-anchor" href="#讲一讲cms" aria-hidden="true">#</a> 讲一讲cms？</h3><p>内容管理系统（英语：content management system，缩写为 CMS）是指在一个合作模式下，用于管理工作流程的一套制度。该系统可应用于手工操作中，也可以应用到电脑或网络里。作为一种中央储存器（central repository），内容管理系统可将相关内容集中储存并具有群组管理、版本控制等功能。版本控制是内容管理系统的一个主要优势。</p><p>内容管理系统在物品或文案或数据的存储、掌管、修订（盘存）、语用充实、文档发布等方面有着广泛的应用。现在流行的开源CMS系统有WordPress、Joomla!、Drupal、Xoops、CmsTop等。</p>',59),Qn={href:"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F",target:"_blank",rel:"noopener noreferrer"},Un=n("h3",{id:"dts-了解过吗",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#dts-了解过吗","aria-hidden":"true"},"#"),s(" DTS 了解过吗？")],-1),Kn=n("p",null,"数字剧院系统（DTS，Digital Theater Systems）由DTS公司（DTS Inc.，NASDAQ：DTSI）开发，为多声道音频格式中的一种，广泛应用于DVD音效上。其最普遍的格式为5.1声道。与杜比数字为主要竞争对手。要实现DTS音效输出，需在硬件上及软件上符合DTS的规格，多数会在产品上标示DTS的商标。",-1),Wn={href:"https://zh.wikipedia.org/wiki/DTS",target:"_blank",rel:"noopener noreferrer"},Xn=n("h2",{id:"💦-算法汇总",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#💦-算法汇总","aria-hidden":"true"},"#"),s(" 💦 算法汇总")],-1),Zn={href:"https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/",target:"_blank",rel:"noopener noreferrer"};function Yn($n,ns){const i=o("RouterLink"),e=o("ExternalLinkIcon");return r(),c("div",null,[y,n("p",null,[s("2022有的大厂面试题不会在2023再次出现（也有可能会因为粗心加上，欢迎issue或者PR指正和修改），如果想要了解可以先看"),a(i,{to:"/Java/eightpart/giant.html"},{default:u(()=>[s("2022大厂面试")]),_:1}),s("版本。")]),f,n("blockquote",null,[_,n("ul",null,[n("li",null,[n("a",w,[s("https://stackoverflow.com/questions/2444005/how-do-i-make-my-arraylist-thread-safe-another-approach-to-problem-in-java"),a(e)]),s(" 如何使我的ArrayList线程安全？Java问题的另一种方法？")]),n("li",null,[n("a",S,[s("https://stackoverflow.com/questions/18983362/how-to-prove-arraylist-is-not-thread-safe-with-a-test"),a(e)]),s(" 如何用测试证明数组列表不是线程安全的？")]),n("li",null,[n("a",x,[s("https://stackoverflow.com/questions/300519/arraylist-vs-vectors-in-java-if-thread-safety-isnt-a-concern"),a(e)]),s(" ArrayList与vector，Java如果线程安全不是一个问题")])])]),C,L,q,R,M,n("blockquote",null,[A,n("ol",null,[n("li",null,[n("a",T,[s("https://stackoverflow.com/questions/602636/why-is-a-concurrentmodificationexception-thrown-and-how-to-debug-it"),a(e)]),s(" 为什么会抛出它会抛出ConcurrentModificationException异常以及如何调试它")]),n("li",null,[n("a",E,[s("https://www.javatpoint.com/concurrentmodificationexception-in-java"),a(e)])])])]),P,n("blockquote",null,[j,n("ul",null,[n("li",null,[n("a",O,[s("https://programming.vip/docs/6200e8e7b682c.html"),a(e)]),s(" 【Mybatis源码解析】Mybatis源码涉及的设计模式总结")]),n("li",null,[n("a",J,[s("https://programming.vip/docs/mybatis-design-pattern.html"),a(e)]),s(" Mybatis设计模式")])])]),B,I,z,n("blockquote",null,[N,n("ul",null,[n("li",null,[n("a",D,[s("https://stackoverflow.com/questions/62137/what-is-a-covered-index"),a(e)]),s(" 什么是覆盖索引？")]),n("li",null,[n("a",G,[s("https://xiaolincoding.com/mysql/index/index_interview.html#按字段个数分类"),a(e)]),s(" 覆盖索引优化-小林coding")]),n("li",null,[n("a",H,[s("https://stackoverflow.com/questions/609343/what-are-covering-indexes-and-covered-queries-in-sql-server"),a(e)]),s(" 在SQL Server中什么是覆盖索引和覆盖查询？")]),n("li",null,[n("a",V,[s("https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/covering-indexes.html"),a(e)]),s(" Covering Indexes")]),n("li",null,[n("a",F,[s("https://www.red-gate.com/simple-talk/databases/sql-server/learn/using-covering-indexes-to-improve-query-performance/"),a(e)]),s(" 使用覆盖索引以提高查询性能")])])]),Q,n("blockquote",null,[U,n("ol",null,[n("li",null,[n("a",K,[s("https://loadforge.com/guides/troubleshooting-redis-performance-issues"),a(e)])]),n("li",null,[n("a",W,[s("https://severalnines.com/blog/performance-tuning-redis/"),a(e)])])])]),X,Z,Y,n("blockquote",null,[n("p",null,[s("参考："),n("a",$,[s("https://xiaolincoding.com/mysql/transaction/mvcc.html"),a(e)])])]),nn,n("blockquote",null,[sn,n("ol",null,[n("li",null,[n("a",an,[s("https://blog.csdn.net/Weixiaohuai/article/details/125391957"),a(e)])]),n("li",null,[n("a",en,[s("https://min.news/en/news/a1b1f8acadd9af9be99514da7504de1b.html"),a(e)])]),n("li",null,[n("a",tn,[s("https://www.dragonflydb.io/error-solutions/redis-big-key-problem"),a(e)])]),n("li",null,[n("a",on,[s("https://xiaolincoding.com/redis/base/redis_interview.html#redis-的大-key-如何处理"),a(e)])])])]),ln,n("blockquote",null,[pn,n("ol",null,[n("li",null,[n("a",rn,[s("https://dzone.com/articles/redis-hotspot-key-discovery-and-common-solutions"),a(e)])]),n("li",null,[n("a",cn,[s("https://developer.redis.com/howtos/antipatterns/"),a(e)])]),n("li",null,[n("a",un,[s("https://github.com/twitter/twemproxy"),a(e)])])])]),dn,kn,hn,gn,n("blockquote",null,[mn,n("ol",null,[n("li",null,[n("a",vn,[s("https://redis.io/docs/data-types/sorted-sets/"),a(e)])]),n("li",null,[n("a",bn,[s("https://www.educba.com/redis-zset/"),a(e)])]),n("li",null,[n("a",yn,[s("https://redis.io/commands/zadd/"),a(e)])])])]),fn,n("blockquote",null,[_n,n("ul",null,[n("li",null,[n("a",wn,[s("https://stackoverflow.com/questions/19154607/how-actually-card-table-and-writer-barrier-work"),a(e)]),s(" 卡表和写屏障是如何工作的？")]),n("li",null,[n("a",Sn,[s("https://tschatzl.github.io/2022/02/15/card-table-card-size.html"),a(e)]),s(" Card Table Card Size Shenanigans")]),n("li",null,[n("a",xn,[s("https://www.mo4tech.com/jvm-card-table.html"),a(e)]),s(" JVM Card Table")]),n("li",null,[n("a",Cn,[s("https://www.cnblogs.com/hongdada/p/12016020.html"),a(e)]),s(" JVM-卡表（Card Table）")]),n("li",null,[n("a",Ln,[s("http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html"),a(e)]),s(" Alexey Ragozin")])])]),qn,n("blockquote",null,[Rn,n("ol",null,[n("li",null,[n("a",Mn,[s("https://stackoverflow.com/questions/24766118/when-is-a-full-gc-triggered"),a(e)])])])]),An,n("blockquote",null,[Tn,n("ol",null,[n("li",null,[n("a",En,[s("https://http2.github.io/"),a(e)])]),n("li",null,[n("a",Pn,[s("https://en.wikipedia.org/wiki/HTTP/2"),a(e)])]),n("li",null,[n("a",jn,[s("https://web.dev/performance-http2/"),a(e)])]),n("li",null,[n("a",On,[s("https://www.digitalocean.com/community/tutorials/http-1-1-vs-http-2-what-s-the-difference"),a(e)])])])]),Jn,n("blockquote",null,[n("p",null,[s("参考："),n("a",Bn,[s("https://linyunwen.github.io/2022/01/02/linux-io-model/"),a(e)])])]),In,n("blockquote",null,[zn,n("ol",null,[n("li",null,[n("a",Nn,[s("https://stackoverflow.com/questions/21033104/close-wait-state-in-server"),a(e)]),s(" 服务器中的CLOSE_WAIT状态")]),n("li",null,[n("a",Dn,[s("https://superuser.com/questions/173535/what-are-close-wait-and-time-wait-states"),a(e)]),s(" 什么是CLOSE_WAITTIME_WAIT状态？")]),n("li",null,[n("a",Gn,[s("https://learn.microsoft.com/en-us/answers/questions/337518/tcp-connections-locked-in-close-wait-status-with-i"),a(e)])]),n("li",null,[n("a",Hn,[s("https://www.cnblogs.com/grey-wolf/p/10936657.html"),a(e)])]),n("li",null,[n("a",Vn,[s("https://juejin.cn/post/6844903734300901390#heading-6"),a(e)])])])]),Fn,n("blockquote",null,[n("p",null,[s("参考： "),n("a",Qn,[s("https://zh.wikipedia.org/wiki/内容管理系统"),a(e)])])]),Un,Kn,n("blockquote",null,[n("p",null,[s("参考： "),n("a",Wn,[s("https://zh.wikipedia.org/wiki/DTS"),a(e)])])]),Xn,n("ol",null,[n("li",null,[n("a",Zn,[s("二叉树的公共祖先（2023 快手）"),a(e)])])])])}const es=p(b,[["render",Yn],["__file","gaint2023.html.vue"]]);export{es as default};
