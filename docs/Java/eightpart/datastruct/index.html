<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Java/eightpart/datastruct">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">datastruct | Computer Science Learn Notes</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/datastruct"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="datastruct | Computer Science Learn Notes"><meta data-rh="true" name="description" content="🧩数据结构"><meta data-rh="true" property="og:description" content="🧩数据结构"><link data-rh="true" rel="icon" href="/Computer-Science-Learn-Notes/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/datastruct"><link data-rh="true" rel="alternate" href="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/datastruct" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/datastruct" hreflang="x-default"><link rel="stylesheet" href="/Computer-Science-Learn-Notes/assets/css/styles.e7823470.css">
<link rel="preload" href="/Computer-Science-Learn-Notes/assets/js/runtime~main.978cdf48.js" as="script">
<link rel="preload" href="/Computer-Science-Learn-Notes/assets/js/main.7c330b06.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Computer-Science-Learn-Notes/"><div class="navbar__logo"><img src="/Computer-Science-Learn-Notes/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/Computer-Science-Learn-Notes/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Computer Science Learn Notes</b></a><a class="navbar__item navbar__link" href="/Computer-Science-Learn-Notes/docs/intro">主页</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/zhiyu1998/Computer-Science-Learn-Notes" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="搜索" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div><div class="searchHintContainer_Pkmr"><kbd class="searchHint_iIMx">ctrl</kbd><kbd class="searchHint_iIMx">K</kbd></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/Computer-Science-Learn-Notes/docs/golang/learnInProblem">目录</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/golang/learnInProblem">Go语言</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/frontend/react/">前端</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/fundamental/datastruct">基础知识</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/basic/">Java基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/giant">Java面试</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/giant">2022大厂面试题</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intro">常见面试题精选</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intro">前言</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/foundation">Java基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/concurrency">Java并发</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/virtualMachine">JVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/spring">Spring系列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/mysql">MySQL</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/redis">Redis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/distribution">分布式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/messageQueue">消息队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/netty">Netty</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/network">计算机网络</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/system">操作系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/datastruct">数据结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intelligenceQuestion">智力题</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/think">基于面试题的一些思考</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/leetcode/">力扣刷题顺序</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/leetcode/src/剑指offer/数组中重复的数字">刷题汇总</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/others/personal_tech">其他分享</a></div></li></ul></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/Computer-Science-Learn-Notes/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">目录</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Java面试</span><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">常见面试题精选</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">数据结构</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>datastruct</h1></header><h3 class="anchor anchorWithStickyNavbar_LWe7" id="数据结构">🧩数据结构<a href="#数据结构" class="hash-link" aria-label="🧩数据结构的直接链接" title="🧩数据结构的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="红黑树">红黑树<a href="#红黑树" class="hash-link" aria-label="红黑树的直接链接" title="红黑树的直接链接">​</a></h4><p><strong>红黑树特点</strong> :</p><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p><strong>红黑树的应用</strong> ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。</p><p><strong>为什么要用红黑树？</strong> 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 <a href="https://juejin.im/post/5a27c6946fb9a04509096248#comment" target="_blank" rel="noopener noreferrer">漫画：什么是红黑树？open in new window</a>（也介绍到了二叉查找树，非常推荐）</p><p><strong>相关阅读</strong> ：<a href="https://zhuanlan.zhihu.com/p/24367771" target="_blank" rel="noopener noreferrer">《红黑树深入剖析及Java实现》open in new window</a>（美团点评技术团队）</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="十大经典排序算法">十大经典排序算法<a href="#十大经典排序算法" class="hash-link" aria-label="十大经典排序算法的直接链接" title="十大经典排序算法的直接链接">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="简介">简介<a href="#简介" class="hash-link" aria-label="简介的直接链接" title="简介的直接链接">​</a></h5><p>排序算法可以分为：</p><ul><li><strong>内部排序</strong> ：数据记录在内存中进行排序。</li><li><strong><a href="https://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener noreferrer">外部排序</a></strong> ：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</li></ul><p>常见的内部排序算法有：<strong>插入排序</strong>、<strong>希尔排序</strong>、<strong>选择排序</strong>、<strong>冒泡排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong>、<strong>基数排序</strong>等，本文只讲解内部排序算法。用一张图概括：</p><p><img loading="lazy" alt="十大排序算法" src="/Computer-Science-Learn-Notes/assets/images/sort1-adc19d2483dbb4b89a2e4887ed0ed1f3.png" width="1580" height="755" class="img_ev3q"></p><p><strong>图片名词解释：</strong></p><ul><li><strong>n</strong>：数据规模</li><li><strong>k</strong>：“桶” 的个数</li><li><strong>In-place</strong>：占用常数内存，不占用额外内存</li><li><strong>Out-place</strong>：占用额外内存</li></ul><h6 class="anchor anchorWithStickyNavbar_LWe7" id="术语说明">术语说明<a href="#术语说明" class="hash-link" aria-label="术语说明的直接链接" title="术语说明的直接链接">​</a></h6><ul><li><strong>稳定</strong>：如果 A 原本在 B 前面，而 A=B，排序之后 A 仍然在 B 的前面。</li><li><strong>不稳定</strong>：如果 A 原本在 B 的前面，而 A=B，排序之后 A 可能会出现在 B 的后面。</li><li><strong>内排序</strong>：所有排序操作都在内存中完成。</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li><li><strong>时间复杂度</strong>： 定性描述一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong>：定性描述一个算法执行所需内存的大小。</li></ul><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法分类">算法分类<a href="#算法分类" class="hash-link" aria-label="算法分类的直接链接" title="算法分类的直接链接">​</a></h6><p>十种常见排序算法可以分类两大类别：<strong>比较类排序</strong>和<strong>非比较类排序</strong>。</p><p><img loading="lazy" alt="1658302145982" src="/Computer-Science-Learn-Notes/assets/images/1658302145982-88a1d4abb5ea774ba29cc92d0a3ccf20.png" width="1558" height="1135" class="img_ev3q"></p><p>常见的<strong>快速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>以及<strong>冒泡排序</strong>等都属于<strong>比较类排序算法</strong>。比较类排序是通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 <code>O(nlogn)</code>，因此也称为非线性时间比较类排序。在冒泡排序之类的排序中，问题规模为 <code>n</code>，又因为需要比较 <code>n</code> 次，所以平均时间复杂度为 <code>O(n²)</code>。在<strong>归并排序</strong>、<strong>快速排序</strong>之类的排序中，问题规模通过<strong>分治法</strong>消减为 <code>logn</code> 次，所以时间复杂度平均 <code>O(nlogn)</code>。</p><p>比较类排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p><p>而<strong>计数排序</strong>、<strong>基数排序</strong>、<strong>桶排序</strong>则属于<strong>非比较类排序算法</strong>。非比较排序不通过比较来决定元素间的相对次序，而是通过确定每个元素之前，应该有多少个元素来排序。由于它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 <code>O(n)</code>。</p><p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="冒泡排序-bubble-sort">冒泡排序 (Bubble Sort)<a href="#冒泡排序-bubble-sort" class="hash-link" aria-label="冒泡排序 (Bubble Sort)的直接链接" title="冒泡排序 (Bubble Sort)的直接链接">​</a></h5><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作是重复地进行直到没有再需要交换为止，此时说明该序列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法步骤">算法步骤<a href="#算法步骤" class="hash-link" aria-label="算法步骤的直接链接" title="算法步骤的直接链接">​</a></h6><p><img loading="lazy" src="https://guide-blog-./personal_images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/bubble_sort.gif" class="img_ev3q"></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="代码实现">代码实现<a href="#代码实现" class="hash-link" aria-label="代码实现的直接链接" title="代码实现的直接链接">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 冒泡排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static int[] bubbleSort(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt; arr.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Set a flag, if true, that means the loop has not been swapped,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // that is, the sequence has been ordered, the sorting has been completed.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean flag = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; arr.length - i; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (arr[j] &gt; arr[j + 1]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int tmp = arr[j];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                arr[j] = arr[j + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                arr[j + 1] = tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Change flag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                flag = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (flag) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>此处对代码做了一个小优化，加入了 <code>is_sorted</code> Flag，目的是将算法的最佳时间复杂度优化为 <code>O(n)</code>，即当原输入序列就是排序好的情况下，该算法的时间复杂度就是 <code>O(n)</code>。</strong></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法分析">算法分析<a href="#算法分析" class="hash-link" aria-label="算法分析的直接链接" title="算法分析的直接链接">​</a></h6><ul><li><strong>稳定性</strong>：稳定</li><li><strong>时间复杂度</strong> ：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li><li><strong>空间复杂度</strong> ：O(1)</li><li><strong>排序方式</strong> ：In-place</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="选择排序-selection-sort">选择排序 (Selection Sort)<a href="#选择排序-selection-sort" class="hash-link" aria-label="选择排序 (Selection Sort)的直接链接" title="选择排序 (Selection Sort)的直接链接">​</a></h5><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²)</code> 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法步骤-1">算法步骤<a href="#算法步骤-1" class="hash-link" aria-label="算法步骤的直接链接" title="算法步骤的直接链接">​</a></h6><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第 2 步，直到所有元素均排序完毕。</li></ol><p><img loading="lazy" src="https://guide-blog-./personal_images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/selection_sort.gif" class="img_ev3q"></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="代码实现-1">代码实现<a href="#代码实现-1" class="hash-link" aria-label="代码实现的直接链接" title="代码实现的直接链接">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 选择排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static int[] selectionSort(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; arr.length - 1; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int minIndex = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = i + 1; j &lt; arr.length; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (arr[j] &lt; arr[minIndex]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                minIndex = j;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (minIndex != i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int tmp = arr[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arr[i] = arr[minIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arr[minIndex] = tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法分析-1">算法分析<a href="#算法分析-1" class="hash-link" aria-label="算法分析的直接链接" title="算法分析的直接链接">​</a></h6><ul><li><strong>稳定性</strong>：不稳定</li><li><strong>时间复杂度</strong> ：最佳：O(n2) ，最差：O(n2)， 平均：O(n2)</li><li><strong>空间复杂度</strong> ：O(1)</li><li><strong>排序方式</strong> ：In-place</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="插入排序-insertion-sort">插入排序 (Insertion Sort)<a href="#插入排序-insertion-sort" class="hash-link" aria-label="插入排序 (Insertion Sort)的直接链接" title="插入排序 (Insertion Sort)的直接链接">​</a></h5><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 <code>O(1)</code> 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法步骤-2">算法步骤<a href="#算法步骤-2" class="hash-link" aria-label="算法步骤的直接链接" title="算法步骤的直接链接">​</a></h6><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2~5。</li></ol><p><img loading="lazy" src="https://guide-blog-./personal_images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/insertion_sort.gif" class="img_ev3q"></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="代码实现-2">代码实现<a href="#代码实现-2" class="hash-link" aria-label="代码实现的直接链接" title="代码实现的直接链接">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 插入排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static int[] insertionSort(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt; arr.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int preIndex = i - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int current = arr[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (preIndex &gt;= 0 &amp;&amp; current &lt; arr[preIndex]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arr[preIndex + 1] = arr[preIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            preIndex -= 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr[preIndex + 1] = current;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法分析-2">算法分析<a href="#算法分析-2" class="hash-link" aria-label="算法分析的直接链接" title="算法分析的直接链接">​</a></h6><ul><li><strong>稳定性</strong>：稳定</li><li><strong>时间复杂度</strong> ：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li><li><strong>空间复杂度</strong> ：O(1)</li><li><strong>排序方式</strong> ：In-place</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="希尔排序-shell-sort">希尔排序 (Shell Sort)<a href="#希尔排序-shell-sort" class="hash-link" aria-label="希尔排序 (Shell Sort)的直接链接" title="希尔排序 (Shell Sort)的直接链接">​</a></h5><p>希尔排序是希尔 (Donald Shell) 于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为递减增量排序算法，同时该算法是冲破 <code>O(n²)</code> 的第一批算法之一。</p><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法步骤-3">算法步骤<a href="#算法步骤-3" class="hash-link" aria-label="算法步骤的直接链接" title="算法步骤的直接链接">​</a></h6><p>我们来看下希尔排序的基本步骤，在此我们选择增量 <code>gap=length/2</code>，缩小增量继续以 <code>gap = gap/2</code> 的方式，这种增量选择我们可以用一个序列来表示，<code>{n/2, (n/2)/2, ..., 1}</code>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列 <code>{t1, t2, …, tk}</code>，其中 <code>(ti&gt;tj, i&lt;j, tk=1)</code>；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 <code>t</code>，将待排序列分割成若干长度为 <code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><p><img loading="lazy" src="https://guide-blog-./personal_images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/shell_sort.png" class="img_ev3q"></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="代码实现-3">代码实现<a href="#代码实现-3" class="hash-link" aria-label="代码实现的直接链接" title="代码实现的直接链接">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 希尔排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static int[] shellSort(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int n = arr.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int gap = n / 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (gap &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = gap; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int current = arr[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int preIndex = i - gap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Insertion sort</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                arr[preIndex + gap] = arr[preIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                preIndex -= gap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arr[preIndex + gap] = current;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gap /= 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法分析-3">算法分析<a href="#算法分析-3" class="hash-link" aria-label="算法分析的直接链接" title="算法分析的直接链接">​</a></h6><ul><li><strong>稳定性</strong>：稳定</li><li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(n2) 平均：O(nlogn)</li><li><strong>空间复杂度</strong> ：<code>O(n)</code></li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="归并排序-merge-sort">归并排序 (Merge Sort)<a href="#归并排序-merge-sort" class="hash-link" aria-label="归并排序 (Merge Sort)的直接链接" title="归并排序 (Merge Sort)的直接链接">​</a></h5><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法 (Divide and Conquer) 的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 - 路归并。</p><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 <code>O(nlogn)</code> 的时间复杂度。代价是需要额外的内存空间。</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法步骤-4">算法步骤<a href="#算法步骤-4" class="hash-link" aria-label="算法步骤的直接链接" title="算法步骤的直接链接">​</a></h6><p>归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下：</p><ol><li>如果输入内只有一个元素，则直接返回，否则将长度为 <code>n</code> 的输入序列分成两个长度为 <code>n/2</code> 的子序列；</li><li>分别对这两个子序列进行归并排序，使子序列变为有序状态；</li><li>设定两个指针，分别指向两个已经排序子序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；</li><li>重复步骤 3 ~4 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><p><img loading="lazy" src="https://guide-blog-./personal_images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/merge_sort.gif" class="img_ev3q"></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="代码实现-4">代码实现<a href="#代码实现-4" class="hash-link" aria-label="代码实现的直接链接" title="代码实现的直接链接">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 归并排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static int[] mergeSort(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (arr.length &lt;= 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int middle = arr.length / 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] arr_1 = Arrays.copyOfRange(arr, 0, middle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] arr_2 = Arrays.copyOfRange(arr, middle, arr.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return merge(mergeSort(arr_1), mergeSort(arr_2));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Merge two sorted arrays</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr_1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr_2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return sorted_arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static int[] merge(int[] arr_1, int[] arr_2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] sorted_arr = new int[arr_1.length + arr_2.length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int idx = 0, idx_1 = 0, idx_2 = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (idx_1 &lt; arr_1.length &amp;&amp; idx_2 &lt; arr_2.length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (arr_1[idx_1] &lt; arr_2[idx_2]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sorted_arr[idx] = arr_1[idx_1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            idx_1 += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sorted_arr[idx] = arr_2[idx_2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            idx_2 += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        idx += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (idx_1 &lt; arr_1.length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (idx_1 &lt; arr_1.length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sorted_arr[idx] = arr_1[idx_1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            idx_1 += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            idx += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (idx_2 &lt; arr_2.length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sorted_arr[idx] = arr_2[idx_2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            idx_2 += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            idx += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return sorted_arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法分析-4">算法分析<a href="#算法分析-4" class="hash-link" aria-label="算法分析的直接链接" title="算法分析的直接链接">​</a></h6><ul><li><strong>稳定性</strong>：稳定</li><li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li><li><strong>空间复杂度</strong> ：O(n)</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="快速排序-quick-sort">快速排序 (Quick Sort)<a href="#快速排序-quick-sort" class="hash-link" aria-label="快速排序 (Quick Sort)的直接链接" title="快速排序 (Quick Sort)的直接链接">​</a></h5><p>快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并不稳定。</p><p>快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法步骤-5">算法步骤<a href="#算法步骤-5" class="hash-link" aria-label="算法步骤的直接链接" title="算法步骤的直接链接">​</a></h6><p>快速排序使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95" target="_blank" rel="noopener noreferrer">分治法</a>（Divide and conquer）策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：</p><ol><li>从序列中<strong>随机</strong>挑出一个元素，做为 “基准”(<code>pivot</code>)；</li><li>重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</li></ol><p><img loading="lazy" src="https://guide-blog-./personal_images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/random_quick_sort.gif" class="img_ev3q"></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="代码实现-5">代码实现<a href="#代码实现-5" class="hash-link" aria-label="代码实现的直接链接" title="代码实现的直接链接">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static int partition(int[] array, int low, int high) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int pivot = array[high];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int pointer = low;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = low; i &lt; high; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (array[i] &lt;= pivot) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int temp = array[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            array[i] = array[pointer];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            array[pointer] = temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pointer++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Arrays.toString(array));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int temp = array[pointer];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    array[pointer] = array[high];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    array[high] = temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return pointer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void quickSort(int[] array, int low, int high) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (low &lt; high) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int position = partition(array, low, high);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        quickSort(array, low, position - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        quickSort(array, position + 1, high);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法分析-5">算法分析<a href="#算法分析-5" class="hash-link" aria-label="算法分析的直接链接" title="算法分析的直接链接">​</a></h6><ul><li><strong>稳定性</strong> ：不稳定</li><li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)，平均：O(nlogn)</li><li><strong>空间复杂度</strong> ：O(nlogn)</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="堆排序-heap-sort">堆排序 (Heap Sort)<a href="#堆排序-heap-sort" class="hash-link" aria-label="堆排序 (Heap Sort)的直接链接" title="堆排序 (Heap Sort)的直接链接">​</a></h5><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足<strong>堆的性质</strong>：即<strong>子结点的值总是小于（或者大于）它的父节点</strong>。</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法步骤-6">算法步骤<a href="#算法步骤-6" class="hash-link" aria-label="算法步骤的直接链接" title="算法步骤的直接链接">​</a></h6><ol><li>将初始待排序列 <code>(R1, R2, ……, Rn)</code> 构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素 <code>R[1]</code> 与最后一个元素 <code>R[n]</code> 交换，此时得到新的无序区 <code>(R1, R2, ……, Rn-1)</code> 和新的有序区 (Rn), 且满足 <code>R[1, 2, ……, n-1]&lt;=R[n]</code>；</li><li>由于交换后新的堆顶 <code>R[1]</code> 可能违反堆的性质，因此需要对当前无序区 <code>(R1, R2, ……, Rn-1)</code> 调整为新堆，然后再次将 R <!-- -->[1]<!-- --> 与无序区最后一个元素交换，得到新的无序区 <code>(R1, R2, ……, Rn-2)</code> 和新的有序区 <code>(Rn-1, Rn)</code>。不断重复此过程直到有序区的元素个数为 <code>n-1</code>，则整个排序过程完成</li></ol><p><img loading="lazy" src="https://guide-blog-./personal_images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/heap_sort.gif" class="img_ev3q"></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="代码实现-6">代码实现<a href="#代码实现-6" class="hash-link" aria-label="代码实现的直接链接" title="代码实现的直接链接">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Global variable that records the length of an array;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int heapLen;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Swap the two elements of an array</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param j</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static void swap(int[] arr, int i, int j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int tmp = arr[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    arr[i] = arr[j];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    arr[j] = tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Build Max Heap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static void buildMaxHeap(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = arr.length / 2 - 1; i &gt;= 0; i--) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        heapify(arr, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Adjust it to the maximum heap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static void heapify(int[] arr, int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int left = 2 * i + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int right = 2 * i + 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int largest = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (right &lt; heapLen &amp;&amp; arr[right] &gt; arr[largest]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        largest = right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (left &lt; heapLen &amp;&amp; arr[left] &gt; arr[largest]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        largest = left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (largest != i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        swap(arr, largest, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        heapify(arr, largest);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Heap Sort</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static int[] heapSort(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // index at the end of the heap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    heapLen = arr.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // build MaxHeap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    buildMaxHeap(arr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = arr.length - 1; i &gt; 0; i--) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Move the top of the heap to the tail of the heap in turn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        swap(arr, 0, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        heapLen -= 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        heapify(arr, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法分析-6">算法分析<a href="#算法分析-6" class="hash-link" aria-label="算法分析的直接链接" title="算法分析的直接链接">​</a></h6><ul><li><strong>稳定性</strong> ：不稳定</li><li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li><li><strong>空间复杂度</strong> ：O(1)</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="计数排序-counting-sort">计数排序 (Counting Sort)<a href="#计数排序-counting-sort" class="hash-link" aria-label="计数排序 (Counting Sort)的直接链接" title="计数排序 (Counting Sort)的直接链接">​</a></h5><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数</strong>。</p><p>计数排序 (Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组 <code>C</code>，其中第 <code>i</code> 个元素是待排序数组 <code>A</code> 中值等于 <code>i</code> 的元素的个数。然后根据数组 <code>C</code> 来将 <code>A</code> 中的元素排到正确的位置。<strong>它只能对整数进行排序</strong>。</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法步骤-7">算法步骤<a href="#算法步骤-7" class="hash-link" aria-label="算法步骤的直接链接" title="算法步骤的直接链接">​</a></h6><ol><li>找出数组中的最大值 <code>max</code>、最小值 <code>min</code>；</li><li>创建一个新数组 <code>C</code>，其长度是 <code>max-min+1</code>，其元素默认值都为 0；</li><li>遍历原数组 <code>A</code> 中的元素 <code>A[i]</code>，以 <code>A[i]-min</code> 作为 <code>C</code> 数组的索引，以 <code>A[i]</code> 的值在 <code>A</code> 中元素出现次数作为 <code>C[A[i]-min]</code> 的值；</li><li>对 <code>C</code> 数组变形，<strong>新元素的值是该元素与前一个元素值的和</strong>，即当 <code>i&gt;1</code> 时 <code>C[i] = C[i] + C[i-1]</code>；</li><li>创建结果数组 <code>R</code>，长度和原始数组一样。</li><li><strong>从后向前</strong>遍历原始数组 <code>A</code> 中的元素 <code>A[i]</code>，使用 <code>A[i]</code> 减去最小值 <code>min</code> 作为索引，在计数数组 <code>C</code> 中找到对应的值 <code>C[A[i]-min]</code>，<code>C[A[i]-min]-1</code> 就是 <code>A[i]</code> 在结果数组 <code>R</code> 中的位置，做完上述这些操作，将 <code>count[A[i]-min]</code> 减小 1。</li></ol><p><img loading="lazy" src="https://guide-blog-./personal_images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/counting_sort.gif" class="img_ev3q"></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="代码实现-7">代码实现<a href="#代码实现-7" class="hash-link" aria-label="代码实现的直接链接" title="代码实现的直接链接">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Gets the maximum and minimum values in the array</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static int[] getMinAndMax(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxValue = arr[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int minValue = arr[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; arr.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (arr[i] &gt; maxValue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            maxValue = arr[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (arr[i] &lt; minValue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            minValue = arr[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new int[] { minValue, maxValue };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Counting Sort</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static int[] countingSort(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (arr.length &lt; 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] extremum = getMinAndMax(arr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int minValue = extremum[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxValue = extremum[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] countArr = new int[maxValue - minValue + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] result = new int[arr.length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; arr.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        countArr[arr[i] - minValue] += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt; countArr.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        countArr[i] += countArr[i - 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = arr.length - 1; i &gt;= 0; i--) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int idx = countArr[arr[i] - minValue] - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result[idx] = arr[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        countArr[arr[i] - minValue] -= 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法分析-7">算法分析<a href="#算法分析-7" class="hash-link" aria-label="算法分析的直接链接" title="算法分析的直接链接">​</a></h6><p>当输入的元素是 <code>n</code> 个 <code>0</code> 到 <code>k</code> 之间的整数时，它的运行时间是 <code>O(n+k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 <code>C</code> 的长度取决于待排序数组中数据的范围（等于待排序数组的<strong>最大值与最小值的差加上 1</strong>），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。</p><ul><li><strong>稳定性</strong> ：稳定</li><li><strong>时间复杂度</strong> ：最佳：<code>O(n+k)</code> 最差：<code>O(n+k)</code> 平均：<code>O(n+k)</code></li><li><strong>空间复杂度</strong> ：<code>O(k)</code></li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="桶排序-bucket-sort">桶排序 (Bucket Sort)<a href="#桶排序-bucket-sort" class="hash-link" aria-label="桶排序 (Bucket Sort)的直接链接" title="桶排序 (Bucket Sort)的直接链接">​</a></h5><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行。</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法步骤-8">算法步骤<a href="#算法步骤-8" class="hash-link" aria-label="算法步骤的直接链接" title="算法步骤的直接链接">​</a></h6><ol><li>设置一个 BucketSize，作为每个桶所能放置多少个不同数值；</li><li>遍历输入数据，并且把数据依次映射到对应的桶里去；</li><li>对每个非空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从非空桶里把排好序的数据拼接起来。</li></ol><p><img loading="lazy" src="https://guide-blog-./personal_images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/bucket_sort.gif" class="img_ev3q"></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="代码实现-8">代码实现<a href="#代码实现-8" class="hash-link" aria-label="代码实现的直接链接" title="代码实现的直接链接">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Gets the maximum and minimum values in the array</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static int[] getMinAndMax(List&lt;Integer&gt; arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxValue = arr.get(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int minValue = arr.get(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i : arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (i &gt; maxValue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            maxValue = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (i &lt; minValue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            minValue = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new int[] { minValue, maxValue };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Bucket Sort</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static List&lt;Integer&gt; bucketSort(List&lt;Integer&gt; arr, int bucket_size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (arr.size() &lt; 2 || bucket_size == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] extremum = getMinAndMax(arr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int minValue = extremum[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxValue = extremum[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int bucket_cnt = (maxValue - minValue) / bucket_size + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; bucket_cnt; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        buckets.add(new ArrayList&lt;Integer&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int element : arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int idx = (element - minValue) / bucket_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        buckets.get(idx).add(element);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; buckets.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (buckets.get(i).size() &gt; 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            buckets.set(i, sort(buckets.get(i), bucket_size / 2));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (List&lt;Integer&gt; bucket : buckets) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int element : bucket) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.add(element);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法分析-8">算法分析<a href="#算法分析-8" class="hash-link" aria-label="算法分析的直接链接" title="算法分析的直接链接">​</a></h6><ul><li><strong>稳定性</strong> ：稳定</li><li><strong>时间复杂度</strong> ：最佳：<code>O(n+k)</code> 最差：<code>O(n²)</code> 平均：<code>O(n+k)</code></li><li><strong>空间复杂度</strong> ：<code>O(k)</code></li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="基数排序-radix-sort">基数排序 (Radix Sort)<a href="#基数排序-radix-sort" class="hash-link" aria-label="基数排序 (Radix Sort)的直接链接" title="基数排序 (Radix Sort)的直接链接">​</a></h5><p>基数排序也是非比较的排序算法，对元素中的每一位数字进行排序，从最低位开始排序，复杂度为 <code>O(n×k)</code>，<code>n</code> 为数组长度，<code>k</code> 为数组中元素的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法步骤-9">算法步骤<a href="#算法步骤-9" class="hash-link" aria-label="算法步骤的直接链接" title="算法步骤的直接链接">​</a></h6><ol><li>取得数组中的最大数，并取得位数，即为迭代次数 <code>N</code>（例如：数组中最大数值为 1000，则 <code>N=4</code>）；</li><li><code>A</code> 为原始数组，从最低位开始取每个位组成 <code>radix</code> 数组；</li><li>对 <code>radix</code> 进行计数排序（利用计数排序适用于小范围数的特点）；</li><li>将 <code>radix</code> 依次赋值给原数组；</li><li>重复 2~4 步骤 <code>N</code> 次</li></ol><p><img loading="lazy" src="https://guide-blog-./personal_images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/radix_sort.gif" class="img_ev3q"></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="代码实现-9">代码实现<a href="#代码实现-9" class="hash-link" aria-label="代码实现的直接链接" title="代码实现的直接链接">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Radix Sort</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param arr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static int[] radixSort(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (arr.length &lt; 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int N = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxValue = arr[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int element : arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (element &gt; maxValue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            maxValue = element;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (maxValue / 10 != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        maxValue = maxValue / 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        N += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; N; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;List&lt;Integer&gt;&gt; radix = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int k = 0; k &lt; 10; k++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            radix.add(new ArrayList&lt;Integer&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int element : arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int idx = (element / (int) Math.pow(10, i)) % 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            radix.get(idx).add(element);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int idx = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (List&lt;Integer&gt; l : radix) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int n : l) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                arr[idx++] = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="算法分析-9">算法分析<a href="#算法分析-9" class="hash-link" aria-label="算法分析的直接链接" title="算法分析的直接链接">​</a></h6><ul><li><strong>稳定性</strong> ：稳定</li><li><strong>时间复杂度</strong> ：最佳：<code>O(n×k)</code> 最差：<code>O(n×k)</code> 平均：<code>O(n×k)</code></li><li><strong>空间复杂度</strong> ：<code>O(n+k)</code></li></ul><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/zhiyu1998/Computer-Science-Learn-Notes/edit/master/docs/Java/eightpart/datastruct.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/system"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">system</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intelligenceQuestion"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">intelligenceQuestion</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#数据结构" class="table-of-contents__link toc-highlight">🧩数据结构</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/Computer-Science-Learn-Notes/docs/intro">主页</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="#" class="footer__link-item">莫得</a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/zhiyu1998" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Computer Science Learn Notes, Inc. Built with Zhiyu1998.</div></div></div></footer></div>
<script src="/Computer-Science-Learn-Notes/assets/js/runtime~main.978cdf48.js"></script>
<script src="/Computer-Science-Learn-Notes/assets/js/main.7c330b06.js"></script>
</body>
</html>