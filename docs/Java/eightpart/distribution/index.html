<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Java/eightpart/distribution">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">distribution | Computer Science Learn Notes</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/distribution"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="distribution | Computer Science Learn Notes"><meta data-rh="true" name="description" content="🔗 分布式"><meta data-rh="true" property="og:description" content="🔗 分布式"><link data-rh="true" rel="icon" href="/Computer-Science-Learn-Notes/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/distribution"><link data-rh="true" rel="alternate" href="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/distribution" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/distribution" hreflang="x-default"><link rel="stylesheet" href="/Computer-Science-Learn-Notes/assets/css/styles.e7823470.css">
<link rel="preload" href="/Computer-Science-Learn-Notes/assets/js/runtime~main.978cdf48.js" as="script">
<link rel="preload" href="/Computer-Science-Learn-Notes/assets/js/main.7c330b06.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Computer-Science-Learn-Notes/"><div class="navbar__logo"><img src="/Computer-Science-Learn-Notes/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/Computer-Science-Learn-Notes/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Computer Science Learn Notes</b></a><a class="navbar__item navbar__link" href="/Computer-Science-Learn-Notes/docs/intro">主页</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/zhiyu1998/Computer-Science-Learn-Notes" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="搜索" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div><div class="searchHintContainer_Pkmr"><kbd class="searchHint_iIMx">ctrl</kbd><kbd class="searchHint_iIMx">K</kbd></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/Computer-Science-Learn-Notes/docs/golang/learnInProblem">目录</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/golang/learnInProblem">Go语言</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/frontend/react/">前端</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/fundamental/datastruct">基础知识</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/basic/">Java基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/giant">Java面试</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/giant">2022大厂面试题</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intro">常见面试题精选</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intro">前言</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/foundation">Java基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/concurrency">Java并发</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/virtualMachine">JVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/spring">Spring系列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/mysql">MySQL</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/redis">Redis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/distribution">分布式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/messageQueue">消息队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/netty">Netty</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/network">计算机网络</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/system">操作系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/datastruct">数据结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intelligenceQuestion">智力题</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/think">基于面试题的一些思考</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/leetcode/">力扣刷题顺序</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/leetcode/src/剑指offer/数组中重复的数字">刷题汇总</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/others/personal_tech">其他分享</a></div></li></ul></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/Computer-Science-Learn-Notes/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">目录</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Java面试</span><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">常见面试题精选</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">分布式</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>distribution</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="-分布式">🔗 分布式<a href="#-分布式" class="hash-link" aria-label="🔗 分布式的直接链接" title="🔗 分布式的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="理论基础">理论基础<a href="#理论基础" class="hash-link" aria-label="理论基础的直接链接" title="理论基础的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="cap理论">CAP理论<a href="#cap理论" class="hash-link" aria-label="CAP理论的直接链接" title="CAP理论的直接链接">​</a></h4><p>CAP 理论/定理起源于 2000年，由加州大学伯克利分校的Eric Brewer教授在分布式计算原理研讨会（PODC）上提出，因此 CAP定理又被称作 <strong>布鲁尔定理（Brewer’s theorem）</strong></p><p>2年后，麻省理工学院的Seth Gilbert和Nancy Lynch 发表了布鲁尔猜想的证明，CAP理论正式成为分布式领域的定理。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="简介">简介<a href="#简介" class="hash-link" aria-label="简介的直接链接" title="简介的直接链接">​</a></h5><p><strong>CAP</strong> 也就是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong> 这三个单词首字母组合。</p><p><img loading="lazy" alt="image-20220726125103940" src="/Computer-Science-Learn-Notes/assets/images/image-20220726125103940-a7c4dbcad2e8a2663444509f214b69cb.png" width="650" height="366" class="img_ev3q"></p><p>CAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 <strong>Consistency</strong>、<strong>Availability</strong>、<strong>Partition Tolerance</strong> 三个单词的明确定义。</p><p>因此，对于 CAP 的民间解读有很多，一般比较被大家推荐的是下面 👇 这种版本的解读。</p><p>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p><ul><li><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本</li><li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li><li><strong>分区容错性（Partition tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="网络分区">网络分区<a href="#网络分区" class="hash-link" aria-label="网络分区的直接链接" title="网络分区的直接链接">​</a></h5><blockquote><p>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。</p></blockquote><p><img loading="lazy" alt="image-20220726132654526" src="/Computer-Science-Learn-Notes/assets/images/image-20220726132654526-8320a0a7759dfbd44da2d2a39a455545.png" width="761" height="200" class="img_ev3q"></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="不是所谓的3-选-2">不是所谓的“3 选 2”<a href="#不是所谓的3-选-2" class="hash-link" aria-label="不是所谓的“3 选 2”的直接链接" title="不是所谓的“3 选 2”的直接链接">​</a></h5><p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。</p><blockquote><p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p><p>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p></blockquote><p>因此，<strong>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</strong> 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p><p><strong>为啥不可能选择 CA 架构呢？</strong> 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p><p><strong>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</strong></p><p>另外，需要补充说明的一点是： <strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</strong></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="cap-实际应用案例">CAP 实际应用案例<a href="#cap-实际应用案例" class="hash-link" aria-label="CAP 实际应用案例的直接链接" title="CAP 实际应用案例的直接链接">​</a></h5><p>我这里以注册中心来探讨一下 CAP 的实际应用。考虑到很多小伙伴不知道注册中心是干嘛的，这里简单以 Dubbo 为例说一说。</p><p>下图是 Dubbo 的架构图。<strong>注册中心 Registry 在其中扮演了什么角色呢？提供了什么服务呢？</strong></p><p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。</p><p><img loading="lazy" alt="image-20220726132721865" src="/Computer-Science-Learn-Notes/assets/images/image-20220726132721865-a49d9e18510c48069e4db9c1fa9c863c.png" width="650" height="505" class="img_ev3q"></p><p>常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos...。</p><ol><li><strong>ZooKeeper 保证的是 CP。</strong> 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</li><li><strong>Eureka 保证的则是 AP。</strong> Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此  Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka  保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。</li><li><strong>Nacos 不仅支持 CP 也支持 AP。</strong></li></ol><h4 class="anchor anchorWithStickyNavbar_LWe7" id="base理论">Base理论<a href="#base理论" class="hash-link" aria-label="Base理论的直接链接" title="Base理论的直接链接">​</a></h4><p><a href="https://dl.acm.org/doi/10.1145/1394127.1394128" target="_blank" rel="noopener noreferrer">BASE 理论</a>起源于 2008 年， 由eBay的架构师Dan Pritchett在ACM上发表。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="简介-1">简介<a href="#简介-1" class="hash-link" aria-label="简介的直接链接" title="简介的直接链接">​</a></h5><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="base-理论的核心思想">BASE 理论的核心思想<a href="#base-理论的核心思想" class="hash-link" aria-label="BASE 理论的核心思想的直接链接" title="BASE 理论的核心思想的直接链接">​</a></h5><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><blockquote><p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p></blockquote><p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</strong></p><p><strong>为什么这样说呢？</strong></p><p>CAP 理论这节我们也说过了：</p><blockquote><p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p></blockquote><p>因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="base-理论三要素">BASE 理论三要素<a href="#base-理论三要素" class="hash-link" aria-label="BASE 理论三要素的直接链接" title="BASE 理论三要素的直接链接">​</a></h5><p><img loading="lazy" alt="image-20220726133418075" src="/Computer-Science-Learn-Notes/assets/images/image-20220726133418075-dd5bd85362020961f36aa0c1575bc903.png" width="612" height="461" class="img_ev3q"></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="基本可用">基本可用<a href="#基本可用" class="hash-link" aria-label="基本可用的直接链接" title="基本可用的直接链接">​</a></h5><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p><p><strong>什么叫允许损失部分可用性呢？</strong></p><ul><li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li><li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="软状态">软状态<a href="#软状态" class="hash-link" aria-label="软状态的直接链接" title="软状态的直接链接">​</a></h5><p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="最终一致性">最终一致性<a href="#最终一致性" class="hash-link" aria-label="最终一致性的直接链接" title="最终一致性的直接链接">​</a></h5><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><blockquote><p>分布式一致性的 3 种级别：</p><ol><li><strong>强一致性</strong> ：系统写入了什么，读出来的就是什么。</li><li><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li><li><strong>最终一致性</strong> ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li></ol><p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p></blockquote><p>那实现最终一致性的具体方式是什么呢? <a href="http://gk.link/a/10rZM" target="_blank" rel="noopener noreferrer">《分布式协议与算法实战》</a>中是这样介绍：</p><blockquote><ul><li><strong>读时修复</strong> : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点 的副本数据不一致，系统就自动修复数据。</li><li><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。</li><li><strong>异步修复</strong> : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li></ul></blockquote><p>比较推荐 <strong>写时修复</strong>，这种方式对性能消耗比较低。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="paxos-算法">Paxos 算法<a href="#paxos-算法" class="hash-link" aria-label="Paxos 算法的直接链接" title="Paxos 算法的直接链接">​</a></h4><p>Paxos 算法是 Leslie Lamport（<a href="https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%96%AF%E5%88%A9%C2%B7%E5%85%B0%E4%BC%AF%E7%89%B9" target="_blank" rel="noopener noreferrer">莱斯利·兰伯特</a>）在 <strong>1990</strong> 年提出了一种分布式系统 <strong>共识</strong> 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。</p><p>为了介绍 Paxos 算法，兰伯特专门写了一篇幽默风趣的论文。在这篇论文中，他虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos 算法。</p><p>不过，审稿人并不认可这篇论文的幽默。于是，他们就给兰伯特说：“如果你想要成功发表这篇论文的话，必须删除所有 Paxos 相关的故事背景”。兰伯特一听就不开心了：“我凭什么修改啊，你们这些审稿人就是缺乏幽默细胞，发不了就不发了呗！”。</p><p>于是乎，提出 Paxos 算法的那篇论文在当时并没有被成功发表。</p><p>直到 1998 年，系统研究中心 (Systems Research  Center，SRC）的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统，Paxos  算法刚好可以解决他们的部分需求。因此，兰伯特就把论文发给了他们。在看了论文之后，这俩大佬觉得论文还是挺不错的。于是，兰伯特在 <strong>1998</strong> 年重新发表论文 <a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf" target="_blank" rel="noopener noreferrer">《The Part-Time Parliament》</a>。</p><p>论文发表之后，各路学者直呼看不懂，言语中还略显调侃之意。这谁忍得了，在 <strong>2001</strong> 年的时候，兰伯特专门又写了一篇 <a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf" target="_blank" rel="noopener noreferrer">《Paxos Made Simple》</a>的论文来简化对 Paxos 的介绍，主要讲述两阶段共识协议部分，顺便还不忘嘲讽一下这群学者。</p><p>《Paxos Made Simple》这篇论文就 14 页，相比于 《The Part-Time Parliament》的33 页精简了不少。最关键的是这篇论文的摘要就一句话：</p><blockquote><p>The Paxos algorithm, when presented in plain English, is very simple.</p></blockquote><p>翻译过来的意思大概就是：当我用无修饰的英文来描述时，Paxos 算法真心简单！</p><p>有没有感觉到来自兰伯特大佬满满地嘲讽的味道？</p><p>兰伯特当时提出的 Paxos 算法主要包含 2 个部分:</p><ul><li><strong>Basic Paxos 算法</strong> ： 描述的是多节点之间如何就某个值(提案 Value)达成共识。</li><li><strong>Multi-Paxos 思想</strong> ： 描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。Multi-Paxos 说白了就是执行多次 Basic Paxos ，核心还是 Basic Paxos 。</li></ul><p>由于 Paxos 算法在国际上被公认的非常难以理解和实现，因此不断有人尝试简化这一算法。到了2013 年才诞生了一个比 Paxos 算法更易理解和实现的共识算法—<a href="https://javaguide.cn/distributed-system/theorem&amp;algorithm&amp;protocol/raft-algorithm.html" target="_blank" rel="noopener noreferrer">Raft 算法</a> 。更具体点来说，Raft 是Multi-Paxos的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现。</p><p>针对没有恶意节点的情况，除了 Raft 算法之外，当前最常用的一些共识算法比如 ZAB 协议、 Fast Paxos 算法都是基于 Paxos 算法改进的。</p><p>针对存在恶意节点的情况，一般使用的是工作量证明（POW，Proof-of-Work）、权益证明（PoS，Proof-of-Stake ）等共识算法。这类共识算法最典型的应用就是区块链，就比如说前段时间以太坊官方宣布其共识机制正在从工作量证明(PoW)转变为权益证明(PoS)。</p><p>区块链系统使用的共识算法需要解决的核心问题是 <strong>拜占庭将军问题</strong> ，这和我们日常接触到的 ZooKeeper、Etcd、Consul 等分布式中间件不太一样。</p><p>下面我们来对 Paxos 算法的定义做一个总结：</p><ul><li>Paxos 算法是兰伯特在 <strong>1990</strong> 年提出了一种分布式系统共识算法。</li><li>兰伯特当时提出的 Paxos 算法主要包含 2 个部分:Basic Paxos 算法和Multi-Paxos 思想。</li><li>Raft 算法、ZAB 协议、 Fast Paxos 算法都是基于 Paxos 算法改进而来。</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="一致性consistency与共识consensus">一致性（Consistency）与共识（Consensus）<a href="#一致性consistency与共识consensus" class="hash-link" aria-label="一致性（Consistency）与共识（Consensus）的直接链接" title="一致性（Consistency）与共识（Consensus）的直接链接">​</a></h5><p>很多人会误把 Paxos 看作是一致性算法，这其实是一个非常大的误区。</p><p>⚠️注意：<strong>Paxos 不是一致性算法而是共识算法，一致性和共识并不是一个概念。</strong></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="basic-paxos-算法">Basic Paxos 算法<a href="#basic-paxos-算法" class="hash-link" aria-label="Basic Paxos 算法的直接链接" title="Basic Paxos 算法的直接链接">​</a></h5><p>Basic Paxos 中存在 3 个重要的角色：</p><ol><li><strong>提议者（Proposer）</strong>：也可以叫做协调者（coordinator），提议者负责接受客户端发起的提议，然后尝试让接受者接受该提议，同时保证即使多个提议者的提议之间产生了冲突，那么算法都能进行下去；</li><li><strong>接受者（Acceptor）</strong>：也可以叫做投票员（voter），负责对提议者的提议投票，同时需要记住自己的投票历史；</li><li><strong>学习者（Learner）</strong>：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。</li></ol><p><img loading="lazy" alt="image-20220726133642419" src="/Computer-Science-Learn-Notes/assets/images/image-20220726133642419-c9c45207559db8b99a481634eaa73bc8.png" width="1024" height="768" class="img_ev3q"></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="multi-paxos-思想">Multi Paxos 思想<a href="#multi-paxos-思想" class="hash-link" aria-label="Multi Paxos 思想的直接链接" title="Multi Paxos 思想的直接链接">​</a></h5><p>因为兰伯特提到的 Multi-Paxos 思想，缺少代码实现的必要细节(比如怎么选举领导者)，所以在理解上比较难。</p><p>⚠️<strong>注意</strong> ： Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。</p><p>二阶段提交是达成共识常用的方式，Basic Paxos 就是通过二阶段提交的方式来达成共识。Basic Paxos 还支持容错，少于一般的节点出现故障时，集群也能正常工作。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="raft-算法">Raft 算法<a href="#raft-算法" class="hash-link" aria-label="Raft 算法的直接链接" title="Raft 算法的直接链接">​</a></h4><p>当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。</p><p>因此，系统必须在正常操作期间处理服务器的上下线。它们必须对变故做出反应并在几秒钟内自动适应；对客户来说的话，明显的中断通常是不可接受的。</p><p>幸运的是，分布式共识可以帮助应对这些挑战。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="拜占庭将军">拜占庭将军<a href="#拜占庭将军" class="hash-link" aria-label="拜占庭将军的直接链接" title="拜占庭将军的直接链接">​</a></h5><p>在介绍共识算法之前，先介绍一个简化版拜占庭将军的例子来帮助理解共识算法。</p><blockquote><p>假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？</p></blockquote><p>解决方案大致可以理解成：先在所有的将军中选出一个大将军，用来做出所有的决定。</p><p>举例如下：假如现在一共有 3 个将军 A，B 和  C，每个将军都有一个随机时间的倒计时器，倒计时一结束，这个将军就把自己当成大将军候选人，然后派信使传递选举投票的信息给将军 B 和 C，如果将军 B 和 C 还没有把自己当作候选人（自己的倒计时还没有结束），并且没有把选举票投给其他人，它们就会把票投给将军 A，信使回到将军 A 时，将军 A 知道自己收到了足够的票数，成为大将军。在有了大将军之后，是否需要进攻就由大将军 A  决定，然后再去派信使通知另外两个将军，自己已经成为了大将军。如果一段时间还没收到将军 B 和 C  的回复（信使可能会被暗杀），那就再重派一个信使，直到收到回复。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="共识算法">共识算法<a href="#共识算法" class="hash-link" aria-label="共识算法的直接链接" title="共识算法的直接链接">​</a></h5><p>共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。</p><p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组<code>Server</code>的状态机计算相同状态的副本，即使有一部分的<code>Server</code>宕机了它们仍然能够继续运行。</p><p><img loading="lazy" alt="image-20220726134912102" src="/Computer-Science-Learn-Notes/assets/images/image-20220726134912102-411b480f818acc353756ca81ab6c6b18.png" width="1102" height="652" class="img_ev3q"></p><p>一般通过使用复制日志来实现复制状态机。每个<code>Server</code>存储着一份包括命令序列的日志文件，状态机会按顺序执行这些命令。因为每个日志包含相同的命令，并且顺序也相同，所以每个状态机处理相同的命令序列。由于状态机是确定性的，所以处理相同的状态，得到相同的输出。</p><p>因此共识算法的工作就是保持复制日志的一致性。服务器上的共识模块从客户端接收命令并将它们添加到日志中。它与其他服务器上的共识模块通信，以确保即使某些服务器发生故障。每个日志最终包含相同顺序的请求。一旦命令被正确地复制，它们就被称为已提交。每个服务器的状态机按照日志顺序处理已提交的命令，并将输出返回给客户端，因此，这些服务器形成了一个单一的、高度可靠的状态机。</p><p>适用于实际系统的共识算法通常具有以下特性：</p><ul><li>安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。</li><li>高可用。只要大多数服务器都是可操作的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入集群。</li><li>一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。</li><li>在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="节点类型">节点类型<a href="#节点类型" class="hash-link" aria-label="节点类型的直接链接" title="节点类型的直接链接">​</a></h5><p>一个 Raft 集群包括若干服务器，以典型的 5 服务器集群举例。在任意的时间，每个服务器一定会处于以下三个状态中的一个：</p><ul><li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li><li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li><li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</li></ul><p>在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。</p><p><img loading="lazy" alt="image-20220726134943719" src="/Computer-Science-Learn-Notes/assets/images/image-20220726134943719-626ce8961d04ca6aedcd87001114caf6.png" width="704" height="304" class="img_ev3q"></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="任期">任期<a href="#任期" class="hash-link" aria-label="任期的直接链接" title="任期的直接链接">​</a></h5><p><img loading="lazy" alt="image-20220726134951395" src="/Computer-Science-Learn-Notes/assets/images/image-20220726134951395-13f8c832514100e8d74d43314d993c8f.png" width="576" height="236" class="img_ev3q"></p><p>如图 3 所示，raft 算法将时间划分为任意长度的任期（term），任期用连续的数字表示，看作当前 term  号。每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。如果一个 Candidate  赢得了选举，它就会在该任期内担任 Leader。如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。raft  算法保证在给定的一个任期最少要有一个 Leader。</p><p>每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的  term 号；如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。如果一个 Candidate 或者  Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term  号是过期的，那么它会拒绝此次请求。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="日志">日志<a href="#日志" class="hash-link" aria-label="日志的直接链接" title="日志的直接链接">​</a></h5><ul><li><code>entry</code>：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为<code>&lt;term,index,cmd&gt;</code>其中 cmd 是可以应用到状态机的操作。</li><li><code>log</code>：由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的  log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader  提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry  应用到自己的状态机中。</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="领导人选举">领导人选举<a href="#领导人选举" class="hash-link" aria-label="领导人选举的直接链接" title="领导人选举的直接链接">​</a></h5><p>raft 使用心跳机制来触发 Leader 的选举。</p><p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。</p><p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower  在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。</p><p>为了开始新的选举，Follower 会自增自己的 term 号并且转换状态为 Candidate。然后他会向所有节点发起 RequestVoteRPC 请求， Candidate 的状态会持续到以下情况发生：</p><ul><li>赢得选举</li><li>其他节点赢得选举</li><li>一轮选举结束，无人胜出</li></ul><p>赢得选举的条件是：一个 Candidate 在一个任期内收到了来自集群内的多数选票<code>（N/2+1）</code>，就可以成为 Leader。</p><p>在 Candidate 等待选票的时候，它可能收到其他节点声明自己是 Leader 的心跳，此时有两种情况：</p><ul><li>该 Leader 的 term 号大于等于自己的 term 号，说明对方已经成为 Leader，则自己回退为 Follower。</li><li>该 Leader 的 term 号小于自己的 term 号，那么会拒绝该请求并让该节点更新 term。</li></ul><p>由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票，如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。</p><p>raft 使用了随机的选举超时时间来避免上述情况。每一个 Candidate 在发起选举后，都会随机化一个新的枚举超时时间，这种机制使得各个服务器能够分散开来，在大多数情况下只有一个服务器会率先超时；它会在其他服务器超时之前赢得选举。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="日志复制">日志复制<a href="#日志复制" class="hash-link" aria-label="日志复制的直接链接" title="日志复制的直接链接">​</a></h5><p>一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（<code>Replicated State Mechine</code>）执行的命令。</p><p>Leader 收到客户端请求后，会生成一个 entry，包含<code>&lt;index,term,cmd&gt;</code>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。</p><p>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。</p><p>如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以成为这个 entry 是 committed 的，并且向客户端返回执行结果。</p><p>raft 保证以下两个性质：</p><ul><li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</li><li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</li></ul><p>通过“仅有 Leader 可以生存 entry”来保证第一个性质，第二个性质需要一致性检查来进行保证。</p><p>一般情况下，Leader 和 Follower 的日志保持一致，然后，Leader 的崩溃会导致日志不一样，这样一致性检查会产生失败。Leader 通过强制  Follower 复制自己的日志来处理日志的不一致。这就意味着，在 Follower 上的冲突日志会被领导者的日志覆盖。</p><p>为了使得 Follower 的日志和自己的日志一致，Leader 需要找到 Follower 与它日志一致的地方，然后删除 Follower 在该位置之后的日志，接着把这之后的日志发送给 Follower。</p><p><code>Leader</code> 给每一个<code>Follower</code> 维护了一个 <code>nextIndex</code>，它表示 <code>Leader</code> 将要发送给该追随者的下一条日志条目的索引。当一个 <code>Leader</code> 开始掌权时，它会将 <code>nextIndex</code> 初始化为它的最新的日志条目索引数+1。如果一个 <code>Follower</code> 的日志和 <code>Leader</code> 的不一致，<code>AppendEntries</code> 一致性检查会在下一次 <code>AppendEntries RPC</code> 时返回失败。在失败之后，<code>Leader</code> 会将 <code>nextIndex</code> 递减然后重试 <code>AppendEntries RPC</code>。最终 <code>nextIndex</code> 会达到一个 <code>Leader</code> 和 <code>Follower</code> 日志一致的地方。这时，<code>AppendEntries</code> 会返回成功，<code>Follower</code> 中冲突的日志条目都被移除了，并且添加所缺少的上了 <code>Leader</code> 的日志条目。一旦 <code>AppendEntries</code> 返回成功，<code>Follower</code> 和 <code>Leader</code> 的日志就一致了，这样的状态会保持到该任期结束。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="选举限制">选举限制<a href="#选举限制" class="hash-link" aria-label="选举限制的直接链接" title="选举限制的直接链接">​</a></h5><p>Leader 需要保证自己存储全部已经提交的日志条目。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。</p><p>每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，如果发现自己的更新，则拒绝投票给该 Candidate。</p><p>判断日志新旧的方式：如果两个日志的 term 不同，term 大的更新；如果 term 相同，更长的 index 更新。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="节点崩溃">节点崩溃<a href="#节点崩溃" class="hash-link" aria-label="节点崩溃的直接链接" title="节点崩溃的直接链接">​</a></h5><p>如果 Leader 崩溃，集群中的节点在 electionTimeout 时间内没有收到 Leader 的心跳信息就会触发新一轮的选主，在选主期间整个集群对外是不可用的。</p><p>如果 Follower 和 Candidate 崩溃，处理方式会简单很多。之后发送给它的 RequestVoteRPC 和  AppendEntriesRPC 会失败。由于 raft  的所有请求都是幂等的，所以失败的话会无限的重试。如果崩溃恢复后，就可以收到新的请求，然后选择追加或者拒绝 entry。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="时间与可用性">时间与可用性<a href="#时间与可用性" class="hash-link" aria-label="时间与可用性的直接链接" title="时间与可用性的直接链接">​</a></h5><p>raft 的要求之一就是安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误。为了保证上述要求，最好能满足以下的时间条件：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li><code>broadcastTime</code>：向其他节点并发发送消息的平均响应时间；</li><li><code>electionTimeout</code>：选举超时时间；</li><li><code>MTBF(mean time between failures)</code>：单台机器的平均健康时间；</li></ul><p><code>broadcastTime</code>应该比<code>electionTimeout</code>小一个数量级，为的是使<code>Leader</code>能够持续发送心跳信息（heartbeat）来阻止<code>Follower</code>开始选举；</p><p><code>electionTimeout</code>也要比<code>MTBF</code>小几个数量级，为的是使得系统稳定运行。当<code>Leader</code>崩溃时，大约会在整个<code>electionTimeout</code>的时间内不可用；我们希望这种情况仅占全部时间的很小一部分。</p><p>由于<code>broadcastTime</code>和<code>MTBF</code>是由系统决定的属性，因此需要决定<code>electionTimeout</code>的时间。</p><p>一般来说，broadcastTime 一般为 <code>0.5～20ms</code>，electionTimeout 可以设置为 <code>10～500ms</code>，MTBF 一般为一两个月。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="了解rpc吗">了解RPC吗？<a href="#了解rpc吗" class="hash-link" aria-label="了解RPC吗？的直接链接" title="了解RPC吗？的直接链接">​</a></h3><p>一言蔽之：<strong>RPC （Remote Procedure Call）的出现就是为了让你调用远程方法像调用本地方法一样简单。</strong></p><p>为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC的 核心功能看作是下面👇 6 个部分实现的：</p><ol><li><strong>客户端（服务消费端）</strong> ：调用远程方法的一端。</li><li><strong>客户端 Stub（桩）</strong> ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li><li><strong>网络传输</strong> ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。</li><li><strong>服务端 Stub（桩）</strong> ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</li><li><strong>服务端（服务提供端）</strong> ：提供远程方法的一端。</li></ol><p>具体原理图如下，后面我会串起来将整个RPC的过程给大家说一下。</p><p><img loading="lazy" alt="image-20220609151233412" src="/Computer-Science-Learn-Notes/assets/images/image-20220609151233412-3e1c6f2f2f63e63e023255c08e8aeead.png" width="499" height="317" class="img_ev3q"></p><ol><li>服务消费端（client）以本地调用的方式调用远程服务；</li><li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li><li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li><li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: <code>RpcRequest</code>；</li><li>服务端 Stub（桩）根据 <code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li><li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li><li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:<code>RpcResponse</code> ，这样也就得到了最终结果。over!</li></ol><p>相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。</p><p>虽然篇幅不多，但是基本把 RPC 框架的核心原理讲清楚了！另外，对于上面的技术细节，我会在后面的章节介绍到。</p><p><strong>最后，对于 RPC 的原理，希望小伙伴不单单要理解，还要能够自己画出来并且能够给别人讲出来。因为，在面试中这个问题在面试官问到 RPC 相关内容的时候基本都会碰到。</strong></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="有哪些常见的-rpc-框架">有哪些常见的 RPC 框架？<a href="#有哪些常见的-rpc-框架" class="hash-link" aria-label="有哪些常见的 RPC 框架？的直接链接" title="有哪些常见的 RPC 框架？的直接链接">​</a></h3><p>我们这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如我下面介绍的  Dubbo、Motan、gRPC这些。 如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC  框架”，比如Feign</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="dubbo">Dubbo<a href="#dubbo" class="hash-link" aria-label="Dubbo的直接链接" title="Dubbo的直接链接">​</a></h4><p><img loading="lazy" alt="image-20220723235648648" src="/Computer-Science-Learn-Notes/assets/images/image-20220723235648648-885939f8b4890096be193aba814a1ff7.png" width="1154" height="469" class="img_ev3q"></p><p>Apache Dubbo 是一款微服务框架，为大规模微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案， 涵盖 Java、Golang 等多种语言 SDK 实现。</p><p>Dubbo 提供了从服务定义、服务发现、服务通信到流量管控等几乎所有的服务治理能力，支持 Triple 协议（基于 HTTP/2 之上定义的下一代 RPC 通信协议）、应用级服务发现、Dubbo Mesh （Dubbo3 赋予了很多云原生友好的新特性）等特性。</p><p><img loading="lazy" alt="image-20220723235657177" src="/Computer-Science-Learn-Notes/assets/images/image-20220723235657177-5d137d96f4ef907ffad7b6a370b5d0ed.png" width="1235" height="706" class="img_ev3q"></p><p>Dubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p><p>Dubbo 算的是比较优秀的国产开源项目了，它的源码也是非常值得学习和阅读的！</p><ul><li>Github ：<a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-dubbo</a></li><li>官网：<a href="https://dubbo.apache.org/zh/" target="_blank" rel="noopener noreferrer">https://dubbo.apache.org/zh/</a></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="motan">Motan<a href="#motan" class="hash-link" aria-label="Motan的直接链接" title="Motan的直接链接">​</a></h4><p>Motan 是新浪微博开源的一款 RPC 框架，据说在新浪微博正支撑着千亿次调用。不过笔者倒是很少看到有公司使用，而且网上的资料也比较少。</p><p>很多人喜欢拿 Motan 和 Dubbo 作比较，毕竟都是国内大公司开源的。笔者在查阅了很多资料，以及简单查看了其源码之后发现：<strong>Motan 更像是一个精简版的 Dubbo，可能是借鉴了 Dubbo 的思想，Motan 的设计更加精简，功能更加纯粹。</strong></p><p>不过，我不推荐你在实际项目中使用 Motan。如果你要是公司实际使用的话，还是推荐 Dubbo ，其社区活跃度以及生态都要好很多。</p><ul><li>从 Motan 看 RPC 框架设计：<a href="http://kriszhang.com/motan-rpc-impl/" target="_blank" rel="noopener noreferrer">http://kriszhang.com/motan-rpc-impl/</a></li><li>Motan 中文文档：<a href="https://github.com/weibocom/motan/wiki/zh_overview" target="_blank" rel="noopener noreferrer">https://github.com/weibocom/motan/wiki/zh_overview</a></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="grpc">gRPC<a href="#grpc" class="hash-link" aria-label="gRPC的直接链接" title="gRPC的直接链接">​</a></h4><p><img loading="lazy" alt="image-20220723235737977" src="/Computer-Science-Learn-Notes/assets/images/image-20220723235737977-f376aa2be7360016531d65d4b53df6a7.png" width="3538" height="1958" class="img_ev3q"></p><p>gRPC 是 Google 开源的一个高性能、通用的开源 RPC 框架。其由主要面向移动应用开发并基于 HTTP/2 协议标准而设计（支持双向流、消息头压缩等功能，更加节省带宽），基于 ProtoBuf 序列化协议开发，并且支持众多开发语言。</p><p><strong>何谓 ProtoBuf？</strong> <a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener noreferrer">ProtoBuf（ Protocol Buffer）</a></p><p> 是一种更加灵活、高效的数据格式，可用于通讯协议、数据存储等领域，基本支持所有主流编程语言且与平台无关。不过，通过 ProtoBuf 定义接口和数据类型还挺繁琐的，这是一个小问题。</p><p><img loading="lazy" alt="image-20220723235747598" src="/Computer-Science-Learn-Notes/assets/images/image-20220723235747598-180902b9af8d902cd0a8e6c7d232050f.png" width="837" height="506" class="img_ev3q"></p><p>不得不说，gRPC 的通信层的设计还是非常优秀的，<a href="https://dubbogo.github.io/" target="_blank" rel="noopener noreferrer">Dubbo-go 3.0</a></p><p> 的通信层改进主要借鉴了 gRPC。</p><p>不过，gRPC 的设计导致其几乎没有服务治理能力。如果你想要解决这个问题的话，就需要依赖其他组件比如腾讯的 PolarisMesh（北极星）了。</p><ul><li>Github：<a href="https://github.com/grpc/grpc" target="_blank" rel="noopener noreferrer">https://github.com/grpc/grpc</a></li><li>官网：<a href="https://grpc.io/" target="_blank" rel="noopener noreferrer">https://grpc.io/</a></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="thrift">Thrift<a href="#thrift" class="hash-link" aria-label="Thrift的直接链接" title="Thrift的直接链接">​</a></h4><p>Apache Thrift 是 Facebook 开源的跨语言的 RPC 通信框架，目前已经捐献给 Apache  基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于 thrift  研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p><p><code>Thrift</code>支持多种不同的<strong>编程语言</strong>，包括<code>C++</code>、<code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>等（相比于 gRPC 支持的语言更多 ）。</p><ul><li>官网：<a href="https://thrift.apache.org/" target="_blank" rel="noopener noreferrer">https://thrift.apache.org/</a></li><li>Thrift 简单介绍：<a href="https://www.jianshu.com/p/8f25d057a5a9" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/8f25d057a5a9</a></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h4><p>gRPC 和 Thrift 虽然支持跨语言的 RPC 调用，但是它们只提供了最基本的 RPC 框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。</p><p>Dubbo 不论是从功能完善程度、生态系统还是社区活跃度来说都是最优秀的。而且，Dubbo在国内有很多成功的案例比如当当网、滴滴等等，是一款经得起生产考验的成熟稳定的 RPC 框架。最重要的是你还能找到非常多的 Dubbo 参考资料，学习成本相对也较低。</p><p>下图展示了 Dubbo 的生态系统。</p><p><img loading="lazy" alt="image-20220723235849004" src="/Computer-Science-Learn-Notes/assets/images/image-20220723235849004-3e214c27e256aefe159251f6c125afc2.png" width="2296" height="1376" class="img_ev3q"></p><p>Dubbo 也是 Spring Cloud Alibaba 里面的一个组件。</p><p><img loading="lazy" alt="image-20220723235856647" src="/Computer-Science-Learn-Notes/assets/images/image-20220723235856647-2b29e32fcdcd29462ff627a33fa85520.png" width="2274" height="1062" class="img_ev3q"></p><p>但是，Dubbo 和 Motan 主要是给 Java 语言使用。虽然，Dubbo 和 Motan 目前也能兼容部分语言，但是不太推荐。如果需要跨多种语言调用的话，可以考虑使用 gRPC。</p><p>综上，如果是 Java 后端技术栈，并且你在纠结选择哪一种 RPC 框架的话，我推荐你考虑一下 Dubbo</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="了解分布式事务吗">了解分布式事务吗？<a href="#了解分布式事务吗" class="hash-link" aria-label="了解分布式事务吗？的直接链接" title="了解分布式事务吗？的直接链接">​</a></h3><p>我接触和了解到的分布式事务大概分为：</p><ul><li>2pc（两段式提交）</li><li>3pc（三段式提交）</li><li>TCC（Try、Confirm、Cancel）</li><li>最大努力通知</li><li>消息事务</li><li>本地消息表（ebay研发出的）</li><li>半消息/最终一致性（RocketMQ）</li></ul><p>这里我就介绍下最简单的<strong>2pc（两段式）</strong>，以及大家以后可能比较常用的<strong>半消息事务</strong>也就是<strong>最终一致性</strong>，目的是让大家理解下分布式事务里面<strong>消息中间件的作用</strong>，别的事务都大同小异，都有很多优点。</p><p>当然也都有<strong>种种弊端</strong>：</p><p>例如<strong>长时间锁定数据库资源</strong>，导致系统的<strong>响应不快</strong>，<strong>并发上不去</strong>。</p><p>网络抖动出现<strong>脑裂</strong>情况，导致事物参与者，不能很好地执行协调者的指令，导致<strong>数据不一致</strong>。</p><p><strong>单点故障</strong>：例如事物协调者，在某一时刻宕机，虽然可以通过选举机制产生新的Leader，但是这过程中，必然出现问题，而TCC，只有强悍的技术团队，才能支持开发，<strong>成本太高</strong>。</p><p>不多BB了，我们开始介绍这个两个事物吧。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="️2pc两段式提交">✔️2pc（两段式提交）<a href="#️2pc两段式提交" class="hash-link" aria-label="✔️2pc（两段式提交）的直接链接" title="✔️2pc（两段式提交）的直接链接">​</a></h4><p><img loading="lazy" alt="image-20220617144013552" src="/Computer-Science-Learn-Notes/assets/images/image-20220617144013552-d46dce70dfa342aad33871feed119a2f.png" width="780" height="683" class="img_ev3q"></p><p><strong>2pc（两段式提交）</strong>可以说是分布式事务的最开始的样子了，像极了<strong>媒婆</strong>，就是通过消息中间件协调多个系统，在两个系统操作事务的时候都锁定资源但是不提交事务，等两者都准备好了，告诉消息中间件，然后再分别提交事务。</p><p><strong>但是我不知道大家看到问题所在没有？</strong></p><p>是的你可能已经发现了，如果A系统事务提交成功了，但是B系统在提交的时候网络波动或者各种原因提交失败了，其实还是会失败的。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="️3pc">✔️3PC<a href="#️3pc" class="hash-link" aria-label="✔️3PC的直接链接" title="✔️3PC的直接链接">​</a></h4><p>3PC 的出现是为了解决 2PC 的一些问题，相比于 2PC 它在<strong>参与者中也引入了超时机制</strong>，并且<strong>新增了一个阶段</strong>使得参与者可以利用这一个阶段统一各自的状态。</p><p>让我们来详细看一下。</p><p>3PC 包含了三个阶段，分别是<strong>准备阶段、预提交阶段和提交阶段</strong>，对应的英文就是：<code>CanCommit、PreCommit 和 DoCommit</code>。</p><p>看起来是<strong>把 2PC 的提交阶段变成了预提交阶段和提交阶段</strong>，但是 3PC 的准备阶段协调者只是询问参与者的自身状况，比如你现在还好吗？负载重不重？这类的。</p><p>而预提交阶段就是和 2PC 的准备阶段一样，除了事务的提交该做的都做了。</p><p>提交阶段和 2PC 的一样，让我们来看一下图。</p><p><img loading="lazy" alt="image-20220725145659669" src="/Computer-Science-Learn-Notes/assets/images/image-20220725145659669-286496f9b2967ec5c1095785e1351489.png" width="1024" height="738" class="img_ev3q"></p><p>不管哪一个阶段有参与者返回失败都会宣布事务失败，这和 2PC 是一样的（当然到最后的提交阶段和 2PC 一样只要是提交请求就只能不断重试）。</p><p>我们先来看一下 3PC 的阶段变更有什么影响。</p><p>首先<strong>准备阶段的变更成不会直接执行事务</strong>，而是会先去询问此时的参与者是否有条件接这个事务，因此<strong>不会一来就干活直接锁资源</strong>，使得在某些资源不可用的情况下所有参与者都阻塞着。</p><p>而<strong>预提交阶段的引入起到了一个统一状态的作用</strong>，它像一道栅栏，表明在预提交阶段前所有参与者其实还未都回应，在预处理阶段表明所有参与者都已经回应了。</p><p>假如你是一位参与者，你知道自己进入了预提交状态那你就可以推断出来其他参与者也都进入了预提交状态。</p><p>但是多引入一个阶段也多一个交互，因此<strong>性能会差一些</strong>，而且<strong>绝大部分的情况下资源应该都是可用的</strong>，这样等于每次明知可用执行还得询问一次。</p><p>我们再来看下参与者超时能带来什么样的影响。</p><p>我们知道 2PC 是同步阻塞的，上面我们已经分析了协调者挂在了提交请求还未发出去的时候是最伤的，所有参与者都已经锁定资源并且阻塞等待着。</p><p>那么引入了超时机制，参与者就不会傻等了，<strong>如果是等待提交命令超时，那么参与者就会提交事务了</strong>，因为都到了这一阶段了大概率是提交的，<strong>如果是等待预提交命令超时，那该干啥就干啥了，反正本来啥也没干</strong>。</p><p>然而超时机制也会带来数据不一致的问题，比如在等待提交命令时候超时了，参与者默认执行的是提交事务操作，但是<strong>有可能执行的是回滚操作，这样一来数据就不一致了</strong>。</p><p>当然 3PC 协调者超时还是在的，具体不分析了和 2PC 是一样的。</p><p>从维基百科上看，3PC 的引入是为了解决提交阶段 2PC 协调者和某参与者都挂了之后新选举的协调者不知道当前应该提交还是回滚的问题。</p><p>新协调者来的时候发现有一个参与者处于预提交或者提交阶段，那么表明已经经过了所有参与者的确认了，所以此时执行的就是提交命令。</p><p>所以说 3PC 就是通过引入预提交阶段来使得参与者之间的状态得到统一，也就是留了一个阶段让大家同步一下。</p><p>但是这也只能让协调者知道该如果做，但不能保证这样做一定对，这其实和上面 2PC 分析一致，因为挂了的参与者到底有没有执行事务无法断定。</p><p>所以说 3PC 通过预提交阶段可以减少故障恢复时候的复杂性，但是不能保证数据一致，除非挂了的那个参与者恢复。</p><p>让我们总结一下， 3PC 相对于 2PC 做了一定的改进：引入了参与者超时机制，并且增加了预提交阶段使得故障恢复之后协调者的决策复杂度降低，但整体的交互过程更长了，性能有所下降，并且还是会存在数据不一致问题。</p><p>所以 2PC 和 3PC 都不能保证数据100%一致，因此一般都需要有定时扫描补偿机制。</p><p>我再说下 3PC 我没有找到具体的实现，所以我认为 3PC 只是纯的理论上的东西，而且可以看到相比于 2PC 它是做了一些努力但是效果甚微，所以只做了解即可。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="️tcc柔性补偿">✔️TCC柔性补偿<a href="#️tcc柔性补偿" class="hash-link" aria-label="✔️TCC柔性补偿的直接链接" title="✔️TCC柔性补偿的直接链接">​</a></h4><ol><li>启动事务（业务系统）</li><li>尝试调不同的服务（接口）</li><li>事务具体成功了还是失败了会告诉事务协调器</li><li>由事务协调器来调用confirm、cancel</li></ol><p><strong>2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务</strong>，就像我前面说的分布式事务不仅仅包括数据库的操作，还包括发送短信等，这时候 TCC 就派上用场了！</p><p>TCC 指的是<code>Try - Confirm - Cancel</code>。</p><ul><li>Try 指的是预留，即资源的预留和锁定，<strong>注意是预留</strong>。</li><li>Confirm 指的是确认操作，这一步其实就是真正的执行了。</li><li>Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了。</li></ul><p>其实从思想上看和 2PC 差不多，都是先试探性的执行，如果都可以那就真正的执行，如果不行就回滚。</p><p>比如说一个事务要执行A、B、C三个操作，那么先对三个操作执行预留动作。如果都预留成功了那么就执行确认操作，如果有一个预留失败那就都执行撤销动作。</p><p>我们来看下流程，TCC模型还有个事务管理者的角色，用来记录TCC全局事务状态并提交或者回滚事务。</p><p><img loading="lazy" alt="image-20220913115340867" src="/Computer-Science-Learn-Notes/assets/images/image-20220913115340867-19885b2af5a4c9210e2e5cd4d4e191e3.png" width="1356" height="653" class="img_ev3q"></p><p>可以看到流程还是很简单的，难点在于业务上的定义，对于每一个操作你都需要定义三个动作分别对应<code>Try - Confirm - Cancel</code>。</p><p>因此 <strong>TCC 对业务的侵入较大和业务紧耦合</strong>，需要根据特定的场景和业务逻辑来设计相应的操作。</p><p>还有一点要注意，撤销和确认操作的执行可能需要重试，因此还需要保证<strong>操作的幂等</strong>。</p><p>相对于 2PC、3PC ，TCC 适用的范围更大，但是开发量也更大，毕竟都在业务上实现，而且有时候你会发现这三个方法还真不好写。不过也因为是在业务上实现的，所以<strong>TCC可以跨数据库、跨不同的业务系统来实现事务</strong>。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="了解最大努力通知">（了解）最大努力通知<a href="#了解最大努力通知" class="hash-link" aria-label="（了解）最大努力通知的直接链接" title="（了解）最大努力通知的直接链接">​</a></h4><p>其实我觉得本地消息表也可以算最大努力，事务消息也可以算最大努力。</p><p>就本地消息表来说会有后台任务定时去查看未完成的消息，然后去调用对应的服务，当一个消息多次调用都失败的时候可以记录下然后引入人工，或者直接舍弃。这其实算是最大努力了。</p><p>事务消息也是一样，当半消息被commit了之后确实就是普通消息了，如果订阅者一直不消费或者消费不了则会一直重试，到最后进入死信队列。其实这也算最大努力。</p><p>所以<strong>最大努力通知其实只是表明了一种柔性事务的思想</strong>：我已经尽力我最大的努力想达成事务的最终一致了。</p><p>适用于对时间不敏感的业务，例如短信通知。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="了解本地消息表">（了解）本地消息表<a href="#了解本地消息表" class="hash-link" aria-label="（了解）本地消息表的直接链接" title="（了解）本地消息表的直接链接">​</a></h4><p>本地消息表其实就是利用了 <strong>各系统本地的事务</strong>来实现分布式事务。</p><p>本地消息表顾名思义就是会有一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候 <strong>将业务的执行和将消息放入消息表中的操作放在同一个事务中</strong>，这样就能保证消息放入本地表中业务肯定是执行成功的。</p><p>然后再去调用下一个操作，如果下一个操作调用成功了好说，消息表的消息状态可以直接改成已成功。</p><p>如果调用失败也没事，会有 <strong>后台任务定时去读取本地消息表</strong>，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。</p><p>这时候有可能消息对应的操作不成功，因此也需要重试，重试就得保证对应服务的方法是幂等的，而且一般重试会有最大次数，超过最大次数可以记录下报警让人工处理。</p><p>可以看到本地消息表其实实现的是<strong>最终一致性</strong>，容忍了数据暂时不一致的情况。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="消息事务">消息事务<a href="#消息事务" class="hash-link" aria-label="消息事务的直接链接" title="消息事务的直接链接">​</a></h4><p>RocketMQ 就很好的支持了消息事务，让我们来看一下如何通过消息实现事务。</p><p>第一步先给 Broker 发送事务消息即半消息，<strong>半消息不是说一半消息，而是这个消息对消费者来说不可见</strong>，然后<strong>发送成功后发送方再执行本地事务</strong>。</p><p>再根据<strong>本地事务的结果向 Broker 发送 Commit 或者 RollBack 命令</strong>。</p><p>并且 RocketMQ 的发送方会提供一个<strong>反查事务状态接口</strong>，如果一段时间内半消息没有收到任何操作请求，那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。</p><p>如果是 Commit 那么订阅方就能收到这条消息，然后再做对应的操作，做完了之后再消费这条消息即可。</p><p>如果是 RollBack 那么订阅方收不到这条消息，等于事务就没执行过。</p><p>可以看到通过 RocketMQ 还是比较容易实现的，RocketMQ 提供了事务消息的功能，我们只需要定义好事务反查接口即可。</p><p><img loading="lazy" alt="image-20220725145800448" src="/Computer-Science-Learn-Notes/assets/images/image-20220725145800448-eff0aa6e488168148117270110972829.png" width="817" height="397" class="img_ev3q"></p><p>可以看到消息事务实现的也是最终一致性。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="最终一致性-1">最终一致性<a href="#最终一致性-1" class="hash-link" aria-label="最终一致性的直接链接" title="最终一致性的直接链接">​</a></h4><p><img loading="lazy" alt="image-20220617144020576" src="/Computer-Science-Learn-Notes/assets/images/image-20220617144020576-ee2b6d7cabca5c1accac8f9a238cadc4.png" width="1080" height="532" class="img_ev3q"></p><p>整个流程中，我们能保证是：</p><ul><li>业务主动方本地事务提交失败，业务被动方不会收到消息的投递。</li><li>只要业务主动方本地事务执行成功，那么消息服务一定会投递消息给下游的业务被动方，并最终保证业务被动方一定能成功消费该消息（消费成功或失败，即最终一定会有一个最终态）。</li></ul><p>不过呢技术就是这样，<strong>各种极端的情况我们都需要考虑</strong>，也很难有完美的方案，所以才会有这么多的方案<strong>三段式</strong>、<strong>TCC</strong>、<strong>最大努力通知</strong>等等分布式事务方案，大家只需要知道为啥要做，做了有啥好处，有啥坏处，在实际开发的时候都注意下就好好了，<strong>系统都是根据业务场景设计出来的，离开业务的技术没有意义，离开技术的业务没有底气</strong>。</p><p>还是那句话：<strong>没有最完美的系统，只有最适合的系统。</strong></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="分布式事务比较">分布式事务比较<a href="#分布式事务比较" class="hash-link" aria-label="分布式事务比较的直接链接" title="分布式事务比较的直接链接">​</a></h4><ul><li>基于消息事务是强一致性事务（会造成等待），会存在资源浪费</li><li>TCC事务是柔性事务，在try阶段要对资源做预留</li><li>TCC事务在确认或取消阶段释放资源</li><li>与基于消息事务相比，TCC的时效性要更好</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="分布式事务注意点">分布式事务注意点<a href="#分布式事务注意点" class="hash-link" aria-label="分布式事务注意点的直接链接" title="分布式事务注意点的直接链接">​</a></h4><ul><li>不要在分布式事务捕获任何异常</li><li>使用TCC-Transaction的时候，confirm和cancel的幂等性需要自己代码支持<ul><li>这就解释了为什么要在confirm和cancel里检查订单状态，而不直接修改为结束状态 ---&gt; 保证幂等性</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="tcc-transaction框架">TCC-Transaction框架<a href="#tcc-transaction框架" class="hash-link" aria-label="TCC-Transaction框架的直接链接" title="TCC-Transaction框架的直接链接">​</a></h4><p><img loading="lazy" alt="image-20220913170527093" src="/Computer-Science-Learn-Notes/assets/images/image-20220913170527093-bc58c803b96279452ac0d509c5cc6592.png" width="1005" height="902" class="img_ev3q"></p><ol><li>什么时候生成的TRANSACTION_CONTEXT隐式参数</li><li>如何判断大事务下有哪些小事务</li><li>为什么要有@Compensable注解</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="常见保证幂等的方式">常见保证幂等的方式<a href="#常见保证幂等的方式" class="hash-link" aria-label="常见保证幂等的方式的直接链接" title="常见保证幂等的方式的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是幂等性">什么是幂等性<a href="#什么是幂等性" class="hash-link" aria-label="什么是幂等性的直接链接" title="什么是幂等性的直接链接">​</a></h4><p>幂等是一个数学与计算机学概念，在数学中某一元运算为幂等时，其作用在任一元素两次后会和其作用一次的结果相同。</p><p>在计算机中编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数或幂等方法是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是接口幂等性">什么是接口幂等性<a href="#什么是接口幂等性" class="hash-link" aria-label="什么是接口幂等性的直接链接" title="什么是接口幂等性的直接链接">​</a></h4><p>在HTTP/1.1中，对幂等性进行了定义。它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外），即第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。</p><p>这里的副作用是不会对结果产生破坏或者产生不可预料的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="为什么需要实现幂等性">为什么需要实现幂等性<a href="#为什么需要实现幂等性" class="hash-link" aria-label="为什么需要实现幂等性的直接链接" title="为什么需要实现幂等性的直接链接">​</a></h4><p>在接口调用时一般情况下都能正常返回信息不会重复提交，不过在遇见以下情况时可以就会出现问题，如：</p><ul><li><strong>前端重复提交表单：</strong> 在填写一些表格时候，用户填写完成提交，很多时候会因网络波动没有及时对用户做出提交成功响应，致使用户认为没有成功提交，然后一直点提交按钮，这时就会发生重复提交表单请求。</li><li><strong>用户恶意进行刷单：</strong> 例如在实现用户投票这种功能时，如果用户针对一个用户进行重复提交投票，这样会导致接口接收到用户重复提交的投票信息，这样会使投票结果与事实严重不符。</li><li><strong>接口超时重复提交：</strong> 很多时候 HTTP 客户端工具都默认开启超时重试的机制，尤其是第三方调用接口时候，为了防止网络波动超时等造成的请求失败，都会添加重试机制，导致一个请求提交多次。</li><li><strong>消息进行重复消费：</strong> 当使用 MQ 消息中间件时候，如果发生消息中间件出现错误未及时提交消费信息，导致发生重复消费。</li></ul><p>使用幂等性最大的优势在于使接口保证任何幂等性操作，免去因重试等造成系统产生的未知的问题。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="引入幂等性后对系统的影响">引入幂等性后对系统的影响<a href="#引入幂等性后对系统的影响" class="hash-link" aria-label="引入幂等性后对系统的影响的直接链接" title="引入幂等性后对系统的影响的直接链接">​</a></h4><p>幂等性是为了简化客户端逻辑处理，能放置重复提交等操作，但却增加了服务端的逻辑复杂性和成本，其主要是：</p><ul><li>把并行执行的功能改为串行执行，降低了执行效率。</li><li>增加了额外控制幂等的业务逻辑，复杂化了业务功能；</li></ul><p>所以在使用时候需要考虑是否引入幂等性的必要性，根据实际业务场景具体分析，除了业务上的特殊要求外，一般情况下不需要引入的接口幂等性。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="restful-api-接口的幂等性">Restful API 接口的幂等性<a href="#restful-api-接口的幂等性" class="hash-link" aria-label="Restful API 接口的幂等性的直接链接" title="Restful API 接口的幂等性的直接链接">​</a></h4><p>现在流行的 Restful 推荐的几种 HTTP 接口方法中，分别存在幂等行与不能保证幂等的方法，如下：</p><ul><li><p>√ 满足幂等</p></li><li><p>x 不满足幂等</p></li><li><p>-<!-- --> 可能满足也可能不满足幂等，根据实际业务逻辑有关</p></li></ul><table><thead><tr><th align="center">方法类型</th><th align="center">是否幂等</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Get</td><td align="center">√</td><td align="center">Get 方法用于获取资源。其一般不会也不应当对系统资源进行改变，所以是幂等的。</td></tr><tr><td align="center">Post</td><td align="center">×</td><td align="center">Post 方法一般用于创建新的资源。其每次执行都会新增数据，所以不是幂等的。</td></tr><tr><td align="center">Put</td><td align="center">-</td><td align="center">Put 方法一般用于修改资源。该操作则分情况来判断是不是满足幂等，更新操作中直接根据某个值进行更新，也能保持幂等。不过执行累加操作的更新是非幂等。</td></tr><tr><td align="center">Delete</td><td align="center">-</td><td align="center">Delete  方法一般用于删除资源。该操作则分情况来判断是不是满足幂等，当根据唯一值进行删除时，删除同一个数据多次执行效果一样。不过需要注意，带查询条件的删除则就不一定满足幂等了。例如在根据条件删除一批数据后，这时候新增加了一条数据也满足条件，然后又执行了一次删除，那么将会导致新增加的这条满足条件数据也被删除。</td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_LWe7" id="如何实现幂等性">如何实现幂等性<a href="#如何实现幂等性" class="hash-link" aria-label="如何实现幂等性的直接链接" title="如何实现幂等性的直接链接">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="方案一数据库唯一主键">方案一：数据库唯一主键<a href="#方案一数据库唯一主键" class="hash-link" aria-label="方案一：数据库唯一主键的直接链接" title="方案一：数据库唯一主键的直接链接">​</a></h5><p><strong>方案描述</strong></p><p>数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。</p><p>使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键（可以参考 Java 中分布式 ID 的设计方案 这篇文章），这样才能能保证在分布式环境下 ID 的全局唯一性。</p><p><strong>适用操作：</strong></p><ul><li>插入操作</li><li>删除操作</li></ul><p><strong>使用限制：</strong></p><ul><li>需要生成全局唯一主键 ID；</li></ul><p><strong>主要流程：</strong></p><p><img loading="lazy" alt="image-20220725150136872" src="/Computer-Science-Learn-Notes/assets/images/image-20220725150136872-9fd04fb05fe6b60ae936906c9d3a285c.png" width="970" height="458" class="img_ev3q"></p><p>主要流程：</p><ul><li>① 客户端执行创建请求，调用服务端接口。</li><li>② 服务端执行业务逻辑，生成一个分布式 ID，将该 ID 充当待插入数据的主键，然后执数据插入操作，运行对应的 SQL 语句。</li><li>③ 服务端将该条数据插入数据库中，如果插入成功则表示没有重复调用接口。如果抛出主键重复异常，则表示数据库中已经存在该条记录，返回错误信息到客户端。</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="方案二数据库乐观锁">方案二：数据库乐观锁<a href="#方案二数据库乐观锁" class="hash-link" aria-label="方案二：数据库乐观锁的直接链接" title="方案二：数据库乐观锁的直接链接">​</a></h5><p><strong>方案描述：</strong></p><p>数据库乐观锁方案一般只能适用于执行“更新操作”的过程，我们可以提前在对应的数据表中多添加一个字段，充当当前数据的版本标识。这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新数据中的版本标识的值。</p><p><strong>适用操作：</strong></p><ul><li>更新操作</li></ul><p><strong>使用限制：</strong></p><ul><li>需要数据库对应业务表中添加额外字段；</li></ul><p><strong>描述示例：</strong></p><p><img loading="lazy" alt="image-20220725150153331" src="/Computer-Science-Learn-Notes/assets/images/image-20220725150153331-6edfbf094346963e18a75082779a3d7b.png" width="970" height="337" class="img_ev3q"></p><p>例如，存在如下的数据表中：</p><table><thead><tr><th align="left">id</th><th align="left">name</th><th align="left">price</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">小米手机</td><td align="left">1000</td></tr><tr><td align="left">2</td><td align="left">苹果手机</td><td align="left">2500</td></tr><tr><td align="left">3</td><td align="left">华为手机</td><td align="left">1600</td></tr></tbody></table><p>为了每次执行更新时防止重复更新，确定更新的一定是要更新的内容，我们通常都会添加一个 version 字段记录当前的记录版本，这样在更新时候将该值带上，那么只要执行更新操作就能确定一定更新的是某个对应版本下的信息。</p><table><thead><tr><th align="left">id</th><th align="left">name</th><th align="left">price</th><th align="left">version</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">小米手机</td><td align="left">1000</td><td align="left">10</td></tr><tr><td align="left">2</td><td align="left">苹果手机</td><td align="left">2500</td><td align="left">21</td></tr><tr><td align="left">3</td><td align="left">华为手机</td><td align="left">1600</td><td align="left">5</td></tr></tbody></table><p>这样每次执行更新时候，都要指定要更新的版本号，如下操作就能准确更新 version=5 的信息：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">UPDATE my_table SET price=price+50,version=version+1 WHERE id=1 AND version=5</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上面 WHERE 后面跟着条件 id=1 AND version=5 被执行后，id=1 的 version 被更新为 6，所以如果重复执行该条  SQL 语句将不生效，因为 id=1 AND version=5 的数据已经不存在，这样就能保住更新的幂等，多次更新对结果不会产生影响。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="方案三防重-token-令牌">方案三：防重 Token 令牌<a href="#方案三防重-token-令牌" class="hash-link" aria-label="方案三：防重 Token 令牌的直接链接" title="方案三：防重 Token 令牌的直接链接">​</a></h5><p><strong>方案描述：</strong></p><p>针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用  Token 的机制实现防止重复提交。简单的说就是调用方在调用接口的时候先向后端请求一个全局 ID（Token），请求的时候携带这个全局 ID  一起请求（Token 最好将其放到 Headers 中），后端需要对这个 Token 作为 Key，用户信息作为 Value 到 Redis  中进行键值内容校验，如果 Key 存在且 Value 匹配就执行删除命令，然后正常执行后面的业务逻辑。如果不存在对应的 Key 或 Value  不匹配就返回重复执行的错误信息，这样来保证幂等操作。</p><p><strong>适用操作：</strong></p><ul><li>插入操作</li><li>更新操作</li><li>删除操作</li></ul><p><strong>使用限制：</strong></p><ul><li>需要生成全局唯一 Token 串；</li><li>需要使用第三方组件 Redis 进行数据效验；</li></ul><p><strong>主要流程：</strong></p><p><img loading="lazy" alt="image-20220725150246041" src="/Computer-Science-Learn-Notes/assets/images/image-20220725150246041-18fb44290891fedb9f7072b1f10c95d0.png" width="970" height="459" class="img_ev3q"></p><ul><li>① 服务端提供获取 Token 的接口，该 Token 可以是一个序列号，也可以是一个分布式 ID 或者 UUID 串。</li><li>② 客户端调用接口获取 Token，这时候服务端会生成一个 Token 串。</li><li>③ 然后将该串存入 Redis 数据库中，以该 Token 作为 Redis 的键（注意设置过期时间）。</li><li>④ 将 Token 返回到客户端，客户端拿到后应存到表单隐藏域中。</li><li>⑤ 客户端在执行提交表单时，把 Token 存入到 Headers 中，执行业务请求带上该 Headers。</li><li>⑥ 服务端接收到请求后从 Headers 中拿到 Token，然后根据 Token 到 Redis 中查找该 key 是否存在。</li><li>⑦ 服务端根据 Redis 中是否存该 key 进行判断，如果存在就将该 key 删除，然后正常执行业务逻辑。如果不存在就抛异常，返回重复提交的错误信息。</li></ul><blockquote><p>注意，在并发情况下，执行 Redis 查找数据与删除需要保证原子性，否则很可能在并发下无法保证幂等性。其实现方法可以使用分布式锁或者使用 Lua 表达式来注销查询与删除操作。</p></blockquote><h5 class="anchor anchorWithStickyNavbar_LWe7" id="方案四下游传递唯一序列号">方案四:下游传递唯一序列号<a href="#方案四下游传递唯一序列号" class="hash-link" aria-label="方案四:下游传递唯一序列号的直接链接" title="方案四:下游传递唯一序列号的直接链接">​</a></h5><p><strong>方案描述：</strong></p><p>所谓请求序列号，其实就是每次向服务端请求时候附带一个短时间内唯一不重复的序列号，该序列号可以是一个有序 ID，也可以是一个订单号，一般由下游生成，在调用上游服务端接口时附加该序列号和用于认证的 ID。</p><p>当上游服务器收到请求信息后拿取该 序列号 和下游 认证ID 进行组合，形成用于操作 Redis 的 Key，然后到 Redis 中查询是否存在对应的 Key 的键值对，根据其结果：</p><ul><li>如果存在，就说明已经对该下游的该序列号的请求进行了业务处理，这时可以直接响应重复请求的错误信息。</li><li>如果不存在，就以该 Key 作为 Redis 的键，以下游关键信息作为存储的值（例如下游商传递的一些业务逻辑信息），将该键值对存储到 Redis 中 ，然后再正常执行对应的业务逻辑即可。</li></ul><p><strong>适用操作：</strong></p><ul><li>插入操作</li><li>更新操作</li><li>删除操作</li></ul><p><strong>使用限制：</strong></p><ul><li>要求第三方传递唯一序列号；</li><li>需要使用第三方组件 Redis 进行数据效验；</li></ul><p><strong>主要流程：</strong></p><p><img loading="lazy" alt="image-20220725150306807" src="/Computer-Science-Learn-Notes/assets/images/image-20220725150306807-11ff68f58563cbf460c75c16cc121306.png" width="970" height="479" class="img_ev3q"></p><p>主要步骤：</p><ul><li>① 下游服务生成分布式 ID 作为序列号，然后执行请求调用上游接口，并附带“唯一序列号”与请求的“认证凭据ID”。</li><li>② 上游服务进行安全效验，检测下游传递的参数中是否存在“序列号”和“凭据ID”。</li><li>③ 上游服务到 Redis 中检测是否存在对应的“序列号”与“认证ID”组成的  Key，如果存在就抛出重复执行的异常信息，然后响应下游对应的错误信息。如果不存在就以该“序列号”和“认证ID”组合作为  Key，以下游关键信息作为 Value，进而存储到 Redis 中，然后正常执行接来来的业务逻辑。</li></ul><blockquote><p>上面步骤中插入数据到 Redis 一定要设置过期时间。这样能保证在这个时间范围内，如果重复调用接口，则能够进行判断识别。如果不设置过期时间，很可能导致数据无限量的存入 Redis，致使 Redis 不能正常工作。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="分布式系统接口如何避免表单的重复提交">分布式系统接口，如何避免表单的重复提交？<a href="#分布式系统接口如何避免表单的重复提交" class="hash-link" aria-label="分布式系统接口，如何避免表单的重复提交？的直接链接" title="分布式系统接口，如何避免表单的重复提交？的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="幂等性">幂等性<a href="#幂等性" class="hash-link" aria-label="幂等性的直接链接" title="幂等性的直接链接">​</a></h4><p><strong>效果：</strong>系统对某接口的多次请求，都应该返回同样的结果！（网络访问失败的场景除外）</p><p><strong>目的：</strong>避免因为各种原因，重复请求导致的业务重复处理</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="重复请求场景案例">重复请求场景案例<a href="#重复请求场景案例" class="hash-link" aria-label="重复请求场景案例的直接链接" title="重复请求场景案例的直接链接">​</a></h4><p>1，客户端第一次请求后，网络异常导致收到请求执行逻辑但是没有返回给客户端，客户端的重新发起请求</p><p>2，客户端迅速点击按钮提交，导致同一逻辑被多次发送到服务器</p><p><em>简单来划分，业务逻辑无非都可以归纳为增删改查！</em></p><p><strong>对于查询</strong>，内部不包含其他操作，属于只读性质的那种业务必然符合幂等性要求的。</p><p><strong>对于删除</strong>，重复做删除请求至少不会造成数据杂乱，不过也有些场景更希望重复点击提示的是删除成功，而不是目标不存在的提示。</p><p><strong>对于新增和修改</strong>，这里是今天要重点关注的部分：新增，需要避免重复插入；修改，避免进行无效的重复修改；</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="幂等性的实现方式">幂等性的实现方式<a href="#幂等性的实现方式" class="hash-link" aria-label="幂等性的实现方式的直接链接" title="幂等性的实现方式的直接链接">​</a></h4><p><strong>实现方法：</strong>客户端做某一请求的时候带上识别参数标识，服务端对此标识进行识别，重复请求则重复返回第一次的结果即可。</p><p><strong>举个栗子：</strong>比如添加请求的表单里，在打开添加表单页面的时候，就生成一个AddId标识，这个AddId跟着表单一起提交到后台接口。</p><p>后台接口根据这个AddId，服务端就可以进行缓存标记并进行过滤，缓存值可以是AddId作为缓存key，返回内容作为缓存Value，这样即使添加按钮被多次点下也可以识别出来。</p><p>这个AddId什么时候更新呢？只有在保存成功并且清空表单之后，才变更这个AddId标识，从而实现新数据的表单提交</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="有几种生成唯一id的方式">有几种生成唯一ID的方式？<a href="#有几种生成唯一id的方式" class="hash-link" aria-label="有几种生成唯一ID的方式？的直接链接" title="有几种生成唯一ID的方式？的直接链接">​</a></h3><p>在复杂分布式系统和庞大数据量的场景下，一般需要对大量数据进行唯一标识。</p><p>比如：</p><ul><li>数据库分库分表后需要用一个唯一ID来标识一条数据。</li><li>nosql中的数据，需要一个唯一ID与其他数据源的数据进行关联</li></ul><p>本文对比和总结了常见的几种方式，在座同学可以进行参考。</p><p>我在实际项目中经常使用ksuid算法。它简单可靠，还可按时间排序</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="uuid">UUID<a href="#uuid" class="hash-link" aria-label="UUID的直接链接" title="UUID的直接链接">​</a></h4><p><code>UUID （Universally Unique Identifier）</code>，通用唯一识别码的缩写。UUID是由一组32位数的16进制数字所构成，所以UUID理论上的总数为 <code>16^32=2^128</code>，约等于 <code>3.4 x 10^38</code>。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。</p><p>生成的UUID是由 8-4-4-4-12格式的数据组成，其中32个字符和4个连字符&#x27; - &#x27;，一般我们使用的时候会将连字符删除 uuid.<code>toString().replaceAll(&quot;-&quot;,&quot;&quot;)</code>。</p><p>目前UUID的产生方式有5种版本，每个版本的算法不同，应用范围也不同。</p><ul><li><code>基于时间的UUID</code> - 版本1： 这个一般是通过当前时间，随机数，和本地Mac地址来计算出来，可以通过 org.apache.logging.log4j.core.util包中的 UuidUtil.getTimeBasedUuid()来使用或者其他包中工具。由于使用了MAC地址，因此能够确保唯一性，但是同时也暴露了MAC地址，私密性不够好。</li><li><code>DCE安全的UUID</code> - 版本2 DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。</li><li><code>基于名字的UUID（MD5）</code>- 版本3 基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。</li><li><code>随机UUID</code> - 版本4 根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但是重复的可能性可以忽略不计，因此该版本也是被经常使用的版本。JDK中使用的就是这个版本。</li><li><code>基于名字的UUID（SHA1）</code> - 版本5 和基于名字的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。</li></ul><p>一般选用V4版本，V1有暴露mac地址的风险，V2特定场景才会用到，V3、V5相同的输入参数得到相同的UUID</p><p>优缺点</p><ul><li>优点：简单可靠</li><li>缺点：不可排序，不利于检索</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="mysql自增id">mysql自增id<a href="#mysql自增id" class="hash-link" aria-label="mysql自增id的直接链接" title="mysql自增id的直接链接">​</a></h4><p>适用mysql的自增id机制，满足 递增性、单调性、唯一性。</p><ul><li>在单机情况下，如果并发量高，mysql的压力会很大。</li><li>分布式情况下，一般需要设定每台机器初始ID，来避免ID重复。这种方式有局限性，且水平扩展方案复杂，容易 出问题。</li></ul><p>优缺点</p><ul><li>优点：简单可靠，在单机、并发不高、数据量较小的情况下适用</li><li>缺点：在分库分表、高并发场景下不适用</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="redis">redis<a href="#redis" class="hash-link" aria-label="redis的直接链接" title="redis的直接链接">​</a></h4><p>因为Redis是单线程，天生保证原子性，可以使用原子操作INCR和INCRBY来实现</p><p>单机和分布式的优缺点与mysql类似</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="snowflake">snowflake<a href="#snowflake" class="hash-link" aria-label="snowflake的直接链接" title="snowflake的直接链接">​</a></h4><p>Snowflake，雪花算法是由Twitter开源的分布式ID生成算法，以划分命名空间的方式将 64-bit位分割成多个部分，每个部分代表不同的含义。而 Java中64bit的整数是Long类型，所以在 Java 中 SnowFlake 算法生成的 ID 就是 long 来存储的。</p><ul><li><strong>第1位</strong>占用1bit，其值始终是0，可看做是符号位不使用。</li><li><strong>第2位</strong>开始的41位是时间戳，41-bit位可表示2^41个数，每个数代表毫秒，那么雪花算法可用的时间年限是 <code>(1L&lt;&lt;41)/(1000L360024*365)</code>=69 年的时间。</li><li><strong>中间的10-bit位</strong>可表示机器数，即2^10 = 1024台机器，但是一般情况下我们不会部署这么台机器。如果我们对IDC（互联网数据中心）有需求，还可以将 10-bit 分 5-bit 给 IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，具体的划分可以根据自身需求定义。</li><li><strong>最后12-bit位</strong>是自增序列，可表示2^12 = 4096个数。</li></ul><p>这样的划分之后相当于<strong>在一毫秒一个数据中心的一台机器上可产生4096个有序的不重复的ID</strong>。但是我们 IDC 和机器数肯定不止一个，所以毫秒内能生成的有序ID数是翻倍的。</p><p>算法结构</p><p><img loading="lazy" alt="image-20220709155254210" src="/Computer-Science-Learn-Notes/assets/images/image-20220709155254210-70d35a0461d0adf55bd0bf46561f97cf.png" width="885" height="265" class="img_ev3q"></p><p>优势：</p><ul><li>单机可在一毫秒内生成4096个唯一ID</li><li>因为最高位是时间戳，所以snowflake生成的ID都是按时间趋势递增</li><li>因为有 workerId来做区分，所以整个分布式系统内不会产生重复ID</li></ul><p>最大的问题：时钟回拨</p><p>snowflake非常依赖系统时间的一致性，如果发生系统时间的回调，改变，就可能会发生id的重复</p><p>下面是我总结的几种解决方法：</p><ul><li>简单粗暴，直接抛出错误，让业务层去解决</li><li>关闭服务器时间同步</li><li>保存过去一小时，每个毫秒的序号使用情况。如果时间回退到某一毫秒，可以使用这一毫秒的序号，继续生成ID</li><li>生成ID的时间，不实时跟随服务器时间，当1毫秒内的序号全部用完，才跳到下一毫秒。如果生成ID的并发量不大，就有很大的余量时间没有使用，就算时钟回退了，也是回退到没有被使用的时间。</li></ul><p>优缺点</p><ul><li>优点：生成的ID趋势递增，生成效率高，可保证不重复</li><li>缺点：时钟回拨问题处理起来复杂，容易出现问题</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="ksuid">ksuid<a href="#ksuid" class="hash-link" aria-label="ksuid的直接链接" title="ksuid的直接链接">​</a></h4><p>算法结构</p><p><img loading="lazy" alt="image-20220709155341400" src="/Computer-Science-Learn-Notes/assets/images/image-20220709155341400-45f9877aba0d0f80481f0649056d9ba1.png" width="1080" height="237" class="img_ev3q"></p><p>ksuid由两部分组成</p><ul><li><strong>第一部分</strong></li></ul><p>32位的秒级时间戳</p><ul><li><strong>第二部分</strong></li></ul><p>128 位随机生成载荷</p><p>优势：</p><ul><li>因为最高位是时间戳，所以snowflake生成的ID都是按时间趋势递增</li><li>而128位的号码空间，在一秒内出现随机碰撞的概率非常之低，1/2^128 约等于明天陨石撞地球的概率</li><li>没有序号则可以避免snowflake的时钟回拨问题</li></ul><p>优缺点</p><ul><li>优点：生成的ID趋势递增，生成效率高，没有时钟回拨的问题</li><li>缺点：有随机部分，理论上存在随机碰撞的可能</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="其他">其他<a href="#其他" class="hash-link" aria-label="其他的直接链接" title="其他的直接链接">​</a></h4><p>另外还有：</p><ul><li>百度-UidGenerator</li><li>美团Leaf</li></ul><p>对比了5种解决方案。在我的业务场景下，我选择简单可靠的ksuid算法来生成唯一ID</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="单点登录">单点登录<a href="#单点登录" class="hash-link" aria-label="单点登录的直接链接" title="单点登录的直接链接">​</a></h3><p>单点登录的英文名叫做：Single Sign On（简称<strong>SSO</strong>）。</p><p>在<strong>初学/以前</strong>的时候，一般我们就<strong>单系统</strong>，所有的功能都在同一个系统上。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dubbo面试汇总">Dubbo面试汇总<a href="#dubbo面试汇总" class="hash-link" aria-label="Dubbo面试汇总的直接链接" title="Dubbo面试汇总的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是-dubbo">什么是 Dubbo?<a href="#什么是-dubbo" class="hash-link" aria-label="什么是 Dubbo?的直接链接" title="什么是 Dubbo?的直接链接">​</a></h4><p><a href="https://github.com/apache/dubbo" target="_blank" rel="noopener noreferrer">Apache Dubbo</a>|ˈdʌbəʊ| 是一款高性能、轻量级的开源 Java RPC 框架。</p><p>根据 <a href="https://dubbo.apache.org/zh/" target="_blank" rel="noopener noreferrer">Dubbo 官方文档</a>的介绍，Dubbo 提供了六大核心能力</p><ol><li>面向接口代理的高性能RPC调用。</li><li>智能容错和负载均衡。</li><li>服务自动注册和发现。</li><li>高度可扩展能力。</li><li>运行期流量调度。</li><li>可视化的服务治理与运维。</li></ol><p><img loading="lazy" alt="image-20220726154002025" src="/Computer-Science-Learn-Notes/assets/images/image-20220726154002025-5bdc0ae2014497faf720f871dfaa6220.png" width="3148" height="826" class="img_ev3q"></p><p>简单来说就是： <strong>Dubbo 不光可以帮助我们调用远程服务，还提供了一些其他开箱即用的功能比如智能负载均衡。</strong></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="dubbo-的负载均衡策略">Dubbo 的负载均衡策略<a href="#dubbo-的负载均衡策略" class="hash-link" aria-label="Dubbo 的负载均衡策略的直接链接" title="Dubbo 的负载均衡策略的直接链接">​</a></h4><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 <code>random</code> 随机调用。我们还可以自行扩展负载均衡策略（参考Dubbo SPI机制）。</p><p>在 Dubbo 中，所有负载均衡实现类均继承自 <code>AbstractLoadBalance</code>，该类实现了 <code>LoadBalance</code> 接口，并封装了一些公共的逻辑。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractLoadBalance implements LoadBalance {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static int calculateWarmupWeight(int uptime, int warmup, int weight) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int getWeight(Invoker&lt;?&gt; invoker, Invocation invocation) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>AbstractLoadBalance</code> 的实现类有下面这些：</p><p><img loading="lazy" alt="image-20220726154345877" src="/Computer-Science-Learn-Notes/assets/images/image-20220726154345877-606a983b1a45797e382d72293bc1c293.png" width="611" height="308" class="img_ev3q"></p><p>官方文档对负载均衡这部分的介绍非常详细，推荐小伙伴们看看，地址：<a href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#m-zhdocsv27devsourceloadbalance" target="_blank" rel="noopener noreferrer">https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#m-zhdocsv27devsourceloadbalance</a></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="randomloadbalance">RandomLoadBalance<a href="#randomloadbalance" class="hash-link" aria-label="RandomLoadBalance的直接链接" title="RandomLoadBalance的直接链接">​</a></h5><p>根据权重随机选择（对加权随机算法的实现）。这是Dubbo默认采用的一种负载均衡策略。</p><p><code> RandomLoadBalance</code> 具体的实现原理非常简单，假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。</p><p>我们把这些权重值分布在坐标区间会得到：S1-&gt;[0, 7) ，S2-&gt;[7, 10)。我们生成[0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。</p><p><img loading="lazy" alt="image-20220726154405163" src="/Computer-Science-Learn-Notes/assets/images/image-20220726154405163-904b0348f8c40596b726c21633cc1aa8.png" width="482" height="591" class="img_ev3q"></p><p><code>RandomLoadBalance</code> 的源码非常简单，简单花几分钟时间看一下。</p><blockquote><p>以下源码来自 Dubbo master 分支上的最新的版本 2.7.9。</p></blockquote><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class RandomLoadBalance extends AbstractLoadBalance {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static final String NAME = &quot;random&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int length = invokers.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean sameWeight = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] weights = new int[length]; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int totalWeight = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 下面这个for循环的主要作用就是计算所有该服务的提供者的权重之和 totalWeight（），</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 除此之外，还会检测每个服务提供者的权重是否相同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int weight = getWeight(invokers.get(i), invocation);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            totalWeight += weight;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            weights[i] = totalWeight;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (sameWeight &amp;&amp; totalWeight != weight * (i + 1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sameWeight = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (totalWeight &gt; 0 &amp;&amp; !sameWeight) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 随机生成一个 [0, totalWeight) 区间内的数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int offset = ThreadLocalRandom.current().nextInt(totalWeight);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 判断会落在哪个服务提供者的区间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (offset &lt; weights[i]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return invokers.get(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="leastactiveloadbalance">LeastActiveLoadBalance<a href="#leastactiveloadbalance" class="hash-link" aria-label="LeastActiveLoadBalance的直接链接" title="LeastActiveLoadBalance的直接链接">​</a></h5><p><code>LeastActiveLoadBalance</code> 直译过来就是<strong>最小活跃数负载均衡</strong>。</p><p>这个名字起得有点不直观，不仔细看官方对活跃数的定义，你压根不知道这玩意是干嘛的。</p><p>我这么说吧！初始状态下所有服务提供者的活跃数均为 0（每个服务提供者的中特定方法都对应一个活跃数，我在后面的源码中会提到），每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。</p><p>因此，<strong>Dubbo 就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。</strong></p><p><strong>如果有多个服务提供者的活跃数相等怎么办？</strong></p><p>很简单，那就再走一遍 <code>RandomLoadBalance</code> 。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class LeastActiveLoadBalance extends AbstractLoadBalance {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static final String NAME = &quot;leastactive&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int length = invokers.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int leastActive = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int leastCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] leastIndexes = new int[length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] weights = new int[length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int totalWeight = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int firstWeight = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean sameWeight = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这个 for 循环的主要作用是遍历 invokers 列表，找出活跃数最小的 Invoker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果有多个 Invoker 具有相同的最小活跃数，还会记录下这些 Invoker 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取 invoker 对应的活跃(active)数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int afterWarmup = getWeight(invoker, invocation);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            weights[i] = afterWarmup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (leastActive == -1 || active &lt; leastActive) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                leastActive = active;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                leastCount = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                leastIndexes[0] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                totalWeight = afterWarmup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                firstWeight = afterWarmup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sameWeight = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (active == leastActive) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                leastIndexes[leastCount++] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                totalWeight += afterWarmup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (sameWeight &amp;&amp; afterWarmup != firstWeight) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sameWeight = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       // 如果只有一个 Invoker 具有最小的活跃数，此时直接返回该 Invoker 即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (leastCount == 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return invokers.get(leastIndexes[0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果有多个 Invoker 具有相同的最小活跃数，但它们之间的权重不同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里的处理方式就和  RandomLoadBalance 一致了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!sameWeight &amp;&amp; totalWeight &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; leastCount; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int leastIndex = leastIndexes[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                offsetWeight -= weights[leastIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (offsetWeight &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return invokers.get(leastIndex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>活跃数是通过 <code>RpcStatus</code> 中的一个 <code>ConcurrentMap</code> 保存的，根据 URL 以及服务提供者被调用的方法的名称，我们便可以获取到对应的活跃数。也就是说服务提供者中的每一个方法的活跃数都是互相独立的。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class RpcStatus {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final ConcurrentMap&lt;String, ConcurrentMap&lt;String, RpcStatus&gt;&gt; METHOD_STATISTICS =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, RpcStatus&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public static RpcStatus getStatus(URL url, String methodName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String uri = url.toIdentityString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ConcurrentMap&lt;String, RpcStatus&gt; map = METHOD_STATISTICS.computeIfAbsent(uri, k -&gt; new ConcurrentHashMap&lt;&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return map.computeIfAbsent(methodName, k -&gt; new RpcStatus());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getActive() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return active.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="consistenthashloadbalance">ConsistentHashLoadBalance<a href="#consistenthashloadbalance" class="hash-link" aria-label="ConsistentHashLoadBalance的直接链接" title="ConsistentHashLoadBalance的直接链接">​</a></h5><p><code>ConsistentHashLoadBalance</code> 小伙伴们应该也不会陌生，在分库分表、各种集群中就经常使用这个负载均衡策略。</p><p><code>ConsistentHashLoadBalance</code> 即<strong>一致性Hash负载均衡策略</strong>。 <code>ConsistentHashLoadBalance</code> 中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。</p><p><img loading="lazy" alt="image-20220726154509626" src="/Computer-Science-Learn-Notes/assets/images/image-20220726154509626-7013111b65656a0a19dd13b5ff5ed647.png" width="1594" height="688" class="img_ev3q"></p><p>另外，Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。</p><p><img loading="lazy" alt="image-20220726154517156" src="/Computer-Science-Learn-Notes/assets/images/image-20220726154517156-f79c1410e8173503cba9ba3f46890a7c.png" width="1622" height="738" class="img_ev3q"></p><p>官方有详细的源码分析：<a href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#23-consistenthashloadbalance" target="_blank" rel="noopener noreferrer">https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#23-consistenthashloadbalance</a> 。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="roundrobinloadbalance">RoundRobinLoadBalance<a href="#roundrobinloadbalance" class="hash-link" aria-label="RoundRobinLoadBalance的直接链接" title="RoundRobinLoadBalance的直接链接">​</a></h5><p>加权轮询负载均衡。</p><p>轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。比如假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。</p><p>如果我们有 10 次请求，那么 7 次会被 S1处理，3次被 S2处理。</p><p>但是，如果是 <code>RandomLoadBalance</code> 的话，很可能存在10次请求有9次都被 S1 处理的情况（概率性问题）。</p><p>Dubbo 中的 <code>RoundRobinLoadBalance</code> 的代码实现被修改重建了好几次，Dubbo-2.6.5 版本的 <code>RoundRobinLoadBalance</code> 为平滑加权轮询算法。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/zhiyu1998/Computer-Science-Learn-Notes/edit/master/docs/Java/eightpart/distribution.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/redis"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">redis</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/messageQueue"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">messageQueue</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#-分布式" class="table-of-contents__link toc-highlight">🔗 分布式</a><ul><li><a href="#理论基础" class="table-of-contents__link toc-highlight">理论基础</a></li><li><a href="#了解rpc吗" class="table-of-contents__link toc-highlight">了解RPC吗？</a></li><li><a href="#有哪些常见的-rpc-框架" class="table-of-contents__link toc-highlight">有哪些常见的 RPC 框架？</a></li><li><a href="#了解分布式事务吗" class="table-of-contents__link toc-highlight">了解分布式事务吗？</a></li><li><a href="#常见保证幂等的方式" class="table-of-contents__link toc-highlight">常见保证幂等的方式</a></li><li><a href="#分布式系统接口如何避免表单的重复提交" class="table-of-contents__link toc-highlight">分布式系统接口，如何避免表单的重复提交？</a></li><li><a href="#有几种生成唯一id的方式" class="table-of-contents__link toc-highlight">有几种生成唯一ID的方式？</a></li><li><a href="#单点登录" class="table-of-contents__link toc-highlight">单点登录</a></li><li><a href="#dubbo面试汇总" class="table-of-contents__link toc-highlight">Dubbo面试汇总</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/Computer-Science-Learn-Notes/docs/intro">主页</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="#" class="footer__link-item">莫得</a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/zhiyu1998" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Computer Science Learn Notes, Inc. Built with Zhiyu1998.</div></div></div></footer></div>
<script src="/Computer-Science-Learn-Notes/assets/js/runtime~main.978cdf48.js"></script>
<script src="/Computer-Science-Learn-Notes/assets/js/main.7c330b06.js"></script>
</body>
</html>