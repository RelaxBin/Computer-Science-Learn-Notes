<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Java/eightpart/foundation">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">foundation | Computer Science Learn Notes</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/foundation"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="foundation | Computer Science Learn Notes"><meta data-rh="true" name="description" content="☕️ Java基础"><meta data-rh="true" property="og:description" content="☕️ Java基础"><link data-rh="true" rel="icon" href="/Computer-Science-Learn-Notes/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/foundation"><link data-rh="true" rel="alternate" href="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/foundation" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/foundation" hreflang="x-default"><link rel="stylesheet" href="/Computer-Science-Learn-Notes/assets/css/styles.e7823470.css">
<link rel="preload" href="/Computer-Science-Learn-Notes/assets/js/runtime~main.978cdf48.js" as="script">
<link rel="preload" href="/Computer-Science-Learn-Notes/assets/js/main.7c330b06.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Computer-Science-Learn-Notes/"><div class="navbar__logo"><img src="/Computer-Science-Learn-Notes/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/Computer-Science-Learn-Notes/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Computer Science Learn Notes</b></a><a class="navbar__item navbar__link" href="/Computer-Science-Learn-Notes/docs/intro">主页</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/zhiyu1998/Computer-Science-Learn-Notes" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="搜索" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div><div class="searchHintContainer_Pkmr"><kbd class="searchHint_iIMx">ctrl</kbd><kbd class="searchHint_iIMx">K</kbd></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/Computer-Science-Learn-Notes/docs/golang/learnInProblem">目录</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/golang/learnInProblem">Go语言</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/frontend/react/">前端</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/fundamental/datastruct">基础知识</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/basic/">Java基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/giant">Java面试</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/giant">2022大厂面试题</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intro">常见面试题精选</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intro">前言</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/foundation">Java基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/concurrency">Java并发</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/virtualMachine">JVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/spring">Spring系列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/mysql">MySQL</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/redis">Redis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/distribution">分布式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/messageQueue">消息队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/netty">Netty</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/network">计算机网络</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/system">操作系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/datastruct">数据结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intelligenceQuestion">智力题</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/think">基于面试题的一些思考</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/leetcode/">力扣刷题顺序</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/leetcode/src/剑指offer/数组中重复的数字">刷题汇总</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/others/personal_tech">其他分享</a></div></li></ul></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/Computer-Science-Learn-Notes/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">目录</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Java面试</span><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">常见面试题精选</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java基础</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>foundation</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="️-java基础">☕️ Java基础<a href="#️-java基础" class="hash-link" aria-label="☕️ Java基础的直接链接" title="☕️ Java基础的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-8的接新增了哪些特性">Java 8的接⼝新增了哪些特性？<a href="#java-8的接新增了哪些特性" class="hash-link" aria-label="Java 8的接⼝新增了哪些特性？的直接链接" title="Java 8的接⼝新增了哪些特性？的直接链接">​</a></h3><ul><li><strong>Lambda 表达式</strong> − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中)。</li><li><strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li><strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。</li><li><strong>新工具</strong> − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li><li><strong>Stream API</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li><li><strong>Date Time API</strong> − 加强对日期与时间的处理。</li><li><strong>Optional 类</strong> − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li><li><strong>Nashorn, JavaScript 引擎</strong> − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="重载和重写的区别">重载和重写的区别？<a href="#重载和重写的区别" class="hash-link" aria-label="重载和重写的区别？的直接链接" title="重载和重写的区别？的直接链接">​</a></h3><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问
修饰符可以不同。
下面是《Java 核心技术》对重载这个概念的介绍：</p><p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。
重写：
重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围
大于等于父类。</li><li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰
的方法能够被再次声明。</li><li>构造方法无法被重写
综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</li></ol><p><img loading="lazy" alt="image-20220617164632798" src="/Computer-Science-Learn-Notes/assets/images/image-20220617164632798-7ee2d084825b19f5e6418db7fc87f9e6.png" width="827" height="433" class="img_ev3q"></p><p><img loading="lazy" alt="image-20220617164418584" src="/Computer-Science-Learn-Notes/assets/images/image-20220617164418584-20ab3d17130c5d7340228d084e495c0d.png" width="750" height="415" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="内部类了解吗">内部类了解吗？<a href="#内部类了解吗" class="hash-link" aria-label="内部类了解吗？的直接链接" title="内部类了解吗？的直接链接">​</a></h3><p>在Java中，可以将⼀个类的定义放在另外⼀个类的定义内部，这就是 内部类 。内部类本身就 是类的⼀
个属性，与其他属性定义⽅式⼀致。</p><p>内部类可以分为四种：</p><p>成员内部类：在一个类中直接定义的内部类，成员内部类与普通类的成员没什么区别，可以与普通成员一样进行修饰和限制。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Circle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    double radius = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Circle(double radius) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.radius = radius;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class Draw {     //内部类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void drawSahpe() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;drawshape&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>局部内部类：在方法中定义的内部类称为局部内部类。与局部变量类似</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class People{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public People() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Man{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Man(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public People getWoman(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        class Woman extends People{   //局部内部类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int age =0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Woman();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>匿名内部类：匿名内部类就是没有名字的内部类</p><p>静态内部类（<strong>嵌套类</strong>）：如果你不需要内部类对象与其外围类对象之间有联系，那你可以将内部类声明为static</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Test {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args)  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Outter.Inner inner = new Outter.Inner();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Outter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Outter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class Inner {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Inner() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashset-如何检查重复">HashSet 如何检查重复<a href="#hashset-如何检查重复" class="hash-link" aria-label="HashSet 如何检查重复的直接链接" title="HashSet 如何检查重复的直接链接">​</a></h3><p>思路整理：hashcode相同 -&gt; equals() 不同-&gt; hash再散列</p><ol><li>当你把对象加⼊HashSet时，HashSet会先计算对象的hashcode值来判断对象加⼊的位置，同时也会与其他已经加⼊的对象的hashcode值作⽐较</li><li>如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是<strong>如果发现有相同hashcode值的对象，这时会调⽤equals()⽅法</strong>来检查hashcode相等的对象是否真的相同</li><li>如果两者相同，HashSet就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。这样我们就⼤⼤减少了equals的次数，相应就⼤⼤提⾼了执⾏速度。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="构造法有哪些特性">构造⽅法有哪些特性？<a href="#构造法有哪些特性" class="hash-link" aria-label="构造⽅法有哪些特性？的直接链接" title="构造⽅法有哪些特性？的直接链接">​</a></h3><ul><li>名字与类名相同</li><li>没有返回值，但不能⽤void声明构造函数</li><li>⽣成类的对象时⾃动执⾏，⽆需调⽤</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="finalstaticthissuper-关键字总结">final,static,this,super 关键字总结<a href="#finalstaticthissuper-关键字总结" class="hash-link" aria-label="final,static,this,super 关键字总结的直接链接" title="final,static,this,super 关键字总结的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="static">static<a href="#static" class="hash-link" aria-label="static的直接链接" title="static的直接链接">​</a></h4><p><strong>static 关键字主要有以下四种使用场景：</strong></p><ol><li><strong>修饰成员变量和成员方法:</strong> 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：<code>类名.静态变量名</code> <code>类名.静态方法名()</code></li><li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li><li><strong>静态内部类（static 修饰类的话只能修饰内部类）：</strong> 静态内部类与非静态内部类之间存在一个最大的区别:  非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1.  它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。</li><li><strong>静态导包(用来导入类中的静态资源，1.5 之后的新特性):</strong> 格式为：<code>import static</code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li></ol><h4 class="anchor anchorWithStickyNavbar_LWe7" id="final">final<a href="#final" class="hash-link" aria-label="final的直接链接" title="final的直接链接">​</a></h4><p><strong>final 关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：</strong></p><ol><li>final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；</li><li>final 修饰的方法不能被重写；</li><li>final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</li></ol><p>说明：使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将  final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final  方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="this">this<a href="#this" class="hash-link" aria-label="this的直接链接" title="this的直接链接">​</a></h4><p>this 关键字用于引用类的当前实例。 例如：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Manager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Employees[] employees;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void manageEmployees() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int totalEmp = this.employees.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Total employees: &quot; + totalEmp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.report();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void report() { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上面的示例中，this 关键字用于两个地方：</p><ul><li>this.employees.length：访问类 Manager 的当前实例的变量。</li><li>this.report（）：调用类 Manager 的当前实例的方法。</li></ul><p>此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="super-关键字">super 关键字<a href="#super-关键字" class="hash-link" aria-label="super 关键字的直接链接" title="super 关键字的直接链接">​</a></h4><p>super 关键字用于从子类访问父类的变量和方法。 例如：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Super {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected int number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected showNumber() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;number = &quot; + number);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Sub extends Super {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void bar() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.number = 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.showNumber();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上面的例子中，Sub 类访问父类成员变量 number 并调用其父类 Super 的 <code>showNumber（）</code> 方法。</p><p><strong>使用 this 和 super 要注意的问题：</strong></p><ul><li>在构造器中使用 <code>super()</code> 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</li><li>this、super 不能用在 static 方法中。</li></ul><p><strong>简单解释一下：</strong></p><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， <strong>this 和 super 是属于对象范畴的东西，而静态方法是属于类范畴的东西</strong>。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="this与super的区别">this与super的区别<a href="#this与super的区别" class="hash-link" aria-label="this与super的区别的直接链接" title="this与super的区别的直接链接">​</a></h3><ul><li>super:它引⽤当前对象的直接⽗类中的成员（⽤来访问直接⽗类中被隐藏的⽗类中成员数据或函数，基类与派⽣类中有相同成员定义时如：super.变量名super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产⽣⼆义性之处，应使⽤this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需⽤this来指明成员变量名）</li><li>👻super()和this()类似，区别是：super()在⼦类中调⽤⽗类的构造⽅法，this()在本类内调⽤本类的其它构造⽅法。</li><li>👻super()和this()均需放在构造⽅法内第⼀⾏。</li><li>👻this和super不能同时出现在⼀个构造函数⾥⾯，因为this必然会调⽤其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同⼀个构造函数⾥⾯有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使⽤。包括：static变量,static⽅法，static语句块。</li><li>👻从本质上讲，this是⼀个指向本对象的指针,然⽽super是⼀个Java关键字。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="静态代理和动态代理">静态代理和动态代理<a href="#静态代理和动态代理" class="hash-link" aria-label="静态代理和动态代理的直接链接" title="静态代理和动态代理的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="概述">概述<a href="#概述" class="hash-link" aria-label="概述的直接链接" title="概述的直接链接">​</a></h4><p>代理模式就是 <strong>使用代理对象来代替对真实对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><p>代理模式大致有三种角色：</p><ul><li>Real Subject：真实类，也就是被代理类、委托类。用来真正完成业务服务功能；</li><li>Proxy：代理类。将自身的请求用 Real Subject 对应的功能来实现，代理类对象并不真正的去实现其业务功能；</li><li>Subject：定义 RealSubject 和 Proxy 角色都应该实现的接口。</li></ul><p><img loading="lazy" alt="img" src="/Computer-Science-Learn-Notes/assets/images/20210221222746-ba32c489e50d2eb6844863f0418acd0a.png" width="1184" height="533" class="img_ev3q"></p><p>通俗来说，<strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些额外的操作，并且不用修改这个方法的原有代码</strong>。如果大家学过 Spring 的 AOP，一定能够很好的理解这句话。</p><p>举个例子：你找了小红来帮你向小绿问话，小红就看作是代理我的代理类 Proxy，而你是 Real Subject，因为小红要传达的话其实是你说的。那么你和小红都需要实现的接口（Subject）就是说话，由于你俩都能说话，在外界看来你俩就是一样的</p><p><img loading="lazy" alt="image-20220723002924420" src="/Computer-Science-Learn-Notes/assets/images/image-20220723002924420-6f96b59f4287e06489b422bfde11571a.png" width="1292" height="277" class="img_ev3q"></p><p>看到这里，不知道大家能不能理解了为什么委托类和代理类都需要实现相同的接口？</p><p>那是为了保持行为的一致性，在访问者看来两者之间就没有区别。这样，通过代理类这个中间层，很好地隐藏和保护了委托类对象，能<strong>有效屏蔽外界对委托类对象的直接访问</strong>。同时，也可以在代理类上加上额外的操作，比如<strong>小红在说话之前会跳一段舞，外界就会觉得你在说话前会跳一段舞，所以，这就实现了委托类的功能增强</strong>。</p><p>代理模式有静态代理和动态代理两种实现方式。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="静态代理">静态代理<a href="#静态代理" class="hash-link" aria-label="静态代理的直接链接" title="静态代理的直接链接">​</a></h4><p>先来看静态代理的实现步骤：</p><p>1）定义一个接口（Subject）</p><p>2）创建一个委托类（Real Subject）实现这个接口</p><p>3）创建一个代理类（Proxy）同样实现这个接口</p><p>4）<strong>将委托类 Real Subject 注入进代理类 Proxy</strong>，在代理类的方法中调用 Real Subject 中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</p><p>从实现和应用角度来说，静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦（需要对每个目标类都单独写一个代理类）。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p><p>从 JVM 层面来说， <strong>静态代理在编译时就将接口、委托类、代理类这些都变成了一个个实际的 <code>.class</code> 文件。</strong></p><p>1）定义发送短信的接口</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface SmsService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String send(String message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2）创建一个委托类（Real Subject）实现这个接口</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class SmsServiceImpl implements SmsService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String send(String message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;send message:&quot; + message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>3）创建一个代理类（Proxy）同样实现这个接口</p><p>4）将委托类 Real Subject 注入进代理类 Proxy，在代理类的方法中调用 Real Subject 中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class SmsProxy implements SmsService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将委托类注入进代理类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final SmsService smsService;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SmsProxy(SmsService smsService) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.smsService = smsService;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String send(String message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用委托类方法之前，我们可以添加自己的操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;before method send()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用委托类方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        smsService.send(message); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用委托类方法之后，我们同样可以添加自己的操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;after method send()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>那么，如何使用这个被增强的 <code>send</code> 方法呢？</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SmsService smsService = new SmsServiceImpl();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SmsProxy smsProxy = new SmsProxy(smsService);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        smsProxy.send(&quot;Java&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>运行上述代码之后，控制台打印出：</p><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">before method send</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">send message:java</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">after method send</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从输出结果可以看出，我们已经增强了委托类 <code>SmsServiceImpl</code>  的 <code>send()</code> 方法。</p><p>当然，从上述代码我们也能看出来，静态代理存在一定的弊端。假如说我们现在新增了一个委托类实现了 <code>SmsService</code> 接口，如果我们想要对这个委托类进行增强，就需要重新写一个代理类，然后注入这个新的委托类，非常不灵活。也就是说静态代理是一个委托了对应一个代理类，能不能<strong>将代理类做成一个通用的</strong>呢？为此，动态代理应用而生。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="java-字节码生成框架">Java 字节码生成框架<a href="#java-字节码生成框架" class="hash-link" aria-label="Java 字节码生成框架的直接链接" title="Java 字节码生成框架的直接链接">​</a></h4><p>在讲解动态之前，我们有必要详细说一下 <code>.class</code> 字节码文件这个东西。动态代理机制和 Java 字节码生成框架息息相关。</p><p>在上文反射中我们提到，一个 <code>Class</code> 类对应一个 <code>.class</code> 字节码文件，也就说字节码文件中存储了一个类的全部信息。字节码其实是二进制文件，内容是只有 JVM 能够识别的机器码。</p><p>解析过程这样的：JVM 读取 <code>.class</code> 字节码文件，取出二进制数据，加载到内存中，解析字节码文件内的信息，生成对应的 <code>Class</code> 类对象：</p><p><img loading="lazy" alt="image-20220723003010392" src="/Computer-Science-Learn-Notes/assets/images/image-20220723003010392-67bde3714cbf2c87fd11db4dbdadff44.png" width="1491" height="911" class="img_ev3q"></p><p>显然，上述这个过程是在编译期就发生的。</p><p>那么，由于JVM 是通过 <code>.class</code> 字节码文件（也就是二进制信息）加载类的，如果我们在运行期遵循 Java 编译系统组织 <code>.class</code> 字节码文件的格式和结构，生成相应的二进制数据，然后再把这个二进制数据加载转换成对应的类。这样，我们不就完成了在运行时动态的创建一个类。这个思想其实也就是动态代理的思想。</p><p><img loading="lazy" alt="image-20220723003018675" src="/Computer-Science-Learn-Notes/assets/images/image-20220723003018675-a294d1351bd81d4d7d973f151553d1f2.png" width="1734" height="965" class="img_ev3q"></p><p>在运行时期按照 JVM 规范对 <code>.class</code> 字节码文件的组织规则，生成对应的二进制数据。当前有很多开源框架可以完成这个功能，如</p><ul><li>ASM</li><li>CGLIB</li><li>Javassist</li><li>......</li></ul><p>需要注意的是，<strong>CGLIB 是基于 ASM 的</strong>。 这里简单对比一下 ASM 和 Javassist：</p><ul><li>Javassist 源代码级 API 比 ASM 中实际的字节码操作更容易使用</li><li>Javassist 在复杂的字节码级操作上提供了更高级别的抽象层。Javassist 源代码级 API 只需要很少的字节码知识，甚至不需要任何实际字节码知识，因此实现起来更容易、更快。</li><li>Javassist 使用反射机制，这使得它比 ASM 慢。</li></ul><p><strong>总的来说 ASM 比 Javassist 快得多，并且提供了更好的性能，但是 Javassist 相对来说更容易使用</strong>，两者各有千秋。</p><p>以 Javassist 为例，我们来看看这些框架在运行时生成 <code>.class</code> 字节码文件的强大能力。</p><p>正常来说，我们创建一个类的代码是这样的：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package com.samples;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Programmer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void code(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;I&#x27;m a Programmer,Just Coding.....&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面通过 Javassist 创建和上面一模一样的 <code>Programmer</code> 类的字节码：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import javassist.ClassPool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javassist.CtClass;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javassist.CtMethod;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javassist.CtNewMethod;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyGenerator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ClassPool pool = ClassPool.getDefault();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 创建 Programmer 类        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CtClass cc= pool.makeClass(&quot;com.samples.Programmer&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 定义方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CtMethod method = CtNewMethod.make(&quot;public void code(){}&quot;, cc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 插入方法代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        method.insertBefore(&quot;System.out.println(\&quot;I&#x27;m a Programmer,Just Coding.....\&quot;);&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cc.addMethod(method);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 保存生成的字节码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cc.writeFile(&quot;d://temp&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过反编译工具打开 <code>Programmer.class</code> 可以看到以下代码：</p><p><img loading="lazy" alt="image-20220723003032359" src="/Computer-Science-Learn-Notes/assets/images/image-20220723003032359-df02f7d1f7fc9711f72e1ff9f0239945.png" width="1234" height="555" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="动态代理">动态代理<a href="#动态代理" class="hash-link" aria-label="动态代理的直接链接" title="动态代理的直接链接">​</a></h4><p>了解了 Java 字节码生成框架，可以开始学习动态代理（Dynamic Proxy）了。</p><p>回顾一下静态代理，我们把静态代理的执行过程抽象为下图：</p><p><img loading="lazy" alt="image-20220723003049255" src="/Computer-Science-Learn-Notes/assets/images/image-20220723003049255-6580fedf52e4a11056927f30d3f88bac.png" width="1228" height="967" class="img_ev3q"></p><p>可以看见，代理类无非是在调用委托类方法的前后增加了一些操作。委托类的不同，也就导致代理类的不同。</p><p>那么为了做一个通用性的代理类出来，我们把调用委托类方法的这个动作抽取出来，把它封装成一个通用性的处理类，于是就有了动态代理中的 <code>InvocationHandler</code> 角色（处理类）。</p><p>于是，在代理类和委托类之间就多了一个处理类的角色，这个角色主要是<strong>对代理类调用委托类方法的这个动作进行统一的调用</strong>，也就是由 <code>InvocationHandler</code> 来统一处理代理类调用委托类方法这个操作。看下图：</p><p><img loading="lazy" alt="image-20220723003057769" src="/Computer-Science-Learn-Notes/assets/images/image-20220723003057769-ab836bcfef7f410c9e6fa0d899ed1470.png" width="1485" height="540" class="img_ev3q"></p><p><strong>从 JVM 角度来说，动态代理是在运行时动态生成 <code>.class</code> 字节码文件 ，并加载到 JVM 中的</strong>。这个我们在 Java 字节码生成框架中已经提到过。</p><p>虽然动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助，<strong>Spring AOP、RPC 等框架的实现都依赖了动态代理</strong>。</p><p>就 Java 来说，动态代理的实现方式有很多种，比如：</p><ul><li>JDK 动态代理</li><li>CGLIB 动态代理</li><li>Javassit 动态代理</li><li>......</li></ul><p>下面详细讲解这三种动态代理机制。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="jdk-动态代理机制">JDK 动态代理机制<a href="#jdk-动态代理机制" class="hash-link" aria-label="JDK 动态代理机制的直接链接" title="JDK 动态代理机制的直接链接">​</a></h4><p>先来看下 JDK 动态代理机制的使用步骤：</p><p>1）定义一个接口（Subject）</p><p>2）创建一个委托类（Real Subject）实现这个接口</p><p>3）创建一个处理类并实现 <code>InvocationHandler</code> 接口，重写其 <code>invoke</code> 方法（在 <code>invoke</code> 方法中利用反射机制调用委托类的方法，并自定义一些处理逻辑），并将委托类注入处理类</p><p><img loading="lazy" alt="image-20220723003128864" src="/Computer-Science-Learn-Notes/assets/images/image-20220723003128864-4a0522124053c069d3947679028b6353.png" width="1339" height="229" class="img_ev3q"></p><p>该方法有下面三个参数：</p><ul><li>proxy：代理类对象（见下一步）</li><li>method：还记得我们在上篇文章反射中讲到的 <code>Method.invoke</code> 吗？就是这个，我们可以通过它来调用委托类的方法（反射）</li></ul><p><img loading="lazy" alt="image-20220723003137612" src="/Computer-Science-Learn-Notes/assets/images/image-20220723003137612-564677d5a30a6da012e48c3d9139e114.png" width="1357" height="772" class="img_ev3q"></p><ul><li>args：传给委托类方法的参数列表</li></ul><p>4）创建代理对象（Proxy）：通过 <code>Proxy.newProxyInstance()</code> 创建委托类对象的代理对象</p><p><img loading="lazy" alt="image-20220723003147365" src="/Computer-Science-Learn-Notes/assets/images/image-20220723003147365-72881145863e6a40366a65bb341ec772.png" width="1173" height="271" class="img_ev3q"></p><p>这个方法需要 3 个参数：</p><ul><li>类加载器 ClassLoader</li><li>委托类实现的接口数组，至少需要传入一个接口进去</li><li>调用的 <code>InvocationHandler</code> 实例处理接口方法（也就是第 3 步我们创建的类的实例）</li></ul><p>也就是说：我们在通过 <code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现了 <code>InvocationHandler</code> 接口的处理类的 <code>invoke()</code>方法，可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><p>1）定义一个接口（Subject）</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface SmsService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String send(String message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2）创建一个委托类（Real Subject）实现这个接口</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class SmsServiceImpl implements SmsService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String send(String message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;send message:&quot; + message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>3）创建一个处理类，并将委托类注入处理类，另外，这个处理类需要实现 <code>InvocationHandler</code> 接口，重写其 <code>invoke</code> 方法（在 <code>invoke</code> 方法中利用反射机制调用委托类的方法，并自定义一些处理逻辑）</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.InvocationHandler;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.InvocationTargetException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.Method;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DebugInvocationHandler implements InvocationHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将委托类注入处理类（这里我们用 Object 代替，方便扩展）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Object target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DebugInvocationHandler(Object target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.target = target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 重写 invoke 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //调用方法之前，我们可以添加自己的操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;before method &quot; + method.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object result = method.invoke(target, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //调用方法之后，我们同样可以添加自己的操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;after method &quot; + method.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>4）定义一个创建代理对象（Proxy）的工厂类：通过 <code>Proxy.newProxyInstance()</code> 创建委托类对象的代理对象</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class JdkProxyFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Object getProxy(Object target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Proxy.newProxyInstance(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                target.getClass().getClassLoader(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                target.getClass().getInterfaces(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new DebugInvocationHandler(target)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>5）实际使用</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">smsService.send(&quot;Java&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>运行上述代码之后，控制台打印出：</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">before method send</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">send message:Java</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">after method send</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="cglib-动态代理机制">CGLIB 动态代理机制<a href="#cglib-动态代理机制" class="hash-link" aria-label="CGLIB 动态代理机制的直接链接" title="CGLIB 动态代理机制的直接链接">​</a></h4><p><strong>JDK 动态代理有一个最致命的问题是它只能代理实现了某个接口的实现类，并且代理类也只能代理接口中实现的方法，要是实现类中有自己私有的方法，而接口中没有的话，该方法不能进行代理调用</strong>。</p><p>为了解决这个问题，我们可以用 CGLIB 动态代理机制。</p><p>上文也提到过，CGLIB（Code Generation Library）是一个基于 ASM 的 Java 字节码生成框架，它允许我们在运行时对字节码进行修改和动态生成。原理就是<strong>通过字节码技术生成一个子类，并在子类中拦截父类方法的调用，织入额外的业务逻辑</strong>。关键词大家注意到没有，拦截！CGLIB 引入一个新的角色就是<strong>方法拦截器</strong> <code>MethodInterceptor</code>。和 JDK 中的处理类 <code>InvocationHandler</code> 差不多，也是用来实现方法的统一调用的。看下图：</p><p><img loading="lazy" alt="image-20220723003222393" src="/Computer-Science-Learn-Notes/assets/images/image-20220723003222393-e787edb4a71e155ebc55eed376f8c145.png" width="1679" height="771" class="img_ev3q"></p><p>另外由于 CGLIB 采用<strong>继承</strong>的方式，所以被代理的类不能被 <code>final</code> 修饰。</p><p>很多知名的开源框架都使用到了 CGLIB， 例如 <strong>Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理</strong>。</p><p>来看 CGLIB 动态代理的使用步骤：</p><p>1）首先创建一个委托类（Real Subject）</p><p>2）创建一个方法拦截器实现接口 <code>MethodInterceptor</code>，并重写 <code>intercept</code> 方法。<code>intercept</code> 用于拦截并增强委托类的方法（和 JDK 动态代理 <code>InvocationHandler</code> 中的 <code>invoke</code> 方法类似）</p><p><img loading="lazy" alt="image-20220723003232098" src="/Computer-Science-Learn-Notes/assets/images/image-20220723003232098-3584d8733bb8a5ba243409435381a6f4.png" width="1874" height="156" class="img_ev3q"></p><p>该方法拥有四个参数：</p><ul><li>Object var1：委托类对象</li><li>Method var2：被拦截的方法（委托类中需要增强的方法）</li><li>Object[] var3：方法入参</li><li>MethodProxy var4：用于调用委托类的原始方法（底层也是通过反射机制，不过不是 <code>Method.invoke</code> 了，而是使用 <code>MethodProxy.invokeSuper</code> 方法）</li></ul><p><img loading="lazy" alt="image-20220723003242424" src="/Computer-Science-Learn-Notes/assets/images/image-20220723003242424-0ed2befbf94a45ae9f2dc0bf22908855.png" width="1360" height="416" class="img_ev3q"></p><p>3）创建代理对象（Proxy）：通过 <code>Enhancer.create()</code> 创建委托类对象的代理对象</p><p><img loading="lazy" alt="image-20220723003250555" src="/Computer-Science-Learn-Notes/assets/images/image-20220723003250555-c6c2e209e2ac63f8d3ebba8916b52421.png" width="1765" height="723" class="img_ev3q"></p><p>也就是说：我们在通过 <code>Enhancer</code> 类的 <code>create()</code> 创建的代理对象在调用方法的时候，实际会调用到实现了 <code>MethodInterceptor</code> 接口的处理类的 <code>intercept()</code>方法，可以在 <code>intercept()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><blockquote><p>可以发现，CGLIB 动态代理机制和 JDK 动态代理机制的步骤差不多，CGLIB 动态代理的核心是方法拦截器 <code>MethodInterceptor</code> 和 <code>Enhancer</code>，而 JDK 动态代理的核心是处理类 <code>InvocationHandler</code> 和 <code>Proxy</code>。</p></blockquote><p>不同于 JDK 动态代理不需要额外的依赖。CGLIB 是一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p><div class="language-xml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-xml codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">cglib</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">cglib</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">3.3.0</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>1）首先创建一个委托类（Real Subject）</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class AliSmsService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String send(String message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;send message:&quot; + message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2）创建一个方法拦截器实现接口 <code>MethodInterceptor</code>，并重写 <code>intercept</code> 方法</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import net.sf.cglib.proxy.MethodInterceptor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import net.sf.cglib.proxy.MethodProxy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.Method;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DebugMethodInterceptor implements MethodInterceptor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用方法之前，我们可以添加自己的操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;before method &quot; + method.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 通过反射调用委托类的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object object = methodProxy.invokeSuper(o, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用方法之后，我们同样可以添加自己的操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;after method &quot; + method.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return object;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>3）创建代理对象（Proxy）：通过 <code>Enhancer.create()</code> 创建委托类对象的代理对象</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import net.sf.cglib.proxy.Enhancer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CglibProxyFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Object getProxy(Class&lt;?&gt; clazz) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建动态代理增强类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Enhancer enhancer = new Enhancer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置类加载器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enhancer.setClassLoader(clazz.getClassLoader());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置委托类（设置父类）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enhancer.setSuperclass(clazz);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置方法拦截器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enhancer.setCallback(new DebugMethodInterceptor());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建代理类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return enhancer.create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>从 <code>setSuperclass</code> 我们就能看出，为什么说 CGLIB 是基于继承的。</p></blockquote><p>4）实际使用</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">AliSmsService aliSmsService = </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">aliSmsService.send(&quot;Java&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>运行上述代码之后，控制台打印出：</p><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">before method send</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">send message:Java</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">after method send</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="jdk-动态代理和-cglib-动态代理对比">JDK 动态代理和 CGLIB 动态代理对比<a href="#jdk-动态代理和-cglib-动态代理对比" class="hash-link" aria-label="JDK 动态代理和 CGLIB 动态代理对比的直接链接" title="JDK 动态代理和 CGLIB 动态代理对比的直接链接">​</a></h4><p>1）JDK 动态代理是基于实现了接口的委托类，通过接口实现代理；而 CGLIB 动态代理是基于继承了委托类的子类，通过子类实现代理。</p><p>2）JDK 动态代理只能代理实现了接口的类，且只能增强接口中现有的方法；而 CGLIB 可以代理未实现任何接口的类。</p><p>3）就二者的效率来说，大部分情况都是 JDK 动态代理的效率更高，随着 JDK 版本的升级，这个优势更加明显。</p><blockquote><p>提一嘴，常见的还有 <strong>Javassist 动态代理机制</strong>。和 CGLIB 一样，作为一个 Java 字节码生成框架，Javassist 天生就拥有在运行时动态创建一个类的能力，实现动态代理自然不在话下。 Dubbo 就是默认使用 Javassit 来进行动态代理的。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="静态代理和动态代理对比">静态代理和动态代理对比<a href="#静态代理和动态代理对比" class="hash-link" aria-label="静态代理和动态代理对比的直接链接" title="静态代理和动态代理对比的直接链接">​</a></h4><ol><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 <code>.class</code> 字节码文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol><h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么情况下使用动态代理">什么情况下使用动态代理<a href="#什么情况下使用动态代理" class="hash-link" aria-label="什么情况下使用动态代理的直接链接" title="什么情况下使用动态代理的直接链接">​</a></h4><ol><li>设计模式中有一个设计原则是<strong>开闭原则</strong>，即<strong>对修改关闭，对扩展开放</strong>，我们在工作中有时会接手很多前人的代码，里面代码逻辑让人摸不着头脑，就很难去下手修改代码，那么这时我们就可以通过代理对类进行增强。</li><li>我们在使用 <strong>RPC 框架</strong>的时候，框架本身并不能提前知道各个业务方要调用哪些接口的哪些方法 。那么这个时候，就可用通过动态代理的方式来建立一个中间人给客户端使用，也方便框架进行搭建逻辑，某种程度上也是客户端代码和框架松耦合的一种表现。</li><li><strong>Spring 的 AOP</strong> 机制同样也是采用了动态代理，此处不做详细讨论。</li></ol><h4 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h4><p>全部捋一遍下来还是收获蛮多的，我感觉只要理解了字节码在编译期生成还是在运行期生成，就差不多能够把握住静态代理和动态代理了。总结一下静态代理和动态代理中的角色：</p><p>静态代理：</p><ul><li>Subject：公共接口</li><li>Real Subject：委托类</li><li>Proxy：代理类</li></ul><p>JDK 动态代理：</p><ul><li>Subject：公共接口</li><li>Real Subject：委托类</li><li>Proxy：代理类</li><li><strong>InvocationHandler</strong>：处理类，统一调用方法</li></ul><p>CGLIB 动态代理：</p><ul><li>Subject：公共接口</li><li>Real Subject：委托类</li><li>Proxy：代理类</li><li><strong>MethodInterceptor</strong>：方法拦截器，统一调用方法</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="static静态代码块与非静态代码块构造代码块">static{}静态代码块与{}非静态代码块(构造代码块)<a href="#static静态代码块与非静态代码块构造代码块" class="hash-link" aria-label="static{}静态代码块与{}非静态代码块(构造代码块)的直接链接" title="static{}静态代码块与{}非静态代码块(构造代码块)的直接链接">​</a></h3><p><strong>相同点</strong>： 都是在 JVM 加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些 static 变量进行赋值。</p><p><strong>不同点</strong>： 静态代码块在非静态代码块之前执行(静态代码块 -&gt; 非静态代码块 -&gt; 构造方法)。静态代码块只在第一次 new  执行一次，之后不再执行，而非静态代码块在每 new 一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。</p><blockquote><p>🐛 <strong>修正</strong>：静态代码块可能在第一次 new 对象的时候执行，但不一定只在第一次 new 的时候执行。比如通过 <code>Class.forName(&quot;ClassDemo&quot;)</code>创建 Class 对象的时候也会执行，即 new 或者 <code>Class.forName(&quot;ClassDemo&quot;)</code> 都会执行静态代码块。 一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：<code>Arrays</code> 类，<code>Character</code> 类，<code>String</code> 类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的.</p></blockquote><p>Example：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Test {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Test() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(&quot;默认构造方法！--&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //非静态代码块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(&quot;非静态代码块！--&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //静态代码块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(&quot;静态代码块！--&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static void test() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(&quot;静态方法中的内容! --&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.print(&quot;静态方法中的代码块！--&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Test test = new Test();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Test.test();//静态代码块！--静态方法中的内容! --静态方法中的代码块！--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码输出：</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！--</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当只执行 <code>Test.test();</code> 时输出：</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">静态代码块！--静态方法中的内容! --静态方法中的代码块！--</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当只执行 <code>Test test = new Test();</code> 时输出：</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">静态代码块！--非静态代码块！--默认构造方法！--</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>非静态代码块与构造函数的区别是：  非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="char型变量中能否能不能存储个中汉字为什么">char型变量中能否能不能存储⼀个中⽂汉字，为什么？<a href="#char型变量中能否能不能存储个中汉字为什么" class="hash-link" aria-label="char型变量中能否能不能存储⼀个中⽂汉字，为什么？的直接链接" title="char型变量中能否能不能存储⼀个中⽂汉字，为什么？的直接链接">​</a></h3><p>char可以存储⼀个中⽂汉字，因为Java中使⽤的编码是Unicode(不选择任何特定的编码，直接使⽤字符在字符集中的编号，这是统⼀的唯⼀⽅法），⼀个char类型占2个字节（16⽐特），所以放⼀个中⽂是没问题的。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="是否可以继承string类">是否可以继承String类？<a href="#是否可以继承string类" class="hash-link" aria-label="是否可以继承String类？的直接链接" title="是否可以继承String类？的直接链接">​</a></h3><p>String类是final类，不可以被继承。</p><p>补充：继承String本身就是⼀个错误的⾏为，对String类型最好的重⽤⽅式是关联关系（Has-A）和依赖关系（Use-A）⽽不是继承关系（Is-A）。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="谈谈你对多态的理解">谈谈你对多态的理解？<a href="#谈谈你对多态的理解" class="hash-link" aria-label="谈谈你对多态的理解？的直接链接" title="谈谈你对多态的理解？的直接链接">​</a></h3><p>著作权归<a href="https://pdai.tech%E6%89%80%E6%9C%89%E3%80%82" target="_blank" rel="noopener noreferrer">https://pdai.tech所有。</a> 链接：<a href="https://www.pdai.tech/md/java/basic/java-basic-oop.html" target="_blank" rel="noopener noreferrer">https://www.pdai.tech/md/java/basic/java-basic-oop.html</a></p><p>多态分为编译时多态和运行时多态:</p><ul><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul><p>下面的代码中，乐器类(Instrument)有两个子类: Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Instrument {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void play() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Instrument is playing...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Wind extends Instrument {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void play() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Wind is playing...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Percussion extends Instrument {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void play() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Percussion is playing...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Music {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        instruments.add(new Wind());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        instruments.add(new Percussion());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(Instrument instrument : instruments) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            instrument.play();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>详细</p></blockquote><p>多态的概念并不难，并且在实际编码中可以说是最最高频使用率。多态就是<strong>使得同一个行为具有多个不同表现形式或形态的能力</strong>。举个形象点的例子：对于 “打印” 这个行为，使用彩色打印机 “打印” 出来的效果就是彩色的，而使用黑白打印机 “打印” 出来的效果就是黑白的。我们就称 “打印” 这个行为是多态的，彩色打印效果和黑白打印效果就是 “打印” 这个行为的两个不同的表现形式。</p><p><img loading="lazy" alt="image-20220618172157050" src="/Computer-Science-Learn-Notes/assets/images/image-20220618172157050-104459e7d35bf27736f54bb11cbd2987.png" width="1136" height="812" class="img_ev3q"></p><p>还可以这样理解，<strong>同一个行为在不同的对象上会产生不同的结果</strong>。再举个形象点的例子：比如我们按下 F1 键这个行为：如果当前在 Word 下弹出的就是 Word 帮助和支持；在 Windows 下弹出的就是 Windows 帮助和支持。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="多态发生的三个必要条件">多态发生的三个必要条件<a href="#多态发生的三个必要条件" class="hash-link" aria-label="多态发生的三个必要条件的直接链接" title="多态发生的三个必要条件的直接链接">​</a></h4><p>先看下面这段代码，首先，我们有一个基类 <code>Shape</code>，三个子类，并且都重写了基类的 <code>draw</code> 方法：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void draw() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Circle extends Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Circle.draw()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Square extends Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Square.draw()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Triangle extends Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Triangle.draw()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面这几行代码就充分体现了多态性：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Shape circle = new Circle();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Shape square = new Square();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Shape triangle = new Triangle();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>大家应该不会太陌生，就是<strong>向上转型</strong>，没错，它就是多态的体现。同样的一个 draw 方法，在这三个不同的对象上产生了三种不同的行为，多态在此体现的淋漓尽致。</p><p>这里需要注意的是，当使用多态方式调用方法时，编译器会首先检查父类中是否有该方法，如果没有，则编译错误；如果父类中有该方法，并且被子类重写，就会调用子类的这个方法；如果父类的方法没有被子类重写，就会调用父类的方法。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Shape circle = new Circle();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">circle.draw(); // 调用的是 Circle 的 eat</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>简单来说：<strong>当父类引用变量指向子类对象后（多态），只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法</strong>。</p><p>结合上述这段简单的代码，我们总结一下多态产生的必要条件：</p><ul><li>1）继承</li><li>2）重写</li><li>3）父类引用指向子类对象：<code>Parent p = new Child();</code></li></ul><p><img loading="lazy" alt="image-20220618172217768" src="/Computer-Science-Learn-Notes/assets/images/image-20220618172217768-ef7746d1476276b069180e0e694cbdcc.png" width="1256" height="1042" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="多态是如何发生的">多态是如何发生的<a href="#多态是如何发生的" class="hash-link" aria-label="多态是如何发生的的直接链接" title="多态是如何发生的的直接链接">​</a></h4><p>❓ 那么，多态到底是如何发生的？编译器是如何知道父类 Shape 引用指向的是 Circle 而不是 Triangle 或 Square 呢？</p><p>首先，我们需要了解静态绑定和动态绑定的概念。什么是<strong>绑定</strong>？将一个方法调用同一个方法主体关联起来的过程就称作绑定。</p><p>若绑定发生在程序运行前，叫做<strong>静态绑定</strong>，也称<strong>前期绑定</strong>。你可能从来没有听说这个术语，因为它是<strong>面向过程</strong>语言不需选择默认的绑定方式，例如在 C 语言中就只有前期绑定这一种方法调用。</p><p>那么对于这段代码：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Shape circle = new Circle();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Shape square = new Square();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">circle.draw(); </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Shape 即引用类型在编译期可知，不会被改变，而 Circle 作为实例对象类型在运行期才可知，可能会发生变化。所以如果使用前期绑定，在运行之前，编译器只知道有一个 Shape 引用，它无法得知究竟会调用哪个方法。</p><p>解决方法就是<strong>动态绑定</strong> Dynamic Binding，在运行时根据对象的类型自动的进行绑定，所以动态绑定也称<strong>运行时绑定</strong>。动态绑定是多态的基础。</p><p>注意：Java 中除了 <code>static</code>和 <code>final</code>方法（<code>private</code>方法属于 <code>final</code>方法）之外，其他所有方法都是动态绑定。这意味着通常情况下，我们不需要判断动态绑定是否会发生，它是自动发生的。</p><blockquote><p><code>final</code> 和 <code>static</code> 关键字后续会单独出文章讲解，此处就笼统的概述一下为什么这两个关键字修饰的方法是静态绑定的：</p><ul><li><code>final</code> 不允许方法重写，而多态发生的条件之一就是重写，所以 <code>final</code> 方法会在编译期间就进行绑定，即静态绑定</li><li><code>static</code> 方法是类直接拥有的的，与该类的任何一个对象都无关（该类的所有对象共同维护），所以也是静态绑定</li></ul></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="重载和重写">重载和重写<a href="#重载和重写" class="hash-link" aria-label="重载和重写的直接链接" title="重载和重写的直接链接">​</a></h4><p>重载和重写在之前的文章中都说过了，此处正好借着多态这个主题将这两个容易混淆的概念总结一波。</p><p>方法的<strong>重写 Overriding</strong> 和<strong>重载 Overloading</strong> 都是是 Java 多态性的表现。</p><p>🔸 1）<strong>方法重写是父类与子类之间多态性的表现</strong>。其子类和父类方法的名字相同，参数个数相同，返回类型也相同，并且子类的访问权限不能比父类的严格，比如父类是 public，那么子类也只能是 public，不能比 public 更严格。也就是说，<strong>方法重写，只有方法体是不一样的，访问权限可以有限制的修改</strong>。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Circle extends Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Circle.draw()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>🚨 其实，上面说的返回类型完全相同并不严格正确。下面我们来解释一下。</p><p>首先，我们需要知道<strong>方法的名字和参数列表称为方法的签名</strong>。例如，<code>draw()</code>  和  <code>draw(String)</code> 是两个具有相同名字， 不同签名的方法。如果在子类中定义了一个与超类签名相同的方法， 那么子类中的这个方法就覆盖/重写了超类中的这个相同签名的方法。</p><p>不过，<strong>返回类型不是签名的一部分</strong>， 因此，在覆盖/重写方法时， 一定要保证返回类的兼容性。 <strong>允许子类将覆盖方法的返回类型定义为原返回类型的子类型</strong>。</p><p>例如， 假设 <code>Shape</code> 类有</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Shape draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在后面的子类 <code>Circle</code> 中， 可以按照如下所示的方式覆盖这个方法</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Circle extends Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Circle draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>用专业术语来说，这两个 <code>draw</code> 方法具有<strong>可协变的返回类型</strong>。</p><p>🔸 2）方法重载并非多态的必要条件，不过可以理解成<strong>某个类的多态性的表现</strong>。所谓方法重载，就是一个类中定义了多个方法名相同，但是参数的数量或者类型不同。方法的返回类型和访问权限可以任意修改，不以它俩作为方法重载的标志。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Circle extends Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Circle.draw()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw(int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Circle.draw()&quot; + i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="image-20220618172249142" src="/Computer-Science-Learn-Notes/assets/images/image-20220618172249142-812043c296bcde38a3bc1cf8798a16a3.png" width="1277" height="844" class="img_ev3q"></p><p>总结一下方法重载和重写：</p><table><thead><tr><th align="center"></th><th align="center">方法重载</th><th align="center">方法重写</th></tr></thead><tbody><tr><td align="center">方法名</td><td align="center">相同</td><td align="center">相同</td></tr><tr><td align="center">参数列表</td><td align="center">必须不同</td><td align="center">必须相同</td></tr><tr><td align="center">返回类型</td><td align="center">可以不同</td><td align="center">子类方法的返回类型可以是原父类方法返回类型的子类型</td></tr><tr><td align="center">访问修饰符</td><td align="center">可以不同</td><td align="center">子类不能做更严格的限制（可以降低限制）</td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_LWe7" id="main-方法是否可以重载">main 方法是否可以重载<a href="#main-方法是否可以重载" class="hash-link" aria-label="main 方法是否可以重载的直接链接" title="main 方法是否可以重载的直接链接">​</a></h4><p>IBM 早些年出过这方面的题，考倒了一片人。首先，答案是肯定的，main 既然作为一个方法，那它当然可以被重载。</p><p>但是，<strong>如果是作为程序的入口，那么 main 函数只有一种写法，Java 虚拟机在运行的时候只会调用带有参数是 String 数组的那个 <code>main()</code> 方法</strong>，而其他重载的写法虚拟机是不认的，只能人为的调用。</p><p>举个例子：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Test {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        main(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;重载的 main 方法&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该程序运行结果如下：</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">重载的 main 方法</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>可以看出第一个 main 方法正常调用了重载的第二个 main 方法，即 main 方法能够被完美重载。但是程序的入口仍然是第一个 main 方法即参数为 String 数组。</p><p><img loading="lazy" alt="image-20220618172317736" src="/Computer-Science-Learn-Notes/assets/images/image-20220618172317736-6dc744bd7ecf74e8c6854d501cba54a8.png" width="1389" height="586" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="构造器constructor是否可被重写override">构造器（constructor）是否可被重写（override）？<a href="#构造器constructor是否可被重写override" class="hash-link" aria-label="构造器（constructor）是否可被重写（override）？的直接链接" title="构造器（constructor）是否可被重写（override）？的直接链接">​</a></h3><p>构造器不能被继承，因此不能被重写，但可以被重载</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-中操作字符串都有哪些类它们之间有什么区别">Java 中操作字符串都有哪些类？它们之间有什么区别？<a href="#java-中操作字符串都有哪些类它们之间有什么区别" class="hash-link" aria-label="Java 中操作字符串都有哪些类？它们之间有什么区别？的直接链接" title="Java 中操作字符串都有哪些类？它们之间有什么区别？的直接链接">​</a></h3><p>操作字符串的类有：<strong>String、StringBuffer、StringBuilder</strong>。</p><p>第一点: 可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。</p><p>第二点: 线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高</p><table><thead><tr><th align="center"></th><th align="center">可变性</th><th>线程安全</th></tr></thead><tbody><tr><td align="center">String</td><td align="center">不可变</td><td>因为不可变，所以是线程安全的</td></tr><tr><td align="center">StringBuffer</td><td align="center">可变</td><td>线程安全的，因为其内部大多数方法都使用 <code>synchronized</code>进行同步。其效率较低</td></tr><tr><td align="center">StringBuilder</td><td align="center">可变</td><td>不是线程安全的，因为没有使用 <code>synchronized</code>进行同步，这也是其效率高于 StringBuffer  的原因。单线程下，优先考虑使用 StringBuilder。</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_LWe7" id="string-str--i-和string-str--new-string1样吗">String str = &quot;i&quot; 和String str = new String(&quot;1&quot;)⼀样吗？<a href="#string-str--i-和string-str--new-string1样吗" class="hash-link" aria-label="String str = &quot;i&quot; 和String str = new String(&quot;1&quot;)⼀样吗？的直接链接" title="String str = &quot;i&quot; 和String str = new String(&quot;1&quot;)⼀样吗？的直接链接">​</a></h3><p>不⼀样，因为内存的分配⽅式不⼀样。String str=&quot;i&quot;的⽅式，JVM会将其分配到常量池中；⽽String str=new String(&quot;i&quot;)，JVM会将其分配到堆内存中。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是序列化反序列化">什么是序列化反序列化?<a href="#什么是序列化反序列化" class="hash-link" aria-label="什么是序列化反序列化?的直接链接" title="什么是序列化反序列化?的直接链接">​</a></h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p><p>维基百科是如是介绍序列化的：</p><blockquote><p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><p><img loading="lazy" alt="image-20220620170922943" src="/Computer-Science-Learn-Notes/assets/images/image-20220620170922943-af5d74254abfcdba3be299112637f807.png" width="664" height="266" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="final-finally-finalize的区别">final finally finalize的区别<a href="#final-finally-finalize的区别" class="hash-link" aria-label="final finally finalize的区别的直接链接" title="final finally finalize的区别的直接链接">​</a></h3><ul><li>final可以修饰类、变量、⽅法，修饰类表示该类不能被继承、修饰⽅法表示该⽅法不能被重写、修饰变量表示该变量是⼀个常量不能被重新赋值。</li><li>finally⼀般作⽤在try-catch代码块中，在处理异常的时候，通常我们将⼀定要执⾏的代码⽅法finally代码块中，表示不管是否出现异常，该代码块都会执⾏，⼀般⽤来存放⼀些关闭资源的代码。</li></ul><blockquote><p>⚠️特殊情况：当finally中包含return</p><p><img loading="lazy" alt="image-20220619143704353" src="/Computer-Science-Learn-Notes/assets/images/image-20220619143704353-33943320acb5bbba06a10e8ca8f739fb.png" width="850" height="530" class="img_ev3q"></p></blockquote><ul><li>finalize是⼀个⽅法，属于Object类的⼀个⽅法，⽽Object类是所有类的⽗类，该⽅法⼀般由垃圾回收器来调⽤，当我们调⽤System.gc()⽅法的时候，由垃圾回收器调⽤finalize()，回收垃圾，⼀个对象是否可回收的最后判断。</li></ul><blockquote><p>⚠️注：</p><ul><li>Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</li><li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 <code>finalize( )</code> 方法。</li><li><code>finalize( )</code> 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li><li><strong>永远不要主动调用某个对象的 finalize ( ) 方法，应该交给垃圾回收机制调用</strong>。理由包括下面三点：<ul><li>在 <code>finalize( )</code> 执行时可能会导致对象复活。</li><li><code>finalize( )</code> 方法的执行时间是没有保障的，它完全由 GC 线程决定，极端情况下，若不发生 GC，则 <code>finalize( )</code> 方法将没有执行机会。</li><li>一个糟糕的 <code>finalize( )</code> 会严重影响 GC 的性能。</li></ul></li><li>从功能上来说，<code>finalize( )</code> 方法与 C++ 中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以 <code>finalize( )</code> 方法在本质上不同于 C++ 中的析构函数。</li><li>由于 <code>finalize( )</code> 方法的存在，虚拟机中的对象一般处于三种可能的状态</li></ul></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="java有哪些数据类型">⭐Java有哪些数据类型<a href="#java有哪些数据类型" class="hash-link" aria-label="⭐Java有哪些数据类型的直接链接" title="⭐Java有哪些数据类型的直接链接">​</a></h3><ul><li>🔢 数值：byte，short，int，long</li><li>🧿 浮点：float，double</li><li>🔣 字符：char</li><li>☑️ 布尔：boolean</li></ul><p>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="基本类型和包装类型的区别">基本类型和包装类型的区别？<a href="#基本类型和包装类型的区别" class="hash-link" aria-label="基本类型和包装类型的区别？的直接链接" title="基本类型和包装类型的区别？的直接链接">​</a></h4><ul><li>包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>⚠️注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class BasicTypeVar{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="包装类型的缓存机制了解么">包装类型的缓存机制了解么？<a href="#包装类型的缓存机制了解么" class="hash-link" aria-label="包装类型的缓存机制了解么？的直接链接" title="包装类型的缓存机制了解么？的直接链接">​</a></h4><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="️占用的空间大小">⭐️占用的空间大小<a href="#️占用的空间大小" class="hash-link" aria-label="⭐️占用的空间大小的直接链接" title="⭐️占用的空间大小的直接链接">​</a></h4><p>👨‍💻面试官 ： 它们的默认值和占用的空间大小知道不？</p><p>🙋 我 ：这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>int</td><td>32</td><td>4</td><td>0</td></tr><tr><td>short</td><td>16</td><td>2</td><td>0</td></tr><tr><td>long</td><td>64</td><td>8</td><td>0L</td></tr><tr><td>byte</td><td>8</td><td>1</td><td>0</td></tr><tr><td>char</td><td>16</td><td>2</td><td>&#x27;u0000&#x27;</td></tr><tr><td>float</td><td>32</td><td>4</td><td>0f</td></tr><tr><td>double</td><td>64</td><td>8</td><td>0d</td></tr><tr><td>boolean</td><td>1</td><td></td><td>false</td></tr></tbody></table><p>另外，对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="java-中-boolean-占多少字节">Java 中 boolean 占多少字节？<a href="#java-中-boolean-占多少字节" class="hash-link" aria-label="Java 中 boolean 占多少字节？的直接链接" title="Java 中 boolean 占多少字节？的直接链接">​</a></h4><p>Oracle 官方文档地址在此：<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html</a></p><p><img loading="lazy" alt="img" src="/Computer-Science-Learn-Notes/assets/images/image-20220706230119388-986cd1ee7a59beea9ee9c98b854d80fe.png" width="1284" height="989" class="img_ev3q"></p><p>总共 8 大基础数据类型，其余 7 个都非常明确的标明了占用多少字节，只有 boolean 模棱两可：</p><blockquote><p><strong>boolean</strong>: The <code>boolean</code> data type has only two possible values: <code>true</code> and <code>false</code>. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its &quot;size&quot; isn&#x27;t something that&#x27;s precisely defined.</p></blockquote><p>翻译下划线部分：这个数据类型表示 1 bit 的信息（true or false，编译后用 0 或 1 来表示），但是它的 size 并没有被精确地定义。也就是说，<strong>不管它占多大的空间，只有 1 个 bit 的信息是有意义的。</strong></p><p>事实上，boolean 到底占用多少大小的空间，“It&#x27;s virtual machine dependent.”，<strong>完全取决于 Java 虚拟机本身的设计</strong>。</p><p>不过显然 boolean 是肯定不可能只占用 1 个 bit 的，最起码也是 1 个 Bytes（字节），因为计算机处理数据的最小单位是 1 个字节</p><p>《Java 虚拟机规范》对于 boolean 到底占用多少空间提供了一定的建议（只是建议，具体的实现仍然取决于每个虚拟机是否按照规范来），官方文档在这里：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.4" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.4</a></p><blockquote><p>Although the Java Virtual Machine defines a <code>boolean</code> type, it only provides very limited support for it. There are no Java Virtual Machine instructions solely dedicated to operations on <code>boolean</code> values. Instead, expressions in the Java programming language that operate on <code>boolean</code> values are compiled to use values of the Java Virtual Machine <code>int</code> data type.</p></blockquote><p>尽管 Java 虚拟机定义了一个布尔类型，但是它只提供了非常有限的支持，<strong>并【没有】专门用于对【boolean 值】进行操作的 Java 虚拟机指令</strong>。相反，<strong>Java 中操作 boolean 值的表达式被编译为使用 int 数据类型的值</strong>。</p><blockquote><p>The Java Virtual Machine does directly support <code>boolean</code> arrays. Its <code>newarray</code> instruction (<code>newarray</code>) enables creation of <code>boolean</code> arrays. Arrays of type <code>boolean</code> are accessed and modified using the <code>byte</code> array instructions <code>baload</code> and <code>bastore</code>.</p></blockquote><p>不过，<strong>Java 虚拟机【直接支持】【boolean 数组】</strong>，通过 <code>newarray</code> 指令创建 boolean 数组，然后通过 byte 数组指令 <code>baload</code> 和 <code>bastore</code> 来访问和修改 boolean 数组。</p><ul><li><code>newarray</code> 指令：Create new array</li><li><code>baload</code> 指令：Load <code>byte</code> or <code>boolean</code> from array</li><li><code>bastore</code> 指令：Store into <code>byte</code> or <code>boolean</code> array</li></ul><blockquote><p>In Oracle’s Java Virtual Machine implementation, <code>boolean</code> arrays in the Java programming language are encoded as Java Virtual Machine <code>byte</code> arrays, using 8 bits per <code>boolean</code> element.</p></blockquote><p><strong>在 Oracle 的 Java 虚拟机实现中，Java 中的 boolean 数组被编码为 byte 数组，每个 boolean 元素使用 1 字节（8 bit）</strong>。</p><p>总结下，Java 虚拟机规范提议：</p><ul><li>如果 boolean 是 “单独使用”：boolean 被编译为 int 类型，占 <strong>4</strong> 个字节</li><li>如果boolean 是以 “boolean 数组” 的形式使用：boolean 占 <strong>1</strong> 个字节，Java 虚拟机直接支持 boolean 数组，通过 <code>newarray</code> 指令创建 boolean 数组，然后通过 byte 数组指令 <code>baload</code> 和 <code>bastore</code> 来访问和修改 boolean 数组</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="float-f34是否正确">float f=3.4;是否正确？<a href="#float-f34是否正确" class="hash-link" aria-label="float f=3.4;是否正确？的直接链接" title="float f=3.4;是否正确？的直接链接">​</a></h3><p>不正确，赋值运算符 &quot;=&quot; 左右两边的精度类型不匹配。</p><p>Java中，有小数点的默认被存储为double类型，即双精度；而float类型的变量为单精度。</p><p>可以使用强转或加f，即 float f = (folat)3.4，float f = 3.4f。</p><p>测试：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float f = 3.14222222222222222222222;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    double d = 3.4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(d);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1.java:3: 错误: 不兼容的类型: 从double转换到float可能会有损失</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">float f = 3.14222222222222222222222;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ^</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1 个错误</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>拓展：Integer a = 1000，Integer b = 1000，a==b 的结果是什么？那如果 a，b 都为1，结果又是什么？</p></blockquote><p>Integer a = 1000，Integer b = 1000，a==b 结果为<strong>false</strong></p><p>Integer a = 1，Integer b = 1，a==b 结果为<strong>true</strong></p><p>这道题主要考察 Integer 包装类缓存的范围,<strong>在-128~127之间会缓存起来</strong>,比较的是直接缓存的数据,在此之外比较的是对象</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="成员变量与局部变量的区别有哪些">成员变量与局部变量的区别有哪些？<a href="#成员变量与局部变量的区别有哪些" class="hash-link" aria-label="成员变量与局部变量的区别有哪些？的直接链接" title="成员变量与局部变量的区别有哪些？的直接链接">​</a></h3><ol><li>从<strong>语法形式上</strong>看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而<strong>局部变量不能被访问控制修饰符及static所修饰</strong>；但是，成员变量和局部变量都能被final所修饰。</li><li>从变量<strong>在内存中的存储方式</strong>来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引用数据类型，那存放的是指向堆内存对象的引用或者是指向常量池中的地址。</li><li>从变量在<strong>内存中的生存时间上</strong>看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量<strong>如果没有被赋初值</strong>:则会自动以类型的默认值而赋值（一种情况例外:被final修饰的成员变量也必须显式地赋值），而<strong>局部变量则不会自动赋值</strong>。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="接口和抽象类的区别是什么">⭐接口和抽象类的区别是什么？<a href="#接口和抽象类的区别是什么" class="hash-link" aria-label="⭐接口和抽象类的区别是什么？的直接链接" title="⭐接口和抽象类的区别是什么？的直接链接">​</a></h3><ol><li>接口的方法默认是public，所有方法在接口中不能有实现(Java8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。</li><li>接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-泛型了解么泛型的作用什么是类型擦除">🌠Java 泛型了解么？泛型的作用？什么是类型擦除？<a href="#java-泛型了解么泛型的作用什么是类型擦除" class="hash-link" aria-label="🌠Java 泛型了解么？泛型的作用？什么是类型擦除？的直接链接" title="🌠Java 泛型了解么？泛型的作用？什么是类型擦除？的直接链接">​</a></h3><p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Persion&gt; persons = new ArrayList&lt;Persion&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Persion</code> 对象，如果传入其他类型的对象就会报错。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p><p>Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是<strong>在编译阶段会进行所谓的“类型擦除”（Type  Erasure）</strong>，将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。理解<strong>类型擦除</strong>对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。</p><p>泛型的类型擦除原则是：</p><ul><li>消除类型参数声明，即删除 <code>&lt;&gt;</code>及其包围的部分。</li><li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li><li>为了保证类型安全，必要时插入强制类型转换代码。</li><li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="擦除类定义中的类型参数">擦除类定义中的类型参数<a href="#擦除类定义中的类型参数" class="hash-link" aria-label="擦除类定义中的类型参数的直接链接" title="擦除类定义中的类型参数的直接链接">​</a></h4><p><strong>无限制类型擦除</strong>  当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如 <code>&lt;T&gt;</code>和 <code>&lt;?&gt;</code>的类型参数都被替换为Object</p><p><img loading="lazy" alt="image-20220617165626034" src="/Computer-Science-Learn-Notes/assets/images/image-20220617165626034-980e51661a65722c4f7b81d25db698ff.png" width="776" height="223" class="img_ev3q"></p><p><strong>有限制类型擦除</strong>  当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如 <code>&lt;T extends Number&gt;</code>和 <code>&lt;? extends Number&gt;</code>的类型参数被替换为Number，<code>&lt;? super  Number&gt;</code>被替换为Object</p><p><img loading="lazy" alt="image-20220617165706253" src="/Computer-Science-Learn-Notes/assets/images/image-20220617165706253-fedc019aa85142c42f9ae32c7510537d.png" width="822" height="236" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="擦除方法定义中的类型参数">擦除方法定义中的类型参数<a href="#擦除方法定义中的类型参数" class="hash-link" aria-label="擦除方法定义中的类型参数的直接链接" title="擦除方法定义中的类型参数的直接链接">​</a></h4><p>擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例</p><p><img loading="lazy" alt="image-20220617165721328" src="/Computer-Science-Learn-Notes/assets/images/image-20220617165721328-0096a7357643f66a08456a7414160f0f.png" width="982" height="144" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="桥接方法和泛型的多态">桥接方法和泛型的多态<a href="#桥接方法和泛型的多态" class="hash-link" aria-label="桥接方法和泛型的多态的直接链接" title="桥接方法和泛型的多态的直接链接">​</a></h4><p><a href="http://softlab.sdut.edu.cn/blog/subaochen/2017/01/generics-type-erasure/" target="_blank" rel="noopener noreferrer">http://softlab.sdut.edu.cn/blog/subaochen/2017/01/generics-type-erasure/</a></p><p>由于原文的篇幅过长，进行以下总结：</p><p>所谓的“桥接方法”（bridge method）来满足Java语法的要求，同时也保证了基于泛型的多态能够有效</p><p>运行的时候，会对 <code>Child</code>类的方法表进行搜索，先分析一下 <code>Child</code>类的方法表里有哪些东西：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. sayHello(Object value) : 从类型被擦除后的超类中继承过来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. sayHello(String value) : 自己新增的方法，和超类毫无联系</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="image-20220622211220694" src="/Computer-Science-Learn-Notes/assets/images/image-20220622211220694-09a7b561d63ba6af12c425ce5772ee2b.png" width="1124" height="561" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="为了更深层次的理解类型擦除选取了stackoverflow的高赞回答">为了更深层次的理解类型擦除，选取了Stackoverflow的高赞回答<a href="#为了更深层次的理解类型擦除选取了stackoverflow的高赞回答" class="hash-link" aria-label="为了更深层次的理解类型擦除，选取了Stackoverflow的高赞回答的直接链接" title="为了更深层次的理解类型擦除，选取了Stackoverflow的高赞回答的直接链接">​</a></h4><p>原帖：<a href="https://stackoverflow.com/questions/339699/java-generics-type-erasure-when-and-what-happens" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/339699/java-generics-type-erasure-when-and-what-happens</a></p><blockquote><p>😣问题是：<strong>When does type erasure occur?</strong> At compile time or runtime? When the class is loaded? When the class is instantiated?</p><p>类型擦除何时发生? 在编译时还是运行时? 当类被加载时? 当类被实例化时？</p></blockquote><p>🧐类型擦除适用于泛型的使用。类文件中肯定有元数据来说明方法/类型是否是泛型，以及约束是什么等等。但是当使用泛型时，它们被转换为编译时检查和执行时强制转换。所以这个代码：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list.add(&quot;Hi&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String x = list.get(0);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>被编译成</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">List list = new ArrayList();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list.add(&quot;Hi&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String x = (String) list.get(0);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在执行时，没有办法找出列表对象的 T = String 这个信息已经消失了。但是 List &lt; T &gt; 界面本身仍然宣称自己是通用的。</p><p>原帖：<a href="https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java</a></p><blockquote><p>😣What is the concept of erasure in generics in Java?</p><p>在 Java的类型擦除中，擦除的概念是什么？</p></blockquote><p>🧐这基本上是通过编译器技巧在 Java 中实现泛型的方式。编译后的泛型代码实际上只使用 java.lang。对象，而且有一些元数据（some metadata）可以告诉编译器它实际上是一个泛型类型。</p><p>当你针对一个泛型类型或方法编译一些代码时，编译器会计算出你的真正意思(例如 T 的类型参数是什么)  ，并在编译时验证你做的是正确的事情，但是发出的代码再次使用 java.lang。对象-编译器在必要时生成额外的强制转换。在执行时，List  &lt; String &gt; 和 List &lt; Date &gt; 完全相同; 编译器已经擦除了额外的类型信息。</p><p>比较一下 C # ，它在执行时保留信息，允许代码包含表达式，例如 typeof (T) ，它等价于 T  类——除非后者是无效的。(两者之间还有进一步的区别。NET 泛型和 Java 泛型，请注意。)在处理 Java  泛型时，类型擦除是许多“奇怪”警告/错误消息的来源。</p><blockquote><p>🥱再看一个这个回答的实战内容</p></blockquote><p>擦除，字面意思是从已编译的字节码中擦除源代码中存在的类型信息。让我们用一些代码来理解这一点。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.ArrayList;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Iterator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.List;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class GenericsErasure {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list.add(&quot;Hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Iterator&lt;String&gt; iter = list.iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(iter.hasNext()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String s = iter.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果您编译这段代码，然后用 Java 反编译器反编译它，您将得到类似下面的代码。注意，反编译的代码不包含原始源代码中显示的类型信息的跟踪。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.PrintStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class GenericsErasure</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public GenericsErasure()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List list = new ArrayList();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list.add(&quot;Hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(Iterator iter = list.iterator(); iter.hasNext(); System.out.println(s))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            s = (String)iter.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="-与-equals">⭐== 与 equals<a href="#-与-equals" class="hash-link" aria-label="⭐== 与 equals的直接链接" title="⭐== 与 equals的直接链接">​</a></h3><p>对于<strong>基本类型</strong>来说，== 比较的是值是否相等；</p><p>对于<strong>引用类型</strong>来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</p><p>equals ：用来比较两个对象的内容是否相等。注意：equals 方法不能用于比较基本数据类型的变量。如果没有对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址（很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等）</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashcode-与-equals">hashCode 与 equals<a href="#hashcode-与-equals" class="hash-link" aria-label="hashCode 与 equals的直接链接" title="hashCode 与 equals的直接链接">​</a></h3><ol><li>如果两个对象相等，则 hashcode 一定也是相同的</li><li>两个对象相等,对两个 equals() 方法返回 true</li><li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li><li>综上， equals() 方法被覆盖过，则 hashCode() 方法也必须被覆盖</li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode() ，则该class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何决定使用-hashmap-还是-treemap">如何决定使用 HashMap 还是 TreeMap？<a href="#如何决定使用-hashmap-还是-treemap" class="hash-link" aria-label="如何决定使用 HashMap 还是 TreeMap？的直接链接" title="如何决定使用 HashMap 还是 TreeMap？的直接链接">​</a></h3><p><code>TreeMap&lt;K,V&gt;</code>的Key值是要求实现java.lang.Comparable，所以迭代的时候TreeMap默认是按照Key值升序排序的；TreeMap的实现是基于红黑树结构。适用于按自然顺序或自定义顺序遍历键（key）。</p><p><code>HashMap&lt;K,V&gt;</code>的Key值实现散列hashCode()，分布是散列的、均匀的，不支持排序；数据结构主要是桶(数组)，链表或红黑树。适用于在Map中插入、删除和定位元素。</p><p><strong>结论</strong>
如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）。除此之外，由于HashMap有更好的性能，所以大多不需要排序的时候我们会使用HashMap。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashmap-的底层实现">⭐HashMap 的底层实现<a href="#hashmap-的底层实现" class="hash-link" aria-label="⭐HashMap 的底层实现的直接链接" title="⭐HashMap 的底层实现的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="jdk18-之前">JDK1.8 之前<a href="#jdk18-之前" class="hash-link" aria-label="JDK1.8 之前的直接链接" title="JDK1.8 之前的直接链接">​</a></h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash  判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key  是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    static final int hash(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      int h;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // key.hashCode()：返回散列值也就是hashcode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // ^ ：按位异或</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int hash(int h) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // This function ensures that hashCodes that differ only by</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // constant multiples at each bit position have a bounded</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // number of collisions (approximately 8 at default load factor).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img loading="lazy" alt="image-20220616155615352" src="/Computer-Science-Learn-Notes/assets/images/image-20220616155615352-70a0ed466467a2a2ac53060070deeb98.png" width="1024" height="803" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="jdk18-之后">JDK1.8 之后<a href="#jdk18-之后" class="hash-link" aria-label="JDK1.8 之后的直接链接" title="JDK1.8 之后的直接链接">​</a></h4><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><img loading="lazy" alt="image-20220616155623710" src="/Computer-Science-Learn-Notes/assets/images/image-20220616155623710-17feccbb3f3d609500d6df964f31b541.png" width="1024" height="656" class="img_ev3q"></p><blockquote><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><blockquote><p>面试可以这样回答：hashmap的底层是哈希表，是基于hash算法实现的，hashmap通过put(key,value)存储，通过get(key)获取，当传入key时，hashmap会调用key.hashcode()方法计算出hash值，根据 hash 值将 value 保存在 bucket 里。当计算</p><p>出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的value。当 hash 冲突的个数少于等于8个时，使用链表否则使用红黑树。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashmap源码分析">⭐HashMap源码分析<a href="#hashmap源码分析" class="hash-link" aria-label="⭐HashMap源码分析的直接链接" title="⭐HashMap源码分析的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="get">get()<a href="#get" class="hash-link" aria-label="get()的直接链接" title="get()的直接链接">​</a></h4><p><code>get(Object key)</code>方法根据指定的 <code>key</code>值返回对应的 <code>value</code>，该方法调用了 <code>getEntry(Object key)</code>得到相应的 <code>entry</code>，然后返回 <code>entry.getValue()</code>。因此 <code>getEntry()</code>是算法的核心。 <strong>算法思想</strong>是首先通过 <code>hash()</code>函数得到对应 <code>bucket</code>的下标，然后依次遍历冲突链表，通过 <code>key.equals(k)</code>方法来判断是否是要找的那个 <code>entry</code>。</p><p><img loading="lazy" alt="image-20220616161400630" src="/Computer-Science-Learn-Notes/assets/images/image-20220616161400630-d1aa16921617e96e3432398fa596fa41.png" width="1200" height="947" class="img_ev3q"></p><p>上图中 <code>hash(k)&amp;(table.length-1)</code>等价于 <code>hash(k)%table.length</code>，原因是<em>HashMap</em>要求 <code>table.length</code>必须是2的指数，因此 <code>table.length-1</code>就是二进制低位全是1，跟 <code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//getEntry()方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final Entry&lt;K,V&gt; getEntry(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = (key == null) ? 0 : hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-1)];//得到冲突链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         e != null; e = e.next) {//依次遍历冲突链表中的每个entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //依据equals()方法判断是否相等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="put">put()<a href="#put" class="hash-link" aria-label="put()的直接链接" title="put()的直接链接">​</a></h4><p><code>put(K key, V value)</code>方法是将指定的 <code>key, value</code>对添加到 <code>map</code>里。该方法首先会对 <code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于 <code>getEntry()</code>方法；如果没有找到，则会通过 <code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的 <code>entry</code>，插入方式为<strong>头插法</strong>。</p><p><img loading="lazy" alt="image-20220616161439305" src="/Computer-Science-Learn-Notes/assets/images/image-20220616161439305-f81e78a0c273abeb50e18d38d364841b.png" width="1200" height="1002" class="img_ev3q"></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//addEntry()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void addEntry(int hash, K key, V value, int bucketIndex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resize(2 * table.length);//自动扩容，并重新哈希</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hash = (null != key) ? hash(key) : 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bucketIndex = hash &amp; (table.length-1);//hash%table.length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //在冲突链表头部插入新的entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    size++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="remove">remove()<a href="#remove" class="hash-link" aria-label="remove()的直接链接" title="remove()的直接链接">​</a></h4><p><code>remove(Object key)</code>的作用是删除 <code>key</code>值对应的 <code>entry</code>，该方法的具体逻辑是在 <code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到 <code>key</code>值对应的 <code>entry</code>，然后删除该 <code>entry</code>(修改链表的相应引用)。查找过程跟 <code>getEntry()</code>过程类似。</p><p><img loading="lazy" alt="image-20220616161551183" src="/Computer-Science-Learn-Notes/assets/images/image-20220616161551183-8fb5d2124ae769daeab75166b75179a9.png" width="1300" height="1033" class="img_ev3q"></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//removeEntryForKey()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final Entry&lt;K,V&gt; removeEntryForKey(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = (key == null) ? 0 : hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i = indexFor(hash, table.length);//hash&amp;(table.length-1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry&lt;K,V&gt; prev = table[i];//得到冲突链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry&lt;K,V&gt; e = prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (e != null) {//遍历冲突链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Entry&lt;K,V&gt; next = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {//找到要删除的entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            modCount++; size--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else prev.next = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prev = e; e = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashmap-的长度为什么是-2-的幂次方">HashMap 的长度为什么是 2 的幂次方<a href="#hashmap-的长度为什么是-2-的幂次方" class="hash-link" aria-label="HashMap 的长度为什么是 2 的幂次方的直接链接" title="HashMap 的长度为什么是 2 的幂次方的直接链接">​</a></h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash  值的范围值-2147483648 到 2147483647，前后加起来大概 40  亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40  亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p><p>🙋‍♂️笔者认为Guide写的这个摸棱两可，所以找了一个StackOverFlow中描述更为清楚的翻译为下：</p><blockquote><p>🧚‍♂️原帖：<a href="https://stackoverflow.com/questions/53526790/why-are-hashmaps-implemented-using-powers-of-two" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/53526790/why-are-hashmaps-implemented-using-powers-of-two</a></p><p>当你从一个幂为2的数字中减去1得到的是一个二进制表示都是1的数字。例如16是2的幂。如果从中减去1，得到15，它的二进制表示是1111。现在，如果你用1111对任何一个数字进行位 AND  运算，你将得到这个数字的最后4位，换句话说，它等于这个数字乘以16的模(除法运算通常是一个昂贵的运算。因此，位操作通常比除法更受欢迎)。最后的4位将计算为0到15之间的任意数字，这些数字是基础数组的索引。</p><p>你可以改成17。在这种情况下，从中减去1得到16也就是二进制的10000。现在你对一个16的数做 AND（与&amp;）  运算，你会失去所有的位，除了从结尾开始的第5位。因此，无论取多少数，数组索引都是16或0。这意味着会有很多冲突，这反过来又意味着性能很差。您将需要 O (log n)而不是 O  (1)进行检索，因为当冲突发生时，给定桶中的所有节点都将存储在一个红黑色树中。不仅如此。如果您在一个多线程环境中使用  ConcurrentHashMap，那么您将经历大量的同步，因为所有新添加的内容最终都会以非常少的存储桶(在上述情况下只有2-0和16个)结束，并且当您在一个已经有其他节点的存储桶中添加新节点时，存储桶将被锁定，以避免由于多个线程的修改而导致的数据不一致。因此，尝试添加新节点的其他线程需要等待当前线程释放锁。</p><p>最后，我还应该提到，Java HashMap 实现还将键的哈希代码的16位向右移动，并在用(length-1)进行位 AND 之前对原哈希代码进行位异或操作，以确保高阶位的效果也被捕获。</p><p>因此，基本上要点是，如果大小是2的幂次方，那么与其他任何不是2的大小相比，键将更均匀地分布在整个数组中，最小的冲突将导致更好的检索性能(在ConcurrentHashMap 的情况下也更少的同步)。</p></blockquote><p>为什么能减少碰撞？这是因为hashmap的hash值是hashCode右移16位得到的，这么做使得hash值的低位保留了高位的信息，所以只要低位就可以了。</p><p>一句话，HashMap的长度为2的幂次方的原因是为了减少Hash碰撞，尽量使Hash算法的结果均匀分布。（只有当长度是2^n时，长度-1的二进制低位才全部是1）</p><blockquote><p>实际场景可以这样回答</p></blockquote><p>Hash 值的范围值比较大，使用之前需要先对数组的长度取模运算，得到的余数才是元素存放的位置也就是对应的数组下标。</p><p>这个数组下标的计算方法是 <code>(n - 1) &amp; hash</code></p><p>将HashMap的长度定为2 的幂次方，这样就可以使用 <code>(n - 1)&amp;hash</code>位运算代替%取余的操作，提高性能。</p><blockquote><p>拓展：<strong>HashMap默认加载因子为什么选择0.75呢？</strong></p></blockquote><p>0.75是对<strong>空间和时间效率</strong>的一个平衡选择，根据泊松分布，loadFactor 取0.75碰撞最小。一般不会修改，除非在时间和空间比较特殊的情况下 ：</p><ul><li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。</li><li>如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashmap-多线程操作导致死循环问题">HashMap 多线程操作导致死循环问题<a href="#hashmap-多线程操作导致死循环问题" class="hash-link" aria-label="HashMap 多线程操作导致死循环问题的直接链接" title="HashMap 多线程操作导致死循环问题的直接链接">​</a></h3><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用  HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener noreferrer">https://coolshell.cn/articles/9606.html</a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="为什么hashmap线程不安全">为什么HashMap线程不安全<a href="#为什么hashmap线程不安全" class="hash-link" aria-label="为什么HashMap线程不安全的直接链接" title="为什么HashMap线程不安全的直接链接">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="put的时候导致的多线程数据不一致">put的时候导致的多线程数据不一致<a href="#put的时候导致的多线程数据不一致" class="hash-link" aria-label="put的时候导致的多线程数据不一致的直接链接" title="put的时候导致的多线程数据不一致的直接链接">​</a></h5><p>这个问题比较好想象，比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="get操作可能因为resize而引起死循环">get操作可能因为resize而引起死循环<a href="#get操作可能因为resize而引起死循环" class="hash-link" aria-label="get操作可能因为resize而引起死循环的直接链接" title="get操作可能因为resize而引起死循环的直接链接">​</a></h5><p>见上一个问题的回答</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么java只有值传递">为什么Java只有值传递<a href="#为什么java只有值传递" class="hash-link" aria-label="为什么Java只有值传递的直接链接" title="为什么Java只有值传递的直接链接">​</a></h3><p>个人理解，不管在方法中如何调用都是只拷贝。例如（int a, int b）就是拷贝传入的值到另外一个地址；如果传入的是（int[] arr）或者（Integer a）则就是拷贝这个的地址到另外一个地址，实质上两个（原值和拷贝的地址）都指向同一个地址。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="异常处理总结">异常处理总结<a href="#异常处理总结" class="hash-link" aria-label="异常处理总结的直接链接" title="异常处理总结的直接链接">​</a></h3><p>finally 块不会被执行：</p><ol><li>在 try 或 finally 块中用了 System.exit(int) 退出程序。但是，如果 System.exit(int) 在异常
语句之后， finally 还是会被执行</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190%E3%80%82" target="_blank" rel="noopener noreferrer">https://github.com/Snailclimb/JavaGuide/issues/190。</a>
<strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static int f(int value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value * value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (value == 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>《java核心技术卷一》中提到过：当finally子句包含return 语句时（当然在设计原则上是不允许在finally块中抛出异常或者 执行return语句的），将会出现一种意想不到的结果。假设利用return语句从try 语句块中退出。在方法返回前，finally子句的内容将被执行。如果finally子句中也有一个return语句，这个返回值将会覆盖原始的返回值。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="有哪些常见的-io-模型">有哪些常见的 IO 模型?<a href="#有哪些常见的-io-模型" class="hash-link" aria-label="有哪些常见的 IO 模型?的直接链接" title="有哪些常见的 IO 模型?的直接链接">​</a></h3><p>UNIX 系统下， IO 模型一共有 5 种： 同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="阻塞式-io">阻塞式 I/O<a href="#阻塞式-io" class="hash-link" aria-label="阻塞式 I/O的直接链接" title="阻塞式 I/O的直接链接">​</a></h4><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。 应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。 下图中，recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p><p><img loading="lazy" alt="image-20220628221701308" src="/Computer-Science-Learn-Notes/assets/images/image-20220628221701308-e5074ac0a97f66b96def683a6aa26356.png" width="981" height="367" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="非阻塞式-io">非阻塞式 I/O<a href="#非阻塞式-io" class="hash-link" aria-label="非阻塞式 I/O的直接链接" title="非阻塞式 I/O的直接链接">​</a></h4><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。</p><p>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。</p><p><img loading="lazy" alt="image-20220628221710263" src="/Computer-Science-Learn-Notes/assets/images/image-20220628221710263-1896b952b9f0a38eea9228159a148905.png" width="998" height="488" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="io-复用">I/O 复用<a href="#io-复用" class="hash-link" aria-label="I/O 复用的直接链接" title="I/O 复用的直接链接">​</a></h4><p><strong>使用 select 或者 poll 等待数据</strong>，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。</p><p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p><p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p><p><img loading="lazy" alt="image-20220628221721484" src="/Computer-Science-Learn-Notes/assets/images/image-20220628221721484-abd804d3964d3d44cdb40a289dcb0fc6.png" width="1105" height="393" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="信号驱动-io">信号驱动 I/O<a href="#信号驱动-io" class="hash-link" aria-label="信号驱动 I/O的直接链接" title="信号驱动 I/O的直接链接">​</a></h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p><p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p><p><img loading="lazy" alt="image-20220628221734114" src="/Computer-Science-Learn-Notes/assets/images/image-20220628221734114-9c62d34198beb2919e2585a736084b5f.png" width="996" height="381" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="异步-io">异步 I/O<a href="#异步-io" class="hash-link" aria-label="异步 I/O的直接链接" title="异步 I/O的直接链接">​</a></h4><p>进行 aio_read（asynchronous read） 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><p><img loading="lazy" alt="image-20220628221741472" src="/Computer-Science-Learn-Notes/assets/images/image-20220628221741472-be74f218247a8159e7121d7d6a5f93ac.png" width="949" height="402" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="bionioaio-有什么区别">⭐BIO,NIO,AIO 有什么区别<a href="#bionioaio-有什么区别" class="hash-link" aria-label="⭐BIO,NIO,AIO 有什么区别的直接链接" title="⭐BIO,NIO,AIO 有什么区别的直接链接">​</a></h3><p><img loading="lazy" alt="image-20220615203937591" src="/Computer-Science-Learn-Notes/assets/images/image-20220615203937591-98f0a351876be0a755098d81c64e5766.png" width="928" height="340" class="img_ev3q"></p><blockquote><p>Java BIO<!-- -->[Blocking I/O]<!-- --> | 同步阻塞I/O模式</p></blockquote><p><img loading="lazy" alt="image-20220731160638775" src="/Computer-Science-Learn-Notes/assets/images/image-20220731160638775-e4e831165406af3377ee7733ea02a09b.png" width="780" height="400" class="img_ev3q"></p><p>BIO 全称Block-IO 是一种同步且阻塞的通信模式。是一个比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速</p><blockquote><p>Java NIO<!-- -->[New I/O]<!-- --> | 同步非阻塞模式</p></blockquote><p><img loading="lazy" alt="image-20220731160650184" src="/Computer-Science-Learn-Notes/assets/images/image-20220731160650184-7e56fd3d859244444aa795bbb95000e8.png" width="786" height="355" class="img_ev3q"></p><p>可以看美团技术团队2016年写的文章：<a href="https://tech.meituan.com/2016/11/04/nio.html" target="_blank" rel="noopener noreferrer">Java NIO浅析</a></p><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了Java NIO的实现主要涉及三大核心内容： <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。Selector用于监听多个Channel的事件，比如连接打开或数据到达，因此，一个线程可以实现对多个数据Channel的管理。传统I/O基于数据流进行I/O读写操作；而Java NIO基于Channel和Buffer进行I/O读写操作，并且数据总是被从Channel读取到Buffer中，或者从Buffer写入Channel中。</p><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p><img loading="lazy" alt="image-20220615204150338" src="/Computer-Science-Learn-Notes/assets/images/image-20220615204150338-6d258877399bf83a72af79d1ede2c4ac.png" width="578" height="664" class="img_ev3q"></p><p>同步非阻塞 IO 模型中，应用程序会<strong>一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间</strong>。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p><p><img loading="lazy" alt="image-20220615204200618" src="/Computer-Science-Learn-Notes/assets/images/image-20220615204200618-d98590742a42f38832e0d1cbaf9a7eb1.png" width="588" height="570" class="img_ev3q"></p><p>IO 多路复用模型中，线程<strong>首先发起 select 调用，询问内核数据是否准备就绪</strong>，等内核把数据准备好了，用户线程再发起 read 调用。<strong>read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的</strong>。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><p><img loading="lazy" alt="image-20220615204212255" src="/Computer-Science-Learn-Notes/assets/images/image-20220615204212255-474072b09a87b1c25fac090ba21ef211.png" width="2384" height="1686" class="img_ev3q"></p><blockquote><p>Java AIO<!-- -->[Asynchronous I/O]<!-- --> | 异步非阻塞I/O模型</p></blockquote><p><img loading="lazy" alt="image-20220731160701735" src="/Computer-Science-Learn-Notes/assets/images/image-20220731160701735-ef5235ecdae1fd3392e8134a4ccff9b1.png" width="816" height="446" class="img_ev3q"></p><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><img loading="lazy" alt="image-20220615205139466" src="/Computer-Science-Learn-Notes/assets/images/image-20220615205139466-f2740af44dad3e35749f20785f4a1525.png" width="570" height="660" class="img_ev3q"></p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p><p><img loading="lazy" alt="image-20220615205148242" src="/Computer-Science-Learn-Notes/assets/images/image-20220615205148242-dcf9c4a48c52aca6b592871a69c1412a.png" width="1184" height="1124" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="java集合类框架的基本接口有哪些">⭐Java集合类框架的基本接口有哪些？<a href="#java集合类框架的基本接口有哪些" class="hash-link" aria-label="⭐Java集合类框架的基本接口有哪些？的直接链接" title="⭐Java集合类框架的基本接口有哪些？的直接链接">​</a></h3><p>Java中的集合分为value（Conllection），key-value(Map)两种存储结构</p><blockquote><p>存储value有分为List 、Set、Queue</p></blockquote><p>List：有序，可存储重复元素</p><p>Set：无序，元素不可重复。根据equals和hashcode判断（如果一个对象要存储在Set中，必须重写equals和hashCode方法）</p><p>Queue：队列</p><blockquote><p>存储key-value的为map</p></blockquote><p><img loading="lazy" alt="image-20220609215207876" src="/Computer-Science-Learn-Notes/assets/images/image-20220609215207876-d65310c7d587f2907b6ca24c94dfc67d.png" width="984" height="521" class="img_ev3q"></p><p><img loading="lazy" alt="image-20220609215218381" src="/Computer-Science-Learn-Notes/assets/images/image-20220609215218381-7f74cb7a1969614c73e06a135ecea206.png" width="974" height="532" class="img_ev3q"></p><p><img loading="lazy" alt="image-20220609215224938" src="/Computer-Science-Learn-Notes/assets/images/image-20220609215224938-b325d371c559eee3193eba9b0b847470.png" width="1063" height="505" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="-arraylist-与-linkedlist-区别">⭐ Arraylist 与 LinkedList 区别<a href="#-arraylist-与-linkedlist-区别" class="hash-link" aria-label="⭐ Arraylist 与 LinkedList 区别的直接链接" title="⭐ Arraylist 与 LinkedList 区别的直接链接">​</a></h3><ol><li><strong>是否保证线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构</strong>： Arraylist 底层使用的是 Object 数组； LinkedList 底层使用的是 双向链表数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响</strong>：①ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。比如：执行add(Ee)方法的时候，ArrayList会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置i插入和删除元素的话（add(intindex,Eelement)）时间复杂度就为O(n-i)。因为在进行上述操作的时候集合中第i和第i个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。②LinkedList采用链表存储，所以对于add(Ee)方法的插入，删除元素时间复杂度不受元素位置的影响，近似O(1)，如果是要在指定位置i插入和删除元素的话（(add(intindex,Eelement)）时间复杂度近似为o(n))因为需要先移动到指定位置再插入。</li><li><strong>是否支持快速随机访问</strong>：LinkedList不支持高效的随机元素访问，而ArrayList支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(intindex)方法)。</li><li><strong>内存空间占用</strong>：ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashmap和hashtable有什么区别">HashMap和HashTable有什么区别<a href="#hashmap和hashtable有什么区别" class="hash-link" aria-label="HashMap和HashTable有什么区别的直接链接" title="HashMap和HashTable有什么区别的直接链接">​</a></h3><ol><li><strong>HashMap</strong>可以接受为null的key和value，key为null的键值对放在下标为0的头结点的链表中，而<strong>Hashtable</strong>则不行。</li><li>HashMap是<strong>非线程安全</strong>的，HashTable是线程安全的。Jdk1.5提供了<strong>ConcurrentHashMap</strong>，它是HashTable的替代。</li><li><strong>Hashtable</strong>很多方法是<strong>同步</strong>方法，在单线程环境下它比HashMap要慢。</li><li><strong>哈希值的使用</strong>不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="concurrenthashmap-和-hashtable-的区别">ConcurrentHashMap 和 Hashtable 的区别<a href="#concurrenthashmap-和-hashtable-的区别" class="hash-link" aria-label="ConcurrentHashMap 和 Hashtable 的区别的直接链接" title="ConcurrentHashMap 和 Hashtable 的区别的直接链接">​</a></h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><p>底层数据结构：JDK1.7的 <code>ConcurrentHashMap</code>底层采用<strong>分段的数组+链表</strong>实现，JDK1.8采用的数据结构跟 <code>HashMap1.8</code>的结构一样，<strong>数组+链表/红黑二叉树</strong>。<code>Hashtable</code>和JDK1.8之前的 <code>HashMap</code>的底层数据结构类似都是采用数组+链表的形式，数组是 <code>HashMap</code>的主体，链表则是主要为了解决哈希冲突而存在的；</p><p>实现线程安全的方式（重要）：</p><ol><li>在JDK1.7的时候，ConcurrentHashMap（分段锁）对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。到了JDK1.8的时候已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用synchronized和CAS来操作。（JDK1.6以后对synchronized锁做了很多优化）整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li><li>HashTable和HashMap的实现原理几乎一样，差别无非是<strong>1.HashTable不允许key和value为null；2.HashTable是线程安全的。</strong>但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把<strong>大锁</strong>，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作<strong>串行化</strong>，在竞争激烈的并发场景中性能就会非常差。</li></ol><p><img loading="lazy" alt="image-20220606221411976" src="/Computer-Science-Learn-Notes/assets/images/image-20220606221411976-bee3f7e7b99a5c4e5a7cd3d710894095.png" width="1692" height="1264" class="img_ev3q"></p><p>JDK1.7 的 ConcurrentHashMap：</p><p><img loading="lazy" alt="image-20220606221435298" src="/Computer-Science-Learn-Notes/assets/images/image-20220606221435298-5ba5fd476d47e786d1cdf0adbbc2f160.png" width="1798" height="944" class="img_ev3q"></p><p>JDK1.8 的 ConcurrentHashMap：
JDK1.8 的 ConcurrentHashMap 不在是 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode 。当冲突链表达到一定⻓度时，链表会转换成红黑树。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="concurrenthashmap线程安全的具体实现方式底层具体实现">⭐ConcurrentHashMap线程安全的具体实现方式/底层具体实现<a href="#concurrenthashmap线程安全的具体实现方式底层具体实现" class="hash-link" aria-label="⭐ConcurrentHashMap线程安全的具体实现方式/底层具体实现的直接链接" title="⭐ConcurrentHashMap线程安全的具体实现方式/底层具体实现的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="jdk17">JDK1.7<a href="#jdk17" class="hash-link" aria-label="JDK1.7的直接链接" title="JDK1.7的直接链接">​</a></h4><p><img loading="lazy" alt="image-20220606221435298" src="/Computer-Science-Learn-Notes/assets/images/image-20220606221435298-5ba5fd476d47e786d1cdf0adbbc2f160.png" width="1798" height="944" class="img_ev3q"></p><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><code>ConcurrentHashMap</code> 是由 <code>Segment </code>数组结构和 <code>HashEntry</code> 数组结构组成。</p><p>Segment实现了ReentrantLock,所以Segment是一种可重入锁，扮演锁的⻆色。HashEntry用于存储键值对数据。</p><div class="language-JAVA codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-JAVA codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>一个 <code>ConcurrentHashMap</code>里包含一个 <code>Segment</code>数组。<code>Segment</code>的结构和 <code>HashMap</code>类似，是一种数组和链表结构，一个 <code>Segment</code>包含一个 <code>HashEntry</code>数组，每个 <code>HashEntry</code>是一个链表结构的元素，每个Segment守护着一个 <code>HashEntry</code>数组里的元素，当对 <code>HashEntry</code>数组的数据进行修改时，必须首先获得对应的Segment的锁。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="jdk18">JDK1.8<a href="#jdk18" class="hash-link" aria-label="JDK1.8的直接链接" title="JDK1.8的直接链接">​</a></h4><p><img loading="lazy" alt="image-20220606222144072" src="/Computer-Science-Learn-Notes/assets/images/image-20220606222144072-912b75191c6b944050e9825dae1f55c1.png" width="732" height="276" class="img_ev3q"></p><p><code>ConcurrentHashMap</code>取消了Segment分段锁，采用 <code>CAS</code>和 <code>synchronized</code>来保证并发安全。数据结构跟 <code>HashMap1.8</code>的结构类似，数组+链表/红黑二叉树。Java 8在链表⻓度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一说java反射">说一说Java反射？<a href="#说一说java反射" class="hash-link" aria-label="说一说Java反射？的直接链接" title="说一说Java反射？的直接链接">​</a></h3><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><ul><li>优点：能够运行时动态获取类的实例，提高灵活性；可与动态编译结合<code>Class.forName(&#x27;com.mysql.jdbc.Driver.class&#x27;);</code>，加载<a href="https://www.wkcto.com/courses/mysql.html" target="_blank" rel="noopener noreferrer">MySQL</a>的驱动类。</li><li>缺点：使用反射性能较低，需要解析字节码，将内存中的对象进行解析。其解决方案是：通过setAccessible(true)关闭JDK的安全检查来提升反射速度；多次创建一个类的实例时，有缓存会快很多；ReflflectASM工具类，通过字节码生成的方式加快反射速度。</li></ul><blockquote><p>应用场景</p></blockquote><ol><li>JDBC连接数据库时使用<code>Class.forName()</code>通过反射加载数据库的驱动程序</li><li>Eclispe、IDEA等开发工具利用反射动态解析对象的类型与结构，动态提示对象的属性和方法</li><li>Web服务器中利用反射调用了Sevlet的<code>service</code>方法</li><li>JDK动态代理底层依赖反射实现</li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/zhiyu1998/Computer-Science-Learn-Notes/edit/master/docs/Java/eightpart/foundation.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intro"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">intro</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/concurrency"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">concurrency</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#️-java基础" class="table-of-contents__link toc-highlight">☕️ Java基础</a><ul><li><a href="#java-8的接新增了哪些特性" class="table-of-contents__link toc-highlight">Java 8的接⼝新增了哪些特性？</a></li><li><a href="#重载和重写的区别" class="table-of-contents__link toc-highlight">重载和重写的区别？</a></li><li><a href="#内部类了解吗" class="table-of-contents__link toc-highlight">内部类了解吗？</a></li><li><a href="#hashset-如何检查重复" class="table-of-contents__link toc-highlight">HashSet 如何检查重复</a></li><li><a href="#构造法有哪些特性" class="table-of-contents__link toc-highlight">构造⽅法有哪些特性？</a></li><li><a href="#finalstaticthissuper-关键字总结" class="table-of-contents__link toc-highlight">final,static,this,super 关键字总结</a></li><li><a href="#this与super的区别" class="table-of-contents__link toc-highlight">this与super的区别</a></li><li><a href="#静态代理和动态代理" class="table-of-contents__link toc-highlight">静态代理和动态代理</a></li><li><a href="#static静态代码块与非静态代码块构造代码块" class="table-of-contents__link toc-highlight">static{}静态代码块与{}非静态代码块(构造代码块)</a></li><li><a href="#char型变量中能否能不能存储个中汉字为什么" class="table-of-contents__link toc-highlight">char型变量中能否能不能存储⼀个中⽂汉字，为什么？</a></li><li><a href="#是否可以继承string类" class="table-of-contents__link toc-highlight">是否可以继承String类？</a></li><li><a href="#谈谈你对多态的理解" class="table-of-contents__link toc-highlight">谈谈你对多态的理解？</a></li><li><a href="#构造器constructor是否可被重写override" class="table-of-contents__link toc-highlight">构造器（constructor）是否可被重写（override）？</a></li><li><a href="#java-中操作字符串都有哪些类它们之间有什么区别" class="table-of-contents__link toc-highlight">Java 中操作字符串都有哪些类？它们之间有什么区别？</a></li><li><a href="#string-str--i-和string-str--new-string1样吗" class="table-of-contents__link toc-highlight">String str = &quot;i&quot; 和String str = new String(&quot;1&quot;)⼀样吗？</a></li><li><a href="#什么是序列化反序列化" class="table-of-contents__link toc-highlight">什么是序列化反序列化?</a></li><li><a href="#final-finally-finalize的区别" class="table-of-contents__link toc-highlight">final finally finalize的区别</a></li><li><a href="#java有哪些数据类型" class="table-of-contents__link toc-highlight">⭐Java有哪些数据类型</a></li><li><a href="#float-f34是否正确" class="table-of-contents__link toc-highlight">float f=3.4;是否正确？</a></li><li><a href="#成员变量与局部变量的区别有哪些" class="table-of-contents__link toc-highlight">成员变量与局部变量的区别有哪些？</a></li><li><a href="#接口和抽象类的区别是什么" class="table-of-contents__link toc-highlight">⭐接口和抽象类的区别是什么？</a></li><li><a href="#java-泛型了解么泛型的作用什么是类型擦除" class="table-of-contents__link toc-highlight">🌠Java 泛型了解么？泛型的作用？什么是类型擦除？</a></li><li><a href="#-与-equals" class="table-of-contents__link toc-highlight">⭐== 与 equals</a></li><li><a href="#hashcode-与-equals" class="table-of-contents__link toc-highlight">hashCode 与 equals</a></li><li><a href="#如何决定使用-hashmap-还是-treemap" class="table-of-contents__link toc-highlight">如何决定使用 HashMap 还是 TreeMap？</a></li><li><a href="#hashmap-的底层实现" class="table-of-contents__link toc-highlight">⭐HashMap 的底层实现</a></li><li><a href="#hashmap源码分析" class="table-of-contents__link toc-highlight">⭐HashMap源码分析</a></li><li><a href="#hashmap-的长度为什么是-2-的幂次方" class="table-of-contents__link toc-highlight">HashMap 的长度为什么是 2 的幂次方</a></li><li><a href="#hashmap-多线程操作导致死循环问题" class="table-of-contents__link toc-highlight">HashMap 多线程操作导致死循环问题</a></li><li><a href="#为什么java只有值传递" class="table-of-contents__link toc-highlight">为什么Java只有值传递</a></li><li><a href="#异常处理总结" class="table-of-contents__link toc-highlight">异常处理总结</a></li><li><a href="#有哪些常见的-io-模型" class="table-of-contents__link toc-highlight">有哪些常见的 IO 模型?</a></li><li><a href="#bionioaio-有什么区别" class="table-of-contents__link toc-highlight">⭐BIO,NIO,AIO 有什么区别</a></li><li><a href="#java集合类框架的基本接口有哪些" class="table-of-contents__link toc-highlight">⭐Java集合类框架的基本接口有哪些？</a></li><li><a href="#-arraylist-与-linkedlist-区别" class="table-of-contents__link toc-highlight">⭐ Arraylist 与 LinkedList 区别</a></li><li><a href="#hashmap和hashtable有什么区别" class="table-of-contents__link toc-highlight">HashMap和HashTable有什么区别</a></li><li><a href="#concurrenthashmap-和-hashtable-的区别" class="table-of-contents__link toc-highlight">ConcurrentHashMap 和 Hashtable 的区别</a></li><li><a href="#concurrenthashmap线程安全的具体实现方式底层具体实现" class="table-of-contents__link toc-highlight">⭐ConcurrentHashMap线程安全的具体实现方式/底层具体实现</a></li><li><a href="#说一说java反射" class="table-of-contents__link toc-highlight">说一说Java反射？</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/Computer-Science-Learn-Notes/docs/intro">主页</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="#" class="footer__link-item">莫得</a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/zhiyu1998" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Computer Science Learn Notes, Inc. Built with Zhiyu1998.</div></div></div></footer></div>
<script src="/Computer-Science-Learn-Notes/assets/js/runtime~main.978cdf48.js"></script>
<script src="/Computer-Science-Learn-Notes/assets/js/main.7c330b06.js"></script>
</body>
</html>