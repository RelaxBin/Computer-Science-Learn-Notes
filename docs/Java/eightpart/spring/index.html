<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Java/eightpart/spring">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">spring | Computer Science Learn Notes</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/spring"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="spring | Computer Science Learn Notes"><meta data-rh="true" name="description" content="🍃 Spring系列"><meta data-rh="true" property="og:description" content="🍃 Spring系列"><link data-rh="true" rel="icon" href="/Computer-Science-Learn-Notes/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/spring"><link data-rh="true" rel="alternate" href="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/spring" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://zhiyu1998.github.io/Computer-Science-Learn-Notes/docs/Java/eightpart/spring" hreflang="x-default"><link rel="stylesheet" href="/Computer-Science-Learn-Notes/assets/css/styles.e7823470.css">
<link rel="preload" href="/Computer-Science-Learn-Notes/assets/js/runtime~main.978cdf48.js" as="script">
<link rel="preload" href="/Computer-Science-Learn-Notes/assets/js/main.7c330b06.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Computer-Science-Learn-Notes/"><div class="navbar__logo"><img src="/Computer-Science-Learn-Notes/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/Computer-Science-Learn-Notes/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Computer Science Learn Notes</b></a><a class="navbar__item navbar__link" href="/Computer-Science-Learn-Notes/docs/intro">主页</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/zhiyu1998/Computer-Science-Learn-Notes" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="搜索" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div><div class="searchHintContainer_Pkmr"><kbd class="searchHint_iIMx">ctrl</kbd><kbd class="searchHint_iIMx">K</kbd></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/Computer-Science-Learn-Notes/docs/golang/learnInProblem">目录</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/golang/learnInProblem">Go语言</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/frontend/react/">前端</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/fundamental/datastruct">基础知识</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/basic/">Java基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/giant">Java面试</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/giant">2022大厂面试题</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intro">常见面试题精选</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intro">前言</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/foundation">Java基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/concurrency">Java并发</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/virtualMachine">JVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/spring">Spring系列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/mysql">MySQL</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/redis">Redis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/distribution">分布式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/messageQueue">消息队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/netty">Netty</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/network">计算机网络</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/system">操作系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/datastruct">数据结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/intelligenceQuestion">智力题</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/think">基于面试题的一些思考</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/leetcode/">力扣刷题顺序</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/Java/leetcode/src/剑指offer/数组中重复的数字">刷题汇总</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/Computer-Science-Learn-Notes/docs/others/personal_tech">其他分享</a></div></li></ul></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/Computer-Science-Learn-Notes/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">目录</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Java面试</span><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">常见面试题精选</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Spring系列</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>spring</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="-spring系列">🍃 Spring系列<a href="#-spring系列" class="hash-link" aria-label="🍃 Spring系列的直接链接" title="🍃 Spring系列的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="️-spring中都有哪些设计模式2022热门问题">⭐️ spring中都有哪些设计模式？（2022热门问题）<a href="#️-spring中都有哪些设计模式2022热门问题" class="hash-link" aria-label="⭐️ spring中都有哪些设计模式？（2022热门问题）的直接链接" title="⭐️ spring中都有哪些设计模式？（2022热门问题）的直接链接">​</a></h3><p>1、<strong>简单工厂模式</strong>：<code>BeanFactory</code>就是简单工厂模式的体现，根据传入一个唯一标识来获得 Bean 对象。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Object getBean(String name) throws BeansException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertBeanFactoryActive();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return getBeanFactory().getBean(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2、<strong>工厂方法模式</strong>：<code>FactoryBean</code>就是典型的工厂方法模式。spring在使用<code>getBean()</code>调用获得该bean时，会自动调用该bean的<code>getObject()</code>方法。每个 Bean 都会对应一个 <code>FactoryBean</code>，如 <code>SqlSessionFactory</code> 对应 <code>SqlSessionFactoryBean</code>。</p><p>3、<strong>单例模式</strong>：一个类仅有一个实例，提供一个访问它的全局访问点。Spring 创建 Bean 实例默认是单例的。</p><p>4、<strong>适配器模式</strong>：SpringMVC中的适配器<code>HandlerAdatper</code>。由于应用会有多个Controller实现，如果需要直接调用Controller方法，那么需要先判断是由哪一个Controller处理请求，然后调用相应的方法。当增加新的 Controller，需要修改原来的逻辑，违反了开闭原则（对修改关闭，对扩展开放）。</p><p>为此，Spring提供了一个适配器接口，每一种 Controller 对应一种 <code>HandlerAdapter</code> 实现类，当请求过来，SpringMVC会调用<code>getHandler()</code>获取相应的Controller，然后获取该Controller对应的 <code>HandlerAdapter</code>，最后调用<code>HandlerAdapter</code>的<code>handle()</code>方法处理请求，实际上调用的是Controller的<code>handleRequest()</code>。每次添加新的 Controller 时，只需要增加一个适配器类就可以，无需修改原有的逻辑。</p><p>常用的处理器适配器：<code>SimpleControllerHandlerAdapter</code>，<code>HttpRequestHandlerAdapter</code>，<code>AnnotationMethodHandlerAdapter</code>。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Determine handler for the current request.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mappedHandler = getHandler(processedRequest);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Actually invoke the handler.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpRequestHandlerAdapter implements HandlerAdapter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean supports(Object handler) {//handler是被适配的对象，这里使用的是对象的适配器模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (handler instanceof HttpRequestHandler);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Nullable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ((HttpRequestHandler) handler).handleRequest(request, response);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>5、<strong>代理模式</strong>：spring 的 aop 使用了动态代理，有两种方式<code>JdkDynamicAopProxy</code>和<code>Cglib2AopProxy</code>。</p><p>6、<strong>观察者模式</strong>：spring 中 observer 模式常用的地方是 listener 的实现，如<code>ApplicationListener</code>。</p><p>7、<strong>模板模式</strong>： Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等，就使用到了模板模式。</p><blockquote><p>详细</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="工厂设计模式">工厂设计模式<a href="#工厂设计模式" class="hash-link" aria-label="工厂设计模式的直接链接" title="工厂设计模式的直接链接">​</a></h4><p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p><p><strong>两者对比：</strong></p><ul><li><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于 <code>ApplicationContext</code> 来说会占用更少的内存，程序启动速度更快。</li><li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code> ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有 <code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用 <code> ApplicationContext</code>会更多。</li></ul><p>ApplicationContext的三个实现类：</p><ol><li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li><li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li><li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li></ol><p>Example:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.context.ApplicationContext;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.context.support.FileSystemXmlApplicationContext;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class App {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ApplicationContext context = new FileSystemXmlApplicationContext(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &quot;C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HelloApplicationContext obj = (HelloApplicationContext) context.getBean(&quot;helloApplicationContext&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        obj.getMsg();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="单例设计模式">单例设计模式<a href="#单例设计模式" class="hash-link" aria-label="单例设计模式的直接链接" title="单例设计模式的直接链接">​</a></h4><p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p><p><strong>使用单例模式的好处:</strong></p><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p><ul><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li><li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li><li>global-session：  全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet  都有不同的会话</li></ul><p><strong>Spring 实现单例的方式：</strong></p><ul><li>xml : <code>&lt;bean id=&quot;userService&quot; class=&quot;top.snailclimb.UserService&quot; scope=&quot;singleton&quot;/&gt;</code></li><li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li></ul><p><strong>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下</strong></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(64);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Assert.notNull(beanName, &quot;&#x27;beanName&#x27; must not be null&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (this.singletonObjects) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 检查缓存中是否存在实例  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object singletonObject = this.singletonObjects.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (singletonObject == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //...省略了很多代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    singletonObject = singletonFactory.getObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //...省略了很多代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果实例对象在不存在，我们注册到单例注册表中。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                addSingleton(beanName, singletonObject);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return (singletonObject != NULL_OBJECT ? singletonObject : null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //将对象添加到单例注册表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void addSingleton(String beanName, Object singletonObject) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (this.singletonObjects) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="代理设计模式">代理设计模式<a href="#代理设计模式" class="hash-link" aria-label="代理设计模式的直接链接" title="代理设计模式的直接链接">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="代理模式在-aop-中的应用">代理模式在 AOP 中的应用<a href="#代理模式在-aop-中的应用" class="hash-link" aria-label="代理模式在 AOP 中的应用的直接链接" title="代理模式在 AOP 中的应用的直接链接">​</a></h5><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img loading="lazy" alt="image-20220616162330096" src="/Computer-Science-Learn-Notes/assets/images/image-20220616162330096-fb2f6aa3c98d362b464c0a98f5c4c03d.png" width="720" height="354" class="img_ev3q"></p><p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="模板方法">模板方法<a href="#模板方法" class="hash-link" aria-label="模板方法的直接链接" title="模板方法的直接链接">​</a></h4><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class Template {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //这是我们的模板方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final void TemplateMethod(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PrimitiveOperation1();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PrimitiveOperation2();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PrimitiveOperation3();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void  PrimitiveOperation1(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //当前类实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //被子类实现的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract void PrimitiveOperation2();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract void PrimitiveOperation3();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TemplateImpl extends Template {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void PrimitiveOperation2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //当前类实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void PrimitiveOperation3() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //当前类实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="观察者模式">观察者模式<a href="#观察者模式" class="hash-link" aria-label="观察者模式的直接链接" title="观察者模式的直接链接">​</a></h4><p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring  事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="spring-事件驱动模型中的三种角色">Spring 事件驱动模型中的三种角色<a href="#spring-事件驱动模型中的三种角色" class="hash-link" aria-label="Spring 事件驱动模型中的三种角色的直接链接" title="Spring 事件驱动模型中的三种角色的直接链接">​</a></h5><h6 class="anchor anchorWithStickyNavbar_LWe7" id="事件角色">事件角色<a href="#事件角色" class="hash-link" aria-label="事件角色的直接链接" title="事件角色的直接链接">​</a></h6><p><code>ApplicationEvent</code> (<code>org.springframework.context</code>包下)充当事件的角色,这是一个抽象类，它继承了 <code>java.util.EventObject</code>并实现了 <code>java.io.Serializable</code>接口。</p><p>Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自 <code>ApplicationContextEvent</code>)：</p><ul><li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li><li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li><li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li><li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件。</li></ul><p><img loading="lazy" alt="image-20220616162504520" src="/Computer-Science-Learn-Notes/assets/images/image-20220616162504520-e2d7112d4ed5083710e168549fa6989b.png" width="640" height="177" class="img_ev3q"></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="事件监听者角色">事件监听者角色<a href="#事件监听者角色" class="hash-link" aria-label="事件监听者角色的直接链接" title="事件监听者角色的直接链接">​</a></h6><p><code>ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code>onApplicationEvent（）</code>方法来处理 <code>ApplicationEvent</code>。<code>ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code>ApplicationEvent</code>就可以了。所以，在 Spring中我们只要实现 <code>ApplicationListener</code> 接口的 <code>onApplicationEvent()</code> 方法即可完成监听事件</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package org.springframework.context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.EventListener;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@FunctionalInterface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void onApplicationEvent(E var1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="事件发布者角色">事件发布者角色<a href="#事件发布者角色" class="hash-link" aria-label="事件发布者角色的直接链接" title="事件发布者角色的直接链接">​</a></h6><p><code>ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@FunctionalInterface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface ApplicationEventPublisher {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default void publishEvent(ApplicationEvent event) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.publishEvent((Object)event);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void publishEvent(Object var1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>ApplicationEventPublisher</code> 接口的 <code>publishEvent（）</code>这个方法在 <code>AbstractApplicationContext</code>类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过 <code>ApplicationEventMulticaster</code>来广播出去的。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="适配器模式">适配器模式<a href="#适配器模式" class="hash-link" aria-label="适配器模式的直接链接" title="适配器模式的直接链接">​</a></h4><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="spring-aop中的适配器模式">spring AOP中的适配器模式<a href="#spring-aop中的适配器模式" class="hash-link" aria-label="spring AOP中的适配器模式的直接链接" title="spring AOP中的适配器模式的直接链接">​</a></h5><p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是 <code>AdvisorAdapter </code> 。Advice 常用的类型有：<code>BeforeAdvice</code>（目标方法调用前,前置通知）、<code>AfterAdvice</code>（目标方法调用后,后置通知）、<code>AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。Spring预定义的通知要通过对应的适配器，适配成 <code>MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="spring-mvc中的适配器模式">spring MVC中的适配器模式<a href="#spring-mvc中的适配器模式" class="hash-link" aria-label="spring MVC中的适配器模式的直接链接" title="spring MVC中的适配器模式的直接链接">​</a></h5><p>在Spring MVC中，<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</p><p><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code> 直接获取对应类型的 <code>Controller</code>，需要的自行来判断，像下面这段代码一样：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if(mappedHandler.getHandler() instanceof MultiActionController){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ((MultiActionController)mappedHandler.getHandler()).xxx  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}else if(mappedHandler.getHandler() instanceof XXX){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}else if(...){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ...  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>假如我们再增加一个 <code>Controller</code>类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="装饰者模式">装饰者模式<a href="#装饰者模式" class="hash-link" aria-label="装饰者模式的直接链接" title="装饰者模式的直接链接">​</a></h4><p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code>InputStream</code>家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改 <code>InputStream</code> 代码的情况下扩展了它的功能。</p><p><img loading="lazy" alt="image-20220616162704781" src="/Computer-Science-Learn-Notes/assets/images/image-20220616162704781-6326400aeb8e7c167fa8754a32183437.png" width="744" height="334" class="img_ev3q"></p><p>Spring 中配置 DataSource 的时候，DataSource  可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code>或者 <code>Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="springboot启动流程">SpringBoot启动流程<a href="#springboot启动流程" class="hash-link" aria-label="SpringBoot启动流程的直接链接" title="SpringBoot启动流程的直接链接">​</a></h3><p><img loading="lazy" alt="image-20220627213051378" src="/Computer-Science-Learn-Notes/assets/images/image-20220627213051378-3c0e03e0e0bcfed7db7a7a764bab9475.png" width="2622" height="1527" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="bean生命周期">Bean生命周期<a href="#bean生命周期" class="hash-link" aria-label="Bean生命周期的直接链接" title="Bean生命周期的直接链接">​</a></h3><p><img loading="lazy" alt="img" src="/Computer-Science-Learn-Notes/assets/images/20220709213529-cb3087624ed040b06d746c881df7985d.png" width="643" height="485" class="img_ev3q"></p><p>1.调用bean的构造方法创建Bean</p><p>2.通过反射调用setter方法进行属性的依赖注入</p><p>3.如果Bean实现了<code>BeanNameAware</code>接口，Spring将调用<code>setBeanName</code>()，设置 <code>Bean</code>的name（xml文件中bean标签的id）</p><p>4.如果Bean实现了<code>BeanFactoryAware</code>接口，Spring将调用<code>setBeanFactory()</code>把bean factory设置给Bean</p><p>5.如果存在<code>BeanPostProcessor</code>，Spring将调用它们的<code>postProcessBeforeInitialization</code>（预初始化）方法，在Bean初始化前对其进行处理</p><p>6.如果Bean实现了<code>InitializingBean</code>接口，Spring将调用它的<code>afterPropertiesSet</code>方法，然后调用xml定义的 init-method 方法，两个方法作用类似，都是在初始化 bean 的时候执行</p><p>7.如果存在<code>BeanPostProcessor</code>，Spring将调用它们的<code>postProcessAfterInitialization</code>（后初始化）方法，在Bean初始化后对其进行处理</p><p>8.Bean初始化完成，供应用使用，这里分两种情况：</p><p>8.1 如果Bean为单例的话，那么容器会返回Bean给用户，并存入缓存池。如果Bean实现了<code>DisposableBean</code>接口，Spring将调用它的<code>destory</code>方法，然后调用在xml中定义的 <code>destory-method</code>方法，这两个方法作用类似，都是在Bean实例销毁前执行。</p><p>8.2 如果Bean是多例的话，容器将Bean返回给用户，剩下的生命周期由用户控制。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="autowired-和-resource-的区别是什么">@Autowired 和 @Resource 的区别是什么？<a href="#autowired-和-resource-的区别是什么" class="hash-link" aria-label="@Autowired 和 @Resource 的区别是什么？的直接链接" title="@Autowired 和 @Resource 的区别是什么？的直接链接">​</a></h3><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p><table><thead><tr><th align="left">Annotaion</th><th align="left">Package</th><th align="left">Source</th></tr></thead><tbody><tr><td align="left"><code>@Autowired</code></td><td align="left"><code>org.springframework.bean.factory</code></td><td align="left">Spring 2.5+</td></tr><tr><td align="left"><code>@Resource</code></td><td align="left"><code>javax.annotation</code></td><td align="left">Java JSR-250</td></tr><tr><td align="left"><code>@Inject</code></td><td align="left"><code>javax.inject</code></td><td align="left">Java JSR-330</td></tr></tbody></table><p><code>@Autowired</code> 和 <code>@Resource</code>使用的比较多一些。</p><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为 <code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 <code>smsService</code> 就是我这里所说的名称，这样应该比较好理解了吧。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// smsService 就是我们上面所说的名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private SmsService smsService;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>举个例子，<code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 报错，byName 和 byType 都无法匹配到 bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private SmsService smsService;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private SmsService smsServiceImpl1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// smsServiceImpl1 就是我们上面所说的名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private SmsService smsService;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们还是建议通过 <code>@Qualifier</code> 注解来显示指定名称而不是依赖变量的名称。</p><p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的实现类的话，注入方式会变为 <code>byType</code>。</p><p><code>@Resource</code> 有两个比较重要且日常开发常用的属性：<code>name</code>（名称）、<code>type</code>（类型）。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public @interface Resource {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String name() default &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;?&gt; type() default Object.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果仅指定 <code>name</code> 属性则注入方式为 <code>byName</code>，如果仅指定 <code>type</code>属性则注入方式为 <code>byType</code>，如果同时指定 <code>name</code> 和 <code>type</code>属性（不建议这么做）则注入方式为 <code>byType</code>+<code>byName</code>。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 报错，byName 和 byType 都无法匹配到 bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Resource</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private SmsService smsService;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Resource</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private SmsService smsServiceImpl1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Resource(name = &quot;smsServiceImpl1&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private SmsService smsService;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>简单总结一下：</p><ul><li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li><li><code>Autowired</code> 默认的注入方式为 <code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li><li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和 <code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显示指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显示指定名称。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="请描述spring-mvc的工作流程描述一下-dispatcherservlet-的工作流程">请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？<a href="#请描述spring-mvc的工作流程描述一下-dispatcherservlet-的工作流程" class="hash-link" aria-label="请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？的直接链接" title="请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？的直接链接">​</a></h3><ol><li>用户发送request请求到前端控制器DispatcherServlet。</li><li>前端控制器DispatcherServlet通过request请求的url地址，向映射器HandlerMapping请求调用对应的处理器handler。</li><li>映射器HandlerMapping通过url地址生产处理器执行链并返回。</li><li>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作。</li><li>适配器执行处理器，即执行Controller中的方法。</li><li>处理器完成业务逻辑后返回ModelAndView。</li><li>适配器将处理器的处理结果返回给前端控制器DispatcherServlet。</li><li>将ModelAndView中的view名称传给viewReslover。</li><li>viewReslover通过view名称返回具体的view。</li><li>将ModelAndView中的model注入到view。</li><li>将最终经过视图渲染的view页面响应给用户。</li></ol><p><img loading="lazy" alt="image-20220711133221313" src="/Computer-Science-Learn-Notes/assets/images/image-20220711133221313-797ee10ef4cfac7f4f8007b4e5163c14.png" width="1144" height="494" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring中构造方法注入和设值注入有什么区别">Spring中构造方法注入和设值注入有什么区别<a href="#spring中构造方法注入和设值注入有什么区别" class="hash-link" aria-label="Spring中构造方法注入和设值注入有什么区别的直接链接" title="Spring中构造方法注入和设值注入有什么区别的直接链接">​</a></h3><p>构造器通过构造方法实现，构造方法有无参数都可以。在大部分情况下我们都是通过类的构造器来创建对象，Spring也可以采用反射机制通过构造器完成注入，这就是构造器注入的原理。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Role {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String roleName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Role(long id,String roleName){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.id=id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.roleName=roleName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void getCount(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Role已被调用&quot;+&quot;\n&quot;+&quot;id:&quot;+id+&quot;\n&quot;+&quot;roleName:&quot;+roleName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>setter注入是Spring中最主流的注入方法（常用），好处就不用多说了。原理也是通过反射注入，直接上代码。（注意对应的实体类属性必须实现set，get方法。如果实体类没有属性也会被注入）。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Role {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public long getId() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setId(long id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.id = id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getRoleName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return roleName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setRoleName(String roleName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.roleName = roleName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String roleName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring怎么解决循环依赖的问题">⭐Spring怎么解决循环依赖的问题？<a href="#spring怎么解决循环依赖的问题" class="hash-link" aria-label="⭐Spring怎么解决循环依赖的问题？的直接链接" title="⭐Spring怎么解决循环依赖的问题？的直接链接">​</a></h3><p><strong>构造器注入的循环依赖：Spring处理不了</strong>，直接抛出<code>BeanCurrentlylnCreationException</code>异常。</p><p>单例模式下属性注入的循环依赖：通过<strong>三级缓存处理循环依赖</strong>。</p><p>非单例循环依赖：无法处理。</p><blockquote><p><strong>Spring为何不能解决非单例属性之外的循环依赖？</strong></p><p>Spring为什么不能解决构造器的循环依赖？</p><p>构造器注入形成的循环依赖： 也就是beanB需要在beanA的构造函数中完成初始化，beanA也需要在beanB的构造函数中完成初始化，这种情况的结果就是两个bean都不能完成初始化，循环依赖难以解决。</p><p>Spring解决循环依赖主要是依赖三级缓存，但是的<strong>在调用构造方法之前还未将其放入三级缓存之中</strong>，因此后续的依赖调用构造方法的时候并不能从三级缓存中获取到依赖的Bean，因此不能解决。</p><hr><p>Spring为什么不能解决prototype作用域循环依赖？</p><p>这种循环依赖同样无法解决，因为spring不会缓存‘prototype’作用域的bean，而spring中循环依赖的解决正是通过缓存来实现的。</p><hr><p>Spring为什么不能解决多例的循环依赖？</p><p>多实例Bean是每次调用一次getBean都会执行一次构造方法并且给属性赋值，根本没有三级缓存，因此不能解决循环依赖。</p></blockquote><p>下面分析单例模式下属性注入的循环依赖是怎么处理的：</p><p>首先，Spring单例对象的初始化大略分为三步：</p><ol><li><code>createBeanInstance</code>：实例化bean，使用构造方法创建对象，为对象分配内存。</li><li><code>populateBean</code>：进行依赖注入。</li><li><code>initializeBean</code>：初始化bean。</li></ol><p>Spring为了解决单例的循环依赖问题，使用了<strong>三级缓存</strong>：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/** Cache of singleton objects: bean name --&gt; bean instance */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/** Cache of early singleton objects: bean name --&gt; bean instance */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li><strong>第一层缓存（singletonObjects）</strong>：单例对象缓存池，已经实例化并且属性赋值，这里的对象是<strong>成熟对象</strong>；</li><li><strong>第二层缓存（earlySingletonObjects）</strong>：单例对象缓存池，已经实例化但尚未属性赋值，这里的对象是<strong>半成品对象</strong>；</li><li><strong>第三层缓存（singletonFactories）</strong>: 单例工厂的缓存</li></ul><p>如下是获取单例中</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">protected Object getSingleton(String beanName, boolean allowEarlyReference) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Spring首先从singletonObjects（一级缓存）中尝试获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Object singletonObject = this.singletonObjects.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 若是获取不到而且对象在建立中，则尝试从earlySingletonObjects(二级缓存)中获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    synchronized (this.singletonObjects) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        singletonObject = this.earlySingletonObjects.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (singletonObject == null &amp;&amp; allowEarlyReference) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (singletonFactory != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //若是仍是获取不到而且容许从singletonFactories经过getObject获取，则经过singletonFactory.getObject()(三级缓存)获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              singletonObject = singletonFactory.getObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              //若是获取到了则将singletonObject放入到earlySingletonObjects,也就是将三级缓存提高到二级缓存中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              this.earlySingletonObjects.put(beanName, singletonObject);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              this.singletonFactories.remove(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return (singletonObject != NULL_OBJECT ? singletonObject : null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>补充一些方法和参数</p><ul><li><code>isSingletonCurrentlyInCreation()</code>：判断当前单例bean是否正在建立中，也就是没有初始化完成(好比A的构造器依赖了B对象因此得先去建立B对象， 或则在A的populateBean过程当中依赖了B对象，得先去建立B对象，这时的A就是处于建立中的状态。)</li><li><code>allowEarlyReference</code> ：是否容许从singletonFactories中经过getObject拿到对象</li></ul><p>分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。若是获取不到，而且对象正在建立中，就再从二级缓存earlySingletonObjects中获取。若是仍是获取不到且容许singletonFactories经过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，若是获取到了则从三级缓存移动到了二级缓存。</p><p>从上面三级缓存的分析，咱们能够知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory，定义以下：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface ObjectFactory&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    T getObject() throws BeansException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在bean建立过程当中，有两处比较重要的匿名内部类实现了该接口。一处是Spring利用其建立bean的时候，另外一处就是:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   @Override   public Object getObject() throws BeansException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return getEarlyBeanReference(beanName, mbd, bean);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此处就是解决循环依赖的关键，这段代码发生在createBeanInstance以后，也就是说单例对象此时已经被建立出来的。这个对象已经被生产出来了，虽然还不完美（尚未进行初始化的第二步和第三步），可是已经能被人认出来了（根据对象引用能定位到堆中的对象），因此Spring此时将这个对象提早曝光出来让你们认识，让你们使用。</p><p>好比“A对象setter依赖B对象，B对象setter依赖A对象”，A首先完成了初始化的第一步，而且将本身提早曝光到singletonFactories中，此时进行初始化的第二步，发现本身依赖对象B，此时就尝试去get(B)，发现B尚未被create，因此走create流程，B在初始化第一步的时候发现本身依赖了对象A，因而尝试get(A)，尝试一级缓存singletonObjects(确定没有，由于A还没初始化彻底)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，因为A经过ObjectFactory将本身提早曝光了，因此B可以经过ObjectFactory.getObject拿到A对象(半成品)，B拿到A对象后顺利完成了初始化阶段一、二、三，彻底初始化以后将本身放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成本身的初始化阶段二、三，最终A也完成了初始化，进去了一级缓存singletonObjects中，并且更加幸运的是，因为B拿到了A的对象引用，因此B如今hold住的A对象完成了初始化。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="transactional失效场景">Transactional失效场景<a href="#transactional失效场景" class="hash-link" aria-label="Transactional失效场景的直接链接" title="Transactional失效场景的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="transactional注解标注方法修饰符为非public">Transactional注解标注方法修饰符为非public<a href="#transactional注解标注方法修饰符为非public" class="hash-link" aria-label="Transactional注解标注方法修饰符为非public的直接链接" title="Transactional注解标注方法修饰符为非public的直接链接">​</a></h4><p>如果<code>Transactional</code>注解应用在非<code>public</code> 修饰的方法上，Transactional将会失效。</p><p>之所以会失效是因为在Spring AOP 代理时，如上图所示 <code>TransactionInterceptor</code> （事务拦截器）在目标方法执行前后进行拦截，<code>DynamicAdvisedInterceptor</code>（CglibAopProxy 的内部类）的 intercept 方法或 <code>JdkDynamicAopProxy</code> 的 invoke 方法会间接调用 <code>AbstractFallbackTransactionAttributeSource</code>的 <code>computeTransactionAttribute</code> 方法，获取Transactional 注解的事务配置信息。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">protected TransactionAttribute computeTransactionAttribute(Method method,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;?&gt; targetClass) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Don&#x27;t allow no-public methods as required.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取<code>@Transactional</code> 的属性配置信息。</p><p><strong>注意：<code>protected</code>、<code>private</code> 修饰的方法上使用 <code>@Transactional</code> 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。</strong></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="注解属性-propagation-设置错误">注解属性 propagation 设置错误<a href="#注解属性-propagation-设置错误" class="hash-link" aria-label="注解属性 propagation 设置错误的直接链接" title="注解属性 propagation 设置错误的直接链接">​</a></h4><p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p><p><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p><p><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p><p><code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="注解属性-rollbackfor-设置错误">注解属性 rollbackFor 设置错误<a href="#注解属性-rollbackfor-设置错误" class="hash-link" aria-label="注解属性 rollbackFor 设置错误的直接链接" title="注解属性 rollbackFor 设置错误的直接链接">​</a></h4><p><code>rollbackFor</code> 可以指定<strong>能够触发事务回滚</strong>的异常类型。Spring<strong>默认</strong>抛出了未检查<code>unchecked</code>异常（<strong>继承自</strong> <strong><code>RuntimeException</code></strong> 的异常）或者 <code>Error</code>才回滚事务；其他异常不会触发回滚事务。<strong>如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 rollbackFor 属性，如果未指定 rollbackFor 属性则事务不会回滚。</strong></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 希望自定义的异常可以进行回滚</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>若在目标方法中抛出的异常是 <code>rollbackFor</code> <strong>指定的异常的子类</strong>，事务同样会回滚。Spring 源码如下：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private int getDepth(Class&lt;?&gt; exceptionClass, int depth) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (exceptionClass.getName().contains(this.exceptionName)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Found it!    return depth;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// If we&#x27;ve gone as far as we can go and haven&#x27;t found it...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (exceptionClass == Throwable.class) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return getDepth(exceptionClass.getSuperclass(), depth + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="同一个类中方法调用">同一个类中方法调用<a href="#同一个类中方法调用" class="hash-link" aria-label="同一个类中方法调用的直接链接" title="同一个类中方法调用的直接链接">​</a></h4><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则<strong>外部调用方法A</strong>之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用 <code>Spring AOP </code>代理造成的，因为 <strong>只有当事务方法被 当前类以外的代码 调用时，才会由<code>Spring</code>生成的代理对象来管理。</strong></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//@Transactional</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@GetMapping(&quot;/test&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private Integer A() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CityInfoDict cityInfoDict = new CityInfoDict();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cityInfoDict.setCityName(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * B 插入字段为 3的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.insertB();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * A 插入字段为 2的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int insert = cityInfoDictMapper.insert(cityInfoDict);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return insert;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Transactional()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Integer insertB() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CityInfoDict cityInfoDict = new CityInfoDict();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cityInfoDict.setCityName(&quot;3&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cityInfoDict.setParentCityId(3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return cityInfoDictMapper.insert(cityInfoDict);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="事务方法内部捕捉了异常">事务方法内部捕捉了异常<a href="#事务方法内部捕捉了异常" class="hash-link" aria-label="事务方法内部捕捉了异常的直接链接" title="事务方法内部捕捉了异常的直接链接">​</a></h4><p>这种情况是最常见的一种 <code>@Transactional</code> 注解失效场景，</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Transactional</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private Integer A() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int insert = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CityInfoDict cityInfoDict = new CityInfoDict();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cityInfoDict.setCityName(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cityInfoDict.setParentCityId(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * A 插入字段为 2的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        insert = cityInfoDictMapper.insert(cityInfoDict);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * B 插入字段为 3的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        b.insertB();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？</p><p>答案：不能！</p><p>会抛出异常：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因为当<code>ServiceB</code>中抛出了一个异常以后，<code>ServiceB</code>标识当前事务需要<code>rollback</code>。但是<code>ServiceA</code>中由于你手动的捕获这个异常并进行处理，<code>ServiceA</code>认为当前事务应该正常<code>commit</code>。此时就出现了前后不一致，也就是因为这样，抛出了前面的<code>UnexpectedRollbackException</code>异常。</p><p><code>spring</code>的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行<code>commit</code> or <code>rollback</code>，事务是否执行取决于是否抛出<code>runtime异常</code>。如果抛出<code>runtime exception</code> 并在你的业务方法中没有catch到的话，事务会回滚。</p><p>在业务方法中一般不需要catch异常，如果<strong>非要catch一定要抛出<code>throw new RuntimeException()</code></strong>，或者注解中指定抛异常类型<strong><code>@Transactional(rollbackFor=Exception.class)</code></strong>，否则会导致事务失效，数据commit造成数据不一致，所以有些时候 try catch反倒会画蛇添足。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="数据库引擎不支持事务">数据库引擎不支持事务<a href="#数据库引擎不支持事务" class="hash-link" aria-label="数据库引擎不支持事务的直接链接" title="数据库引擎不支持事务的直接链接">​</a></h4><p>这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的<code>innodb</code>引擎。一旦数据库引擎切换成不支持事务的<code>myisam</code>，那事务就从根本上失效了。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/zhiyu1998/Computer-Science-Learn-Notes/edit/master/docs/Java/eightpart/spring.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/virtualMachine"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">virtualMachine</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/Computer-Science-Learn-Notes/docs/Java/eightpart/mysql"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">mysql</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#-spring系列" class="table-of-contents__link toc-highlight">🍃 Spring系列</a><ul><li><a href="#️-spring中都有哪些设计模式2022热门问题" class="table-of-contents__link toc-highlight">⭐️ spring中都有哪些设计模式？（2022热门问题）</a></li><li><a href="#springboot启动流程" class="table-of-contents__link toc-highlight">SpringBoot启动流程</a></li><li><a href="#bean生命周期" class="table-of-contents__link toc-highlight">Bean生命周期</a></li><li><a href="#autowired-和-resource-的区别是什么" class="table-of-contents__link toc-highlight">@Autowired 和 @Resource 的区别是什么？</a></li><li><a href="#请描述spring-mvc的工作流程描述一下-dispatcherservlet-的工作流程" class="table-of-contents__link toc-highlight">请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</a></li><li><a href="#spring中构造方法注入和设值注入有什么区别" class="table-of-contents__link toc-highlight">Spring中构造方法注入和设值注入有什么区别</a></li><li><a href="#spring怎么解决循环依赖的问题" class="table-of-contents__link toc-highlight">⭐Spring怎么解决循环依赖的问题？</a></li><li><a href="#transactional失效场景" class="table-of-contents__link toc-highlight">Transactional失效场景</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/Computer-Science-Learn-Notes/docs/intro">主页</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="#" class="footer__link-item">莫得</a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/zhiyu1998" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Computer Science Learn Notes, Inc. Built with Zhiyu1998.</div></div></div></footer></div>
<script src="/Computer-Science-Learn-Notes/assets/js/runtime~main.978cdf48.js"></script>
<script src="/Computer-Science-Learn-Notes/assets/js/main.7c330b06.js"></script>
</body>
</html>